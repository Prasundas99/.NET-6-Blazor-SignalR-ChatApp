// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: WebAPI/metadata_2.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Metadata2 {

  /// <summary>Holder for reflection information generated from WebAPI/metadata_2.proto</summary>
  public static partial class Metadata2Reflection {

    #region Descriptor
    /// <summary>File descriptor for WebAPI/metadata_2.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static Metadata2Reflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "ChdXZWJBUEkvbWV0YWRhdGFfMi5wcm90bxIKbWV0YWRhdGFfMhoUY29tbW9u",
            "L2RlY2ltYWwucHJvdG8aFWNvbW1vbi9zaGFyZWRfMS5wcm90bxodV2ViQVBJ",
            "L21ldGFkYXRhX2FkbWluXzIucHJvdG8aIldlYkFQSS9zdHJhdGVneV9kZWZp",
            "bml0aW9uXzIucHJvdG8iKQoXU3ltYm9sUmVzb2x1dGlvblJlcXVlc3QSDgoG",
            "c3ltYm9sGAEgAigJImIKFlN5bWJvbFJlc29sdXRpb25SZXBvcnQSNwoRY29u",
            "dHJhY3RfbWV0YWRhdGEYASACKAsyHC5tZXRhZGF0YV8yLkNvbnRyYWN0TWV0",
            "YWRhdGESDwoHZGVsZXRlZBgCIAEoCCIuChdDb250cmFjdE1ldGFkYXRhUmVx",
            "dWVzdBITCgtjb250cmFjdF9pZBgBIAIoDSJRChZDb250cmFjdE1ldGFkYXRh",
            "UmVwb3J0EjcKEWNvbnRyYWN0X21ldGFkYXRhGAEgASgLMhwubWV0YWRhdGFf",
            "Mi5Db250cmFjdE1ldGFkYXRhIk8KD1RpY2tTaXplQnlQcmljZRIRCgl0aWNr",
            "X3NpemUYASACKAESEgoKdGlja192YWx1ZRgCIAIoARIVCg1taW5pbXVtX3By",
            "aWNlGAMgAigBIlEKHFRpY2tTaXplQnlEYXRlVGlsbEV4cGlyYXRpb24SCgoC",
            "aWQYASACKA0SEQoJdGlja19zaXplGAIgAigBEhIKCnRpY2tfdmFsdWUYAyAC",
            "KAEitg8KEENvbnRyYWN0TWV0YWRhdGESEwoLY29udHJhY3RfaWQYASACKA0S",
            "FwoPY29udHJhY3Rfc3ltYm9sGAIgAigJEhsKE2NvcnJlY3RfcHJpY2Vfc2Nh",
            "bGUYAyACKAESGwoTZGlzcGxheV9wcmljZV9zY2FsZRgEIAIoDRIpCiFkaXNj",
            "cmV0aW9uYXJ5X2Rpc3BsYXlfcHJpY2Vfc2NhbGUYJSABKA0SEwoLZGVzY3Jp",
            "cHRpb24YBSACKAkSHAoUZXh0ZW5kZWRfZGVzY3JpcHRpb24YKyABKAkSDQoF",
            "dGl0bGUYBiACKAkSEQoJdGlja19zaXplGAcgAigBEh8KF2Rpc2NyZXRpb25h",
            "cnlfdGlja19zaXplGCQgASgBEhAKCGN1cnJlbmN5GAggAigJEhIKCnRpY2tf",
            "dmFsdWUYCSACKAESEAoIY2ZpX2NvZGUYCiACKAkSFgoOaXNfbW9zdF9hY3Rp",
            "dmUYCyABKAgSGQoRbGFzdF90cmFkaW5nX2RhdGUYDCABKBISGQoRZmlyc3Rf",
            "bm90aWNlX2RhdGUYDSABKBISIgoadW5kZXJseWluZ19jb250cmFjdF9zeW1i",
            "b2wYDiABKAkSFAoMbWFyZ2luX3N0eWxlGA8gASgNEh0KFWluc3RydW1lbnRf",
            "Z3JvdXBfbmFtZRgQIAIoCRIXCg9zZXNzaW9uX2luZm9faWQYESACKBESCwoD",
            "bWljGBIgASgJEhcKD21pY19kZXNjcmlwdGlvbhgsIAEoCRIZChFtYXJrZXRf",
            "ZGF0YV9kZWxheRgUIAEoEhIYChBlbmRfb2ZfZGF5X2RlbGF5GDsgASgSEiMK",
            "G3Nob3J0X2luc3RydW1lbnRfZ3JvdXBfbmFtZRgVIAIoCRIkChxpbnN0cnVt",
            "ZW50X2dyb3VwX2Rlc2NyaXB0aW9uGBYgAigJEjgKE3RpY2tfc2l6ZXNfYnlf",
            "cHJpY2UYFyADKAsyGy5tZXRhZGF0YV8yLlRpY2tTaXplQnlQcmljZRJDChF0",
            "aWNrX3NpemVzX2J5X2R0ZRgYIAMoCzIoLm1ldGFkYXRhXzIuVGlja1NpemVC",
            "eURhdGVUaWxsRXhwaXJhdGlvbhIcChR0aWNrX3NpemVzX2J5X2R0ZV9pZBgZ",
            "IAEoDRIOCgZzdHJpa2UYGiABKBESFAoMc3RyaWtlX3ByaWNlGBsgASgBEhIK",
            "CmRpYWxlY3RfaWQYHCABKAkSFAoMY291bnRyeV9jb2RlGB0gAigJEkYKE3N0",
            "cmF0ZWd5X2RlZmluaXRpb24YHiABKAsyKS5zdHJhdGVneV9kZWZpbml0aW9u",
            "XzIuU3RyYXRlZ3lEZWZpbml0aW9uEhUKDWNvbnRyYWN0X3NpemUYHyABKAkS",
            "GQoRcG9zaXRpb25fdHJhY2tpbmcYICABKA0SKAoZc3BlY3VsYXRpb25fdHlw",
            "ZV9yZXF1aXJlZBghIAEoCDoFZmFsc2USGwoTbWF0dXJpdHlfbW9udGhfeWVh",
            "chgiIAEoCRIVCg1tYXR1cml0eV9kYXRlGDUgASgSEjgKEnByaWNlX2Rpc3Bs",
            "YXlfbW9kZRgjIAEoDjIcLm1ldGFkYXRhXzIuUHJpY2VEaXNwbGF5TW9kZRJG",
            "CiBkaXNjcmV0aW9uYXJ5X3ByaWNlX2Rpc3BsYXlfbW9kZRgmIAEoDjIcLm1l",
            "dGFkYXRhXzIuUHJpY2VEaXNwbGF5TW9kZRIYChBmb3JlaWduX2N1cnJlbmN5",
            "GCcgASgJEiIKDHZvbHVtZV9zY2FsZRgoIAEoCzIMLmNxZy5EZWNpbWFsEiIK",
            "F3ZvbHVtZV9kaXNwbGF5X2V4cG9uZW50GCkgASgROgEwEioKFHRyYWRlX3Np",
            "emVfaW5jcmVtZW50GCogASgLMgwuY3FnLkRlY2ltYWwSIQoZaGFzX2ludmVy",
            "dGVkX3ByaWNlX2xhZGRlchg8IAEoCBIkChxkb21fbGFkZGVyX2NvbXByZXNz",
            "aW9uX3JhdGlvGC0gASgNEiUKFmV4cGVjdF9vZmZfdGlja19wcmljZXMYLiAB",
            "KAg6BWZhbHNlEiEKE2hhc19leGNoYW5nZV92b2x1bWUYLyABKAg6BHRydWUS",
            "EgoKaGFzX3lpZWxkcxg9IAEoCBIMCgRpc2luGDAgASgJEhoKEm1haW50ZW5h",
            "bmNlX21hcmdpbhgxIAEoARIsChZjb250cmFjdF9zaXplX2luX3VuaXRzGDIg",
            "ASgLMgwuY3FnLkRlY2ltYWwSKgoSY29udHJhY3Rfc2l6ZV91bml0GDMgASgL",
            "Mg4uc2hhcmVkXzEuVGV4dBIaChJsYXN0X2RlbGl2ZXJ5X2RhdGUYNCABKBIS",
            "RwoWY29udHJpYnV0b3JfcGFyYW1ldGVycxg2IAMoCzInLm1ldGFkYXRhX2Fk",
            "bWluXzIuQ29udHJpYnV0b3JQYXJhbWV0ZXJzEhMKC3BlcmlvZF90eXBlGDcg",
            "ASgNEhQKDHBlcmlvZF92YWx1ZRg4IAEoDRIRCglzeW1ib2xfaWQYOSABKAkS",
            "FgoHZGVsZXRlZBg6IAEoCDoFZmFsc2UiQAoLTWFyZ2luU3R5bGUSFwoTTUFS",
            "R0lOX1NUWUxFX0ZVVFVSRRABEhgKFE1BUkdJTl9TVFlMRV9QUkVNSVVNEAIq",
            "tAEKFFBvc2l0aW9uVHJhY2tpbmdUeXBlEicKI1BPU0lUSU9OX1RSQUNLSU5H",
            "X1RZUEVfTkVUX1BPU0lUSU9OEAESOAo0UE9TSVRJT05fVFJBQ0tJTkdfVFlQ",
            "RV9MT05HX1NIT1JUX1dJVEhfSU1QTElFRF9DTE9TRRACEjkKNVBPU0lUSU9O",
            "X1RSQUNLSU5HX1RZUEVfTE9OR19TSE9SVF9XSVRIX0VYUExJQ0lUX0NMT1NF",
            "EAMqdgoQUHJpY2VEaXNwbGF5TW9kZRIgChxQUklDRV9ESVNQTEFZX01PREVf",
            "TlVNRVJBVE9SEAASHgoaUFJJQ0VfRElTUExBWV9NT0RFX1JPVU5ERUQQARIg",
            "ChxQUklDRV9ESVNQTEFZX01PREVfVFJVTkNBVEVEEAIq4AIKClBlcmlvZFR5",
            "cGUSFQoRUEVSSU9EX1RZUEVfTU9OVEgQABIXChNQRVJJT0RfVFlQRV9RVUFS",
            "VEVSEAESGwoXUEVSSU9EX1RZUEVfU0VNSV9BTk5VQUwQAhIUChBQRVJJT0Rf",
            "VFlQRV9ZRUFSEAMSGwoXUEVSSU9EX1RZUEVfREFZX09GX1dFRUsQBBIcChhQ",
            "RVJJT0RfVFlQRV9EQVlfT0ZfTU9OVEgQBRIbChdQRVJJT0RfVFlQRV9EQVlf",
            "T0ZfWUVBUhAGEh0KGVBFUklPRF9UWVBFX1dFRUtfT0ZfTU9OVEgQBxIcChhQ",
            "RVJJT0RfVFlQRV9XRUVLX09GX1lFQVIQCBIWChJQRVJJT0RfVFlQRV9TRUNP",
            "TkQQCRIWChJQRVJJT0RfVFlQRV9NSU5VVEUQChIUChBQRVJJT0RfVFlQRV9I",
            "T1VSEAsSFAoQUEVSSU9EX1RZUEVfREFURRAM"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Cqg.DecimalReflection.Descriptor, global::Shared1.Shared1Reflection.Descriptor, global::MetadataAdmin2.MetadataAdmin2Reflection.Descriptor, global::StrategyDefinition2.StrategyDefinition2Reflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(new[] {typeof(global::Metadata2.PositionTrackingType), typeof(global::Metadata2.PriceDisplayMode), typeof(global::Metadata2.PeriodType), }, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Metadata2.SymbolResolutionRequest), global::Metadata2.SymbolResolutionRequest.Parser, new[]{ "Symbol" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Metadata2.SymbolResolutionReport), global::Metadata2.SymbolResolutionReport.Parser, new[]{ "ContractMetadata", "Deleted" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Metadata2.ContractMetadataRequest), global::Metadata2.ContractMetadataRequest.Parser, new[]{ "ContractId" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Metadata2.ContractMetadataReport), global::Metadata2.ContractMetadataReport.Parser, new[]{ "ContractMetadata" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Metadata2.TickSizeByPrice), global::Metadata2.TickSizeByPrice.Parser, new[]{ "TickSize", "TickValue", "MinimumPrice" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Metadata2.TickSizeByDateTillExpiration), global::Metadata2.TickSizeByDateTillExpiration.Parser, new[]{ "Id", "TickSize", "TickValue" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Metadata2.ContractMetadata), global::Metadata2.ContractMetadata.Parser, new[]{ "ContractId", "ContractSymbol", "CorrectPriceScale", "DisplayPriceScale", "DiscretionaryDisplayPriceScale", "Description", "ExtendedDescription", "Title", "TickSize", "DiscretionaryTickSize", "Currency", "TickValue", "CfiCode", "IsMostActive", "LastTradingDate", "FirstNoticeDate", "UnderlyingContractSymbol", "MarginStyle", "InstrumentGroupName", "SessionInfoId", "Mic", "MicDescription", "MarketDataDelay", "EndOfDayDelay", "ShortInstrumentGroupName", "InstrumentGroupDescription", "TickSizesByPrice", "TickSizesByDte", "TickSizesByDteId", "Strike", "StrikePrice", "DialectId", "CountryCode", "StrategyDefinition", "ContractSize", "PositionTracking", "SpeculationTypeRequired", "MaturityMonthYear", "MaturityDate", "PriceDisplayMode", "DiscretionaryPriceDisplayMode", "ForeignCurrency", "VolumeScale", "VolumeDisplayExponent", "TradeSizeIncrement", "HasInvertedPriceLadder", "DomLadderCompressionRatio", "ExpectOffTickPrices", "HasExchangeVolume", "HasYields", "Isin", "MaintenanceMargin", "ContractSizeInUnits", "ContractSizeUnit", "LastDeliveryDate", "ContributorParameters", "PeriodType", "PeriodValue", "SymbolId", "Deleted" }, null, new[]{ typeof(global::Metadata2.ContractMetadata.Types.MarginStyle) }, null, null)
          }));
    }
    #endregion

  }
  #region Enums
  /// <summary>
  /// Way how to track the trader's open positions on a given contract.
  /// </summary>
  public enum PositionTrackingType {
    /// <summary>
    /// Difference between long and short open positions is tracked.
    /// </summary>
    [pbr::OriginalName("POSITION_TRACKING_TYPE_NET_POSITION")] NetPosition = 1,
    /// <summary>
    /// Long and short open positions are tracked separately.
    /// </summary>
    [pbr::OriginalName("POSITION_TRACKING_TYPE_LONG_SHORT_WITH_IMPLIED_CLOSE")] LongShortWithImpliedClose = 2,
    /// <summary>
    /// Long and short as well as today and yesterday open positions are tracked separately.
    /// The explicit order instruction to close either today or yesterday is taken into account.
    /// </summary>
    [pbr::OriginalName("POSITION_TRACKING_TYPE_LONG_SHORT_WITH_EXPLICIT_CLOSE")] LongShortWithExplicitClose = 3,
  }

  /// <summary>
  /// Recommended display mode for prices.
  /// The rules are applied according to the display scale of a contract.
  /// For combined scales like Eighths of Thirty Seconds the mode is applied only to the minor fractions (Eighths) while
  /// the major fractions (Thirty Seconds) always shown in PRICE_DISPLAY_MODE_NUMERATOR mode.
  /// Sample: TRUNCATED mode for 108 22/32 with extra 7/8 of 1/32 (108 + 22/32 + 7/256) is shown as 108'228 where 8 is calculated
  /// as 7/8 -> truncate (0.875) -> 8 (see TRUNCATED sample below).
  /// </summary>
  public enum PriceDisplayMode {
    /// <summary>
    /// The numerator of the fractional part is shown directly.
    /// Samples: for 3/8 the fractional part is shown as '3', for 7/16 - '07', for 15/100 - '15' etc.
    /// </summary>
    [pbr::OriginalName("PRICE_DISPLAY_MODE_NUMERATOR")] Numerator = 0,
    /// <summary>
    /// Rounded decimal. In this mode the fractional part is converted to the decimal fraction
    /// and then rounded to the minimum digits which are necessary to recognize the price.
    /// Samples: 3/8 -> round(0.375) -> '4', 7/8 ¨C round(0.875) -> '9', 11/16 -> round(0.6875) -> '69'.
    /// It means the same as PRICE_DISPLAY_MODE_NUMERATOR for decimal scales.
    /// </summary>
    [pbr::OriginalName("PRICE_DISPLAY_MODE_ROUNDED")] Rounded = 1,
    /// <summary>
    /// Truncated decimal. In this mode the fractional part is converted to the decimal fraction
    /// and then truncated to the minimum digits which are necessary to recognize the price.
    /// Samples: 3/8 -> truncate(0.375) -> '3', 7/8 -> truncate (0.875) -> '8', 11/16 -> truncate (0.6875) -> '68'.
    /// It means the same as PRICE_DISPLAY_MODE_NUMERATOR for decimal scales.
    /// </summary>
    [pbr::OriginalName("PRICE_DISPLAY_MODE_TRUNCATED")] Truncated = 2,
  }

  /// <summary>
  /// Describes period value type.
  /// See example in ContractMetadata.period_type and ContractMetadata.period_value.
  /// </summary>
  public enum PeriodType {
    [pbr::OriginalName("PERIOD_TYPE_MONTH")] Month = 0,
    [pbr::OriginalName("PERIOD_TYPE_QUARTER")] Quarter = 1,
    [pbr::OriginalName("PERIOD_TYPE_SEMI_ANNUAL")] SemiAnnual = 2,
    [pbr::OriginalName("PERIOD_TYPE_YEAR")] Year = 3,
    [pbr::OriginalName("PERIOD_TYPE_DAY_OF_WEEK")] DayOfWeek = 4,
    [pbr::OriginalName("PERIOD_TYPE_DAY_OF_MONTH")] DayOfMonth = 5,
    [pbr::OriginalName("PERIOD_TYPE_DAY_OF_YEAR")] DayOfYear = 6,
    [pbr::OriginalName("PERIOD_TYPE_WEEK_OF_MONTH")] WeekOfMonth = 7,
    [pbr::OriginalName("PERIOD_TYPE_WEEK_OF_YEAR")] WeekOfYear = 8,
    [pbr::OriginalName("PERIOD_TYPE_SECOND")] Second = 9,
    [pbr::OriginalName("PERIOD_TYPE_MINUTE")] Minute = 10,
    [pbr::OriginalName("PERIOD_TYPE_HOUR")] Hour = 11,
    [pbr::OriginalName("PERIOD_TYPE_DATE")] Date = 12,
  }

  #endregion

  #region Messages
  /// <summary>
  /// Request to resolve a symbol pattern or specific symbol identifier to a specific contract with optional subscription for meta-data updates.
  /// Symbol resolution rules:
  ///   a) If the requested symbol points to a symbol prefix rather than a specific contract then it is resolved into the most active contract for
  ///      this symbol prefix (e.g. 'EP' is resolved to 'EPU3').
  ///      The update is sent when an active contract is changed (e.g. the update might contain the following 'EPZ3')
  ///   b) If the requested symbol points to a specific contract which last trading date was less than 30 days ago (by default) SymbolResolutionReport is returned with 'deleted' field set to True.
  ///      Else if contract's last trading day was more than 30 days ago (by default) status code NOT_FOUND is returned in InformationReport.
  ///   c) If the requested symbol points to a specific contract that is tradable right now then it is resolved to itself. Update is sent only when
  ///      meta-data for such contract is changed or expired. In case of expiration SymbolResolutionReport is returned with 'deleted' field set to True.
  ///   d) If requested symbol points to an option instrument without specific month and strike it is resolved to the lead (first non-spot) month
  ///      of the underlying future or its own front month if the underlying contract is not a future (e.g. 'C.EP' is resolved to 'C.EPU131600').
  ///      Update is sent only when the resolved option contract is expired (strike is not updated to follow underlying contract market price).
  ///   e) If requested symbol is a symbol prefix that follows '?N' or '??N' (where N is number, e.g. EP?2) then it is resolved to
  ///      Nth nearest contract.
  ///      N = 1 means 'front' contract, N = 2 means the nearest contract that follows the front, etc.
  ///      '?' and '??' are different for futures only and '?' means Nth nearest regular future and '??' means Nth nearest spot or regular future.
  ///      Update is sent when the front contract expired and replaced with the following contract (relative position change).
  ///      N = 0 is a special case that means 'most active' contract which works the same way as (a)
  /// NOTE: Available and active contract lists are updated within 24 hours of an expiring contract's final trading session.
  ///       Meta-data updates for affected contracts, when a subscription is present, are sent when the list updates occur.
  ///       Initial resolution requests use the same lists, so the best way to avoid inconsistency and unnecessary server load is to subscribe
  ///       and process updates when notified.
  /// </summary>
  public sealed partial class SymbolResolutionRequest : pb::IMessage<SymbolResolutionRequest>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<SymbolResolutionRequest> _parser = new pb::MessageParser<SymbolResolutionRequest>(() => new SymbolResolutionRequest());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<SymbolResolutionRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Metadata2.Metadata2Reflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SymbolResolutionRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SymbolResolutionRequest(SymbolResolutionRequest other) : this() {
      symbol_ = other.symbol_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SymbolResolutionRequest Clone() {
      return new SymbolResolutionRequest(this);
    }

    /// <summary>Field number for the "symbol" field.</summary>
    public const int SymbolFieldNumber = 1;
    private readonly static string SymbolDefaultValue = "";

    private string symbol_;
    /// <summary>
    /// Symbol pattern to resolve.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Symbol {
      get { return symbol_ ?? SymbolDefaultValue; }
      set {
        symbol_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "symbol" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasSymbol {
      get { return symbol_ != null; }
    }
    /// <summary>Clears the value of the "symbol" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearSymbol() {
      symbol_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as SymbolResolutionRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(SymbolResolutionRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Symbol != other.Symbol) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasSymbol) hash ^= Symbol.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasSymbol) {
        output.WriteRawTag(10);
        output.WriteString(Symbol);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasSymbol) {
        output.WriteRawTag(10);
        output.WriteString(Symbol);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (HasSymbol) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Symbol);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(SymbolResolutionRequest other) {
      if (other == null) {
        return;
      }
      if (other.HasSymbol) {
        Symbol = other.Symbol;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Symbol = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Symbol = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Symbol resolution result or update.
  /// </summary>
  public sealed partial class SymbolResolutionReport : pb::IMessage<SymbolResolutionReport>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<SymbolResolutionReport> _parser = new pb::MessageParser<SymbolResolutionReport>(() => new SymbolResolutionReport());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<SymbolResolutionReport> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Metadata2.Metadata2Reflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SymbolResolutionReport() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SymbolResolutionReport(SymbolResolutionReport other) : this() {
      _hasBits0 = other._hasBits0;
      contractMetadata_ = other.contractMetadata_ != null ? other.contractMetadata_.Clone() : null;
      deleted_ = other.deleted_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SymbolResolutionReport Clone() {
      return new SymbolResolutionReport(this);
    }

    /// <summary>Field number for the "contract_metadata" field.</summary>
    public const int ContractMetadataFieldNumber = 1;
    private global::Metadata2.ContractMetadata contractMetadata_;
    /// <summary>
    /// Resolved contract meta-data.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Metadata2.ContractMetadata ContractMetadata {
      get { return contractMetadata_; }
      set {
        contractMetadata_ = value;
      }
    }

    /// <summary>Field number for the "deleted" field.</summary>
    public const int DeletedFieldNumber = 2;
    private readonly static bool DeletedDefaultValue = false;

    private bool deleted_;
    /// <summary>
    /// Contract is expired (used for updates).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Deleted {
      get { if ((_hasBits0 & 1) != 0) { return deleted_; } else { return DeletedDefaultValue; } }
      set {
        _hasBits0 |= 1;
        deleted_ = value;
      }
    }
    /// <summary>Gets whether the "deleted" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasDeleted {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "deleted" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearDeleted() {
      _hasBits0 &= ~1;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as SymbolResolutionReport);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(SymbolResolutionReport other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(ContractMetadata, other.ContractMetadata)) return false;
      if (Deleted != other.Deleted) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (contractMetadata_ != null) hash ^= ContractMetadata.GetHashCode();
      if (HasDeleted) hash ^= Deleted.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (contractMetadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(ContractMetadata);
      }
      if (HasDeleted) {
        output.WriteRawTag(16);
        output.WriteBool(Deleted);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (contractMetadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(ContractMetadata);
      }
      if (HasDeleted) {
        output.WriteRawTag(16);
        output.WriteBool(Deleted);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (contractMetadata_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ContractMetadata);
      }
      if (HasDeleted) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(SymbolResolutionReport other) {
      if (other == null) {
        return;
      }
      if (other.contractMetadata_ != null) {
        if (contractMetadata_ == null) {
          ContractMetadata = new global::Metadata2.ContractMetadata();
        }
        ContractMetadata.MergeFrom(other.ContractMetadata);
      }
      if (other.HasDeleted) {
        Deleted = other.Deleted;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (contractMetadata_ == null) {
              ContractMetadata = new global::Metadata2.ContractMetadata();
            }
            input.ReadMessage(ContractMetadata);
            break;
          }
          case 16: {
            Deleted = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (contractMetadata_ == null) {
              ContractMetadata = new global::Metadata2.ContractMetadata();
            }
            input.ReadMessage(ContractMetadata);
            break;
          }
          case 16: {
            Deleted = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Request contract metadata by contract ID.
  /// </summary>
  public sealed partial class ContractMetadataRequest : pb::IMessage<ContractMetadataRequest>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ContractMetadataRequest> _parser = new pb::MessageParser<ContractMetadataRequest>(() => new ContractMetadataRequest());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ContractMetadataRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Metadata2.Metadata2Reflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ContractMetadataRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ContractMetadataRequest(ContractMetadataRequest other) : this() {
      _hasBits0 = other._hasBits0;
      contractId_ = other.contractId_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ContractMetadataRequest Clone() {
      return new ContractMetadataRequest(this);
    }

    /// <summary>Field number for the "contract_id" field.</summary>
    public const int ContractIdFieldNumber = 1;
    private readonly static uint ContractIdDefaultValue = 0;

    private uint contractId_;
    /// <summary>
    /// contract ID to request the metadata.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint ContractId {
      get { if ((_hasBits0 & 1) != 0) { return contractId_; } else { return ContractIdDefaultValue; } }
      set {
        _hasBits0 |= 1;
        contractId_ = value;
      }
    }
    /// <summary>Gets whether the "contract_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasContractId {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "contract_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearContractId() {
      _hasBits0 &= ~1;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ContractMetadataRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ContractMetadataRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (ContractId != other.ContractId) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasContractId) hash ^= ContractId.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasContractId) {
        output.WriteRawTag(8);
        output.WriteUInt32(ContractId);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasContractId) {
        output.WriteRawTag(8);
        output.WriteUInt32(ContractId);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (HasContractId) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(ContractId);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ContractMetadataRequest other) {
      if (other == null) {
        return;
      }
      if (other.HasContractId) {
        ContractId = other.ContractId;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            ContractId = input.ReadUInt32();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            ContractId = input.ReadUInt32();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Report with the requested contract metadata.
  /// </summary>
  public sealed partial class ContractMetadataReport : pb::IMessage<ContractMetadataReport>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ContractMetadataReport> _parser = new pb::MessageParser<ContractMetadataReport>(() => new ContractMetadataReport());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ContractMetadataReport> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Metadata2.Metadata2Reflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ContractMetadataReport() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ContractMetadataReport(ContractMetadataReport other) : this() {
      contractMetadata_ = other.contractMetadata_ != null ? other.contractMetadata_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ContractMetadataReport Clone() {
      return new ContractMetadataReport(this);
    }

    /// <summary>Field number for the "contract_metadata" field.</summary>
    public const int ContractMetadataFieldNumber = 1;
    private global::Metadata2.ContractMetadata contractMetadata_;
    /// <summary>
    /// Requested metadata if successfully found.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Metadata2.ContractMetadata ContractMetadata {
      get { return contractMetadata_; }
      set {
        contractMetadata_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ContractMetadataReport);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ContractMetadataReport other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(ContractMetadata, other.ContractMetadata)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (contractMetadata_ != null) hash ^= ContractMetadata.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (contractMetadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(ContractMetadata);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (contractMetadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(ContractMetadata);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (contractMetadata_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ContractMetadata);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ContractMetadataReport other) {
      if (other == null) {
        return;
      }
      if (other.contractMetadata_ != null) {
        if (contractMetadata_ == null) {
          ContractMetadata = new global::Metadata2.ContractMetadata();
        }
        ContractMetadata.MergeFrom(other.ContractMetadata);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (contractMetadata_ == null) {
              ContractMetadata = new global::Metadata2.ContractMetadata();
            }
            input.ReadMessage(ContractMetadata);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (contractMetadata_ == null) {
              ContractMetadata = new global::Metadata2.ContractMetadata();
            }
            input.ReadMessage(ContractMetadata);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Describes tick size and value, and the range of prices they apply in.
  /// </summary>
  public sealed partial class TickSizeByPrice : pb::IMessage<TickSizeByPrice>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<TickSizeByPrice> _parser = new pb::MessageParser<TickSizeByPrice>(() => new TickSizeByPrice());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<TickSizeByPrice> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Metadata2.Metadata2Reflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TickSizeByPrice() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TickSizeByPrice(TickSizeByPrice other) : this() {
      _hasBits0 = other._hasBits0;
      tickSize_ = other.tickSize_;
      tickValue_ = other.tickValue_;
      minimumPrice_ = other.minimumPrice_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TickSizeByPrice Clone() {
      return new TickSizeByPrice(this);
    }

    /// <summary>Field number for the "tick_size" field.</summary>
    public const int TickSizeFieldNumber = 1;
    private readonly static double TickSizeDefaultValue = 0D;

    private double tickSize_;
    /// <summary>
    /// Size or a single market tick in correct price format.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double TickSize {
      get { if ((_hasBits0 & 1) != 0) { return tickSize_; } else { return TickSizeDefaultValue; } }
      set {
        _hasBits0 |= 1;
        tickSize_ = value;
      }
    }
    /// <summary>Gets whether the "tick_size" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasTickSize {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "tick_size" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearTickSize() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "tick_value" field.</summary>
    public const int TickValueFieldNumber = 2;
    private readonly static double TickValueDefaultValue = 0D;

    private double tickValue_;
    /// <summary>
    /// Contract tick money value in the contract's currency.
    /// Zero if not applicable (e.g. for indexes).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double TickValue {
      get { if ((_hasBits0 & 2) != 0) { return tickValue_; } else { return TickValueDefaultValue; } }
      set {
        _hasBits0 |= 2;
        tickValue_ = value;
      }
    }
    /// <summary>Gets whether the "tick_value" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasTickValue {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "tick_value" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearTickValue() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "minimum_price" field.</summary>
    public const int MinimumPriceFieldNumber = 3;
    private readonly static double MinimumPriceDefaultValue = 0D;

    private double minimumPrice_;
    /// <summary>
    /// The tick size and value apply from this price (inclusive) and upper, to the next TickSizeByPrice.minimum_price, if any.
    /// The price is in correct price format.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double MinimumPrice {
      get { if ((_hasBits0 & 4) != 0) { return minimumPrice_; } else { return MinimumPriceDefaultValue; } }
      set {
        _hasBits0 |= 4;
        minimumPrice_ = value;
      }
    }
    /// <summary>Gets whether the "minimum_price" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasMinimumPrice {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "minimum_price" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearMinimumPrice() {
      _hasBits0 &= ~4;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as TickSizeByPrice);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(TickSizeByPrice other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(TickSize, other.TickSize)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(TickValue, other.TickValue)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(MinimumPrice, other.MinimumPrice)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasTickSize) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(TickSize);
      if (HasTickValue) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(TickValue);
      if (HasMinimumPrice) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(MinimumPrice);
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasTickSize) {
        output.WriteRawTag(9);
        output.WriteDouble(TickSize);
      }
      if (HasTickValue) {
        output.WriteRawTag(17);
        output.WriteDouble(TickValue);
      }
      if (HasMinimumPrice) {
        output.WriteRawTag(25);
        output.WriteDouble(MinimumPrice);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasTickSize) {
        output.WriteRawTag(9);
        output.WriteDouble(TickSize);
      }
      if (HasTickValue) {
        output.WriteRawTag(17);
        output.WriteDouble(TickValue);
      }
      if (HasMinimumPrice) {
        output.WriteRawTag(25);
        output.WriteDouble(MinimumPrice);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (HasTickSize) {
        size += 1 + 8;
      }
      if (HasTickValue) {
        size += 1 + 8;
      }
      if (HasMinimumPrice) {
        size += 1 + 8;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(TickSizeByPrice other) {
      if (other == null) {
        return;
      }
      if (other.HasTickSize) {
        TickSize = other.TickSize;
      }
      if (other.HasTickValue) {
        TickValue = other.TickValue;
      }
      if (other.HasMinimumPrice) {
        MinimumPrice = other.MinimumPrice;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 9: {
            TickSize = input.ReadDouble();
            break;
          }
          case 17: {
            TickValue = input.ReadDouble();
            break;
          }
          case 25: {
            MinimumPrice = input.ReadDouble();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 9: {
            TickSize = input.ReadDouble();
            break;
          }
          case 17: {
            TickValue = input.ReadDouble();
            break;
          }
          case 25: {
            MinimumPrice = input.ReadDouble();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Describes tick size and value applied within some range of dates.
  /// </summary>
  public sealed partial class TickSizeByDateTillExpiration : pb::IMessage<TickSizeByDateTillExpiration>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<TickSizeByDateTillExpiration> _parser = new pb::MessageParser<TickSizeByDateTillExpiration>(() => new TickSizeByDateTillExpiration());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<TickSizeByDateTillExpiration> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Metadata2.Metadata2Reflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TickSizeByDateTillExpiration() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TickSizeByDateTillExpiration(TickSizeByDateTillExpiration other) : this() {
      _hasBits0 = other._hasBits0;
      id_ = other.id_;
      tickSize_ = other.tickSize_;
      tickValue_ = other.tickValue_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TickSizeByDateTillExpiration Clone() {
      return new TickSizeByDateTillExpiration(this);
    }

    /// <summary>Field number for the "id" field.</summary>
    public const int IdFieldNumber = 1;
    private readonly static uint IdDefaultValue = 0;

    private uint id_;
    /// <summary>
    /// Id of the record.  Starts from 0.  The record with id of 0 applies immediately before contract expiration, id of 1
    /// applies before 0th, etc.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint Id {
      get { if ((_hasBits0 & 1) != 0) { return id_; } else { return IdDefaultValue; } }
      set {
        _hasBits0 |= 1;
        id_ = value;
      }
    }
    /// <summary>Gets whether the "id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasId {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearId() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "tick_size" field.</summary>
    public const int TickSizeFieldNumber = 2;
    private readonly static double TickSizeDefaultValue = 0D;

    private double tickSize_;
    /// <summary>
    /// Size or a single market tick in correct price format.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double TickSize {
      get { if ((_hasBits0 & 2) != 0) { return tickSize_; } else { return TickSizeDefaultValue; } }
      set {
        _hasBits0 |= 2;
        tickSize_ = value;
      }
    }
    /// <summary>Gets whether the "tick_size" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasTickSize {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "tick_size" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearTickSize() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "tick_value" field.</summary>
    public const int TickValueFieldNumber = 3;
    private readonly static double TickValueDefaultValue = 0D;

    private double tickValue_;
    /// <summary>
    /// Contract tick money value in the contract's currency.
    /// Zero if not applicable (e.g. for indexes).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double TickValue {
      get { if ((_hasBits0 & 4) != 0) { return tickValue_; } else { return TickValueDefaultValue; } }
      set {
        _hasBits0 |= 4;
        tickValue_ = value;
      }
    }
    /// <summary>Gets whether the "tick_value" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasTickValue {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "tick_value" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearTickValue() {
      _hasBits0 &= ~4;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as TickSizeByDateTillExpiration);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(TickSizeByDateTillExpiration other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Id != other.Id) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(TickSize, other.TickSize)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(TickValue, other.TickValue)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasId) hash ^= Id.GetHashCode();
      if (HasTickSize) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(TickSize);
      if (HasTickValue) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(TickValue);
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasId) {
        output.WriteRawTag(8);
        output.WriteUInt32(Id);
      }
      if (HasTickSize) {
        output.WriteRawTag(17);
        output.WriteDouble(TickSize);
      }
      if (HasTickValue) {
        output.WriteRawTag(25);
        output.WriteDouble(TickValue);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasId) {
        output.WriteRawTag(8);
        output.WriteUInt32(Id);
      }
      if (HasTickSize) {
        output.WriteRawTag(17);
        output.WriteDouble(TickSize);
      }
      if (HasTickValue) {
        output.WriteRawTag(25);
        output.WriteDouble(TickValue);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (HasId) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Id);
      }
      if (HasTickSize) {
        size += 1 + 8;
      }
      if (HasTickValue) {
        size += 1 + 8;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(TickSizeByDateTillExpiration other) {
      if (other == null) {
        return;
      }
      if (other.HasId) {
        Id = other.Id;
      }
      if (other.HasTickSize) {
        TickSize = other.TickSize;
      }
      if (other.HasTickValue) {
        TickValue = other.TickValue;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Id = input.ReadUInt32();
            break;
          }
          case 17: {
            TickSize = input.ReadDouble();
            break;
          }
          case 25: {
            TickValue = input.ReadDouble();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Id = input.ReadUInt32();
            break;
          }
          case 17: {
            TickSize = input.ReadDouble();
            break;
          }
          case 25: {
            TickValue = input.ReadDouble();
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class ContractMetadata : pb::IMessage<ContractMetadata>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ContractMetadata> _parser = new pb::MessageParser<ContractMetadata>(() => new ContractMetadata());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    private int _hasBits1;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ContractMetadata> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Metadata2.Metadata2Reflection.Descriptor.MessageTypes[6]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ContractMetadata() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ContractMetadata(ContractMetadata other) : this() {
      _hasBits0 = other._hasBits0;
      _hasBits1 = other._hasBits1;
      contractId_ = other.contractId_;
      contractSymbol_ = other.contractSymbol_;
      correctPriceScale_ = other.correctPriceScale_;
      displayPriceScale_ = other.displayPriceScale_;
      discretionaryDisplayPriceScale_ = other.discretionaryDisplayPriceScale_;
      description_ = other.description_;
      extendedDescription_ = other.extendedDescription_;
      title_ = other.title_;
      tickSize_ = other.tickSize_;
      discretionaryTickSize_ = other.discretionaryTickSize_;
      currency_ = other.currency_;
      tickValue_ = other.tickValue_;
      cfiCode_ = other.cfiCode_;
      isMostActive_ = other.isMostActive_;
      lastTradingDate_ = other.lastTradingDate_;
      firstNoticeDate_ = other.firstNoticeDate_;
      underlyingContractSymbol_ = other.underlyingContractSymbol_;
      marginStyle_ = other.marginStyle_;
      instrumentGroupName_ = other.instrumentGroupName_;
      sessionInfoId_ = other.sessionInfoId_;
      mic_ = other.mic_;
      micDescription_ = other.micDescription_;
      marketDataDelay_ = other.marketDataDelay_;
      endOfDayDelay_ = other.endOfDayDelay_;
      shortInstrumentGroupName_ = other.shortInstrumentGroupName_;
      instrumentGroupDescription_ = other.instrumentGroupDescription_;
      tickSizesByPrice_ = other.tickSizesByPrice_.Clone();
      tickSizesByDte_ = other.tickSizesByDte_.Clone();
      tickSizesByDteId_ = other.tickSizesByDteId_;
      strike_ = other.strike_;
      strikePrice_ = other.strikePrice_;
      dialectId_ = other.dialectId_;
      countryCode_ = other.countryCode_;
      strategyDefinition_ = other.strategyDefinition_ != null ? other.strategyDefinition_.Clone() : null;
      contractSize_ = other.contractSize_;
      positionTracking_ = other.positionTracking_;
      speculationTypeRequired_ = other.speculationTypeRequired_;
      maturityMonthYear_ = other.maturityMonthYear_;
      maturityDate_ = other.maturityDate_;
      priceDisplayMode_ = other.priceDisplayMode_;
      discretionaryPriceDisplayMode_ = other.discretionaryPriceDisplayMode_;
      foreignCurrency_ = other.foreignCurrency_;
      volumeScale_ = other.volumeScale_ != null ? other.volumeScale_.Clone() : null;
      volumeDisplayExponent_ = other.volumeDisplayExponent_;
      tradeSizeIncrement_ = other.tradeSizeIncrement_ != null ? other.tradeSizeIncrement_.Clone() : null;
      hasInvertedPriceLadder_ = other.hasInvertedPriceLadder_;
      domLadderCompressionRatio_ = other.domLadderCompressionRatio_;
      expectOffTickPrices_ = other.expectOffTickPrices_;
      hasExchangeVolume_ = other.hasExchangeVolume_;
      hasYields_ = other.hasYields_;
      isin_ = other.isin_;
      maintenanceMargin_ = other.maintenanceMargin_;
      contractSizeInUnits_ = other.contractSizeInUnits_ != null ? other.contractSizeInUnits_.Clone() : null;
      contractSizeUnit_ = other.contractSizeUnit_ != null ? other.contractSizeUnit_.Clone() : null;
      lastDeliveryDate_ = other.lastDeliveryDate_;
      contributorParameters_ = other.contributorParameters_.Clone();
      periodType_ = other.periodType_;
      periodValue_ = other.periodValue_;
      symbolId_ = other.symbolId_;
      deleted_ = other.deleted_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ContractMetadata Clone() {
      return new ContractMetadata(this);
    }

    /// <summary>Field number for the "contract_id" field.</summary>
    public const int ContractIdFieldNumber = 1;
    private readonly static uint ContractIdDefaultValue = 0;

    private uint contractId_;
    /// <summary>
    /// Server assigned ID for a contract, it is not the same across sessions.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint ContractId {
      get { if ((_hasBits0 & 1) != 0) { return contractId_; } else { return ContractIdDefaultValue; } }
      set {
        _hasBits0 |= 1;
        contractId_ = value;
      }
    }
    /// <summary>Gets whether the "contract_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasContractId {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "contract_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearContractId() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "contract_symbol" field.</summary>
    public const int ContractSymbolFieldNumber = 2;
    private readonly static string ContractSymbolDefaultValue = "";

    private string contractSymbol_;
    /// <summary>
    /// Full contract symbol.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ContractSymbol {
      get { return contractSymbol_ ?? ContractSymbolDefaultValue; }
      set {
        contractSymbol_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "contract_symbol" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasContractSymbol {
      get { return contractSymbol_ != null; }
    }
    /// <summary>Clears the value of the "contract_symbol" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearContractSymbol() {
      contractSymbol_ = null;
    }

    /// <summary>Field number for the "correct_price_scale" field.</summary>
    public const int CorrectPriceScaleFieldNumber = 3;
    private readonly static double CorrectPriceScaleDefaultValue = 0D;

    private double correctPriceScale_;
    /// <summary>
    /// Scale to convert prices from this protocol to correct prices
    /// (correctPrice = price * correctPriceScale).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double CorrectPriceScale {
      get { if ((_hasBits0 & 2) != 0) { return correctPriceScale_; } else { return CorrectPriceScaleDefaultValue; } }
      set {
        _hasBits0 |= 2;
        correctPriceScale_ = value;
      }
    }
    /// <summary>Gets whether the "correct_price_scale" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasCorrectPriceScale {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "correct_price_scale" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearCorrectPriceScale() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "display_price_scale" field.</summary>
    public const int DisplayPriceScaleFieldNumber = 4;
    private readonly static uint DisplayPriceScaleDefaultValue = 0;

    private uint displayPriceScale_;
    /// <summary>
    /// Display Price Scale is a number that defines conversion of float correct price to
    /// a 'native' integer display format and back.
    /// Below is the table of possible scale values.
    /// -------------------------------------------------------
    /// | Scale |       Name            |    Description      |
    /// -------------------------------------------------------
    /// | 0     |One                     |Don't scale         |
    /// | 1     |TenMinusOne             |Divide by 10        |
    /// | 2     |TenMinusTwo             |Divide by 100       |
    /// | 3     |TenMinusThree           |Divide by 1000      |
    /// | 4     |TenMinusFour            |Divide by 10000     |
    /// | 5     |TenMinusFive            |Divide by 100000    |
    /// | 6     |TenMinusSix             |Divide by 1000000   |
    /// | 7     |TenMinusSeven           |Divide by 10000000  |
    /// | 8     |TenMinusEight           |Divide by 100000000 |
    /// | 9     |TenMinusNine            |Divide by 1000000000|
    /// | 10    |TenMinusTen             |Divide by 10^10     |
    /// | 11    |TenMinusEleven          |Divide by 10^11     |
    /// | 12    |TenMinusTwelve          |Divide by 10^12     |
    /// | 13    |TenMinusThirteen        |Divide by 10^13     |
    /// | 14    |TenMinusFourteen        |Divide by 10^14     |
    /// | 15    |TenMinusFifteen         |Divide by 10^15     |
    /// | 101   |Halves                  |Divide by 2         |
    /// | 102   |Fourths                 |Divide by 4         |
    /// | 103   |Eighths                 |Divide by 8         |
    /// | 104   |Sixteenths              |Divide by 16        |
    /// | 105   |ThirtySeconds           |Divide by 32        |
    /// | 106   |SixtyFourths            |Divide by 64        |
    /// | 107   |OneHundredTwentyEighths |Divide by 128       |
    /// | 108   |TwoHundredFiftySixths   |Divide by 256       |
    /// | 109   |FiveHundredTwelths      |Divide by 512       |
    /// | 110   |OneThousandTwentyFourths|Divide by 1024      |
    /// | 201   |HalfThirtySeconds       |Similar to 64ths    |
    /// | 202   |QuarterThirtySeconds    |Similar to 128ths   |
    /// | 203   |EighthThirtySeconds     |Similar to 256ths   |
    /// | 204   |HalfSixtyFourths        |Similar to 128ths   |
    /// | 205   |QuarterSixtyFourths     |Similar to 256ths   |
    /// | 206   |SixteenthThirtySeconds  |Similar to 512ths   |
    /// -------------------------------------------------------
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint DisplayPriceScale {
      get { if ((_hasBits0 & 4) != 0) { return displayPriceScale_; } else { return DisplayPriceScaleDefaultValue; } }
      set {
        _hasBits0 |= 4;
        displayPriceScale_ = value;
      }
    }
    /// <summary>Gets whether the "display_price_scale" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasDisplayPriceScale {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "display_price_scale" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearDisplayPriceScale() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "discretionary_display_price_scale" field.</summary>
    public const int DiscretionaryDisplayPriceScaleFieldNumber = 37;
    private readonly static uint DiscretionaryDisplayPriceScaleDefaultValue = 0;

    private uint discretionaryDisplayPriceScale_;
    /// <summary>
    /// Discretionary Display Price Scale if applicable.
    /// See display_price_scale above for possible values.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint DiscretionaryDisplayPriceScale {
      get { if ((_hasBits0 & 262144) != 0) { return discretionaryDisplayPriceScale_; } else { return DiscretionaryDisplayPriceScaleDefaultValue; } }
      set {
        _hasBits0 |= 262144;
        discretionaryDisplayPriceScale_ = value;
      }
    }
    /// <summary>Gets whether the "discretionary_display_price_scale" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasDiscretionaryDisplayPriceScale {
      get { return (_hasBits0 & 262144) != 0; }
    }
    /// <summary>Clears the value of the "discretionary_display_price_scale" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearDiscretionaryDisplayPriceScale() {
      _hasBits0 &= ~262144;
    }

    /// <summary>Field number for the "description" field.</summary>
    public const int DescriptionFieldNumber = 5;
    private readonly static string DescriptionDefaultValue = "";

    private string description_;
    /// <summary>
    /// Contract description.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Description {
      get { return description_ ?? DescriptionDefaultValue; }
      set {
        description_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "description" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasDescription {
      get { return description_ != null; }
    }
    /// <summary>Clears the value of the "description" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearDescription() {
      description_ = null;
    }

    /// <summary>Field number for the "extended_description" field.</summary>
    public const int ExtendedDescriptionFieldNumber = 43;
    private readonly static string ExtendedDescriptionDefaultValue = "";

    private string extendedDescription_;
    /// <summary>
    /// Contract description with additional information, e.g. strategy legs.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ExtendedDescription {
      get { return extendedDescription_ ?? ExtendedDescriptionDefaultValue; }
      set {
        extendedDescription_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "extended_description" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasExtendedDescription {
      get { return extendedDescription_ != null; }
    }
    /// <summary>Clears the value of the "extended_description" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearExtendedDescription() {
      extendedDescription_ = null;
    }

    /// <summary>Field number for the "title" field.</summary>
    public const int TitleFieldNumber = 6;
    private readonly static string TitleDefaultValue = "";

    private string title_;
    /// <summary>
    /// Contract display name.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Title {
      get { return title_ ?? TitleDefaultValue; }
      set {
        title_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "title" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasTitle {
      get { return title_ != null; }
    }
    /// <summary>Clears the value of the "title" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearTitle() {
      title_ = null;
    }

    /// <summary>Field number for the "tick_size" field.</summary>
    public const int TickSizeFieldNumber = 7;
    private readonly static double TickSizeDefaultValue = 0D;

    private double tickSize_;
    /// <summary>
    /// Size or a single market tick in correct price format.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double TickSize {
      get { if ((_hasBits0 & 8) != 0) { return tickSize_; } else { return TickSizeDefaultValue; } }
      set {
        _hasBits0 |= 8;
        tickSize_ = value;
      }
    }
    /// <summary>Gets whether the "tick_size" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasTickSize {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "tick_size" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearTickSize() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "discretionary_tick_size" field.</summary>
    public const int DiscretionaryTickSizeFieldNumber = 36;
    private readonly static double DiscretionaryTickSizeDefaultValue = 0D;

    private double discretionaryTickSize_;
    /// <summary>
    /// Size or a single discretionary tick in correct price format if applicable.
    /// Note: to get number of discretionary ticks between nearest regular prices use:
    /// ((tick_size / discretionary_tick_size) - 1).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double DiscretionaryTickSize {
      get { if ((_hasBits0 & 131072) != 0) { return discretionaryTickSize_; } else { return DiscretionaryTickSizeDefaultValue; } }
      set {
        _hasBits0 |= 131072;
        discretionaryTickSize_ = value;
      }
    }
    /// <summary>Gets whether the "discretionary_tick_size" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasDiscretionaryTickSize {
      get { return (_hasBits0 & 131072) != 0; }
    }
    /// <summary>Clears the value of the "discretionary_tick_size" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearDiscretionaryTickSize() {
      _hasBits0 &= ~131072;
    }

    /// <summary>Field number for the "currency" field.</summary>
    public const int CurrencyFieldNumber = 8;
    private readonly static string CurrencyDefaultValue = "";

    private string currency_;
    /// <summary>
    /// Contract currency code (ISO 4217 based).
    /// Empty string if not applicable (e.g. for indexes).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Currency {
      get { return currency_ ?? CurrencyDefaultValue; }
      set {
        currency_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "currency" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasCurrency {
      get { return currency_ != null; }
    }
    /// <summary>Clears the value of the "currency" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearCurrency() {
      currency_ = null;
    }

    /// <summary>Field number for the "tick_value" field.</summary>
    public const int TickValueFieldNumber = 9;
    private readonly static double TickValueDefaultValue = 0D;

    private double tickValue_;
    /// <summary>
    /// Contract tick money value in the contract's currency.
    /// Zero if not applicable (e.g. for indexes).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double TickValue {
      get { if ((_hasBits0 & 16) != 0) { return tickValue_; } else { return TickValueDefaultValue; } }
      set {
        _hasBits0 |= 16;
        tickValue_ = value;
      }
    }
    /// <summary>Gets whether the "tick_value" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasTickValue {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "tick_value" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearTickValue() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "cfi_code" field.</summary>
    public const int CfiCodeFieldNumber = 10;
    private readonly static string CfiCodeDefaultValue = "";

    private string cfiCode_;
    /// <summary>
    /// CFI code (Classification of Financial Instruments, ISO 10962).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string CfiCode {
      get { return cfiCode_ ?? CfiCodeDefaultValue; }
      set {
        cfiCode_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "cfi_code" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasCfiCode {
      get { return cfiCode_ != null; }
    }
    /// <summary>Clears the value of the "cfi_code" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearCfiCode() {
      cfiCode_ = null;
    }

    /// <summary>Field number for the "is_most_active" field.</summary>
    public const int IsMostActiveFieldNumber = 11;
    private readonly static bool IsMostActiveDefaultValue = false;

    private bool isMostActive_;
    /// <summary>
    /// True if this contract is the most active one for derivatives.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsMostActive {
      get { if ((_hasBits0 & 32) != 0) { return isMostActive_; } else { return IsMostActiveDefaultValue; } }
      set {
        _hasBits0 |= 32;
        isMostActive_ = value;
      }
    }
    /// <summary>Gets whether the "is_most_active" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasIsMostActive {
      get { return (_hasBits0 & 32) != 0; }
    }
    /// <summary>Clears the value of the "is_most_active" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearIsMostActive() {
      _hasBits0 &= ~32;
    }

    /// <summary>Field number for the "last_trading_date" field.</summary>
    public const int LastTradingDateFieldNumber = 12;
    private readonly static long LastTradingDateDefaultValue = 0L;

    private long lastTradingDate_;
    /// <summary>
    /// Contract trading date for derivatives
    /// (local exchange date in time format, use date part only).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long LastTradingDate {
      get { if ((_hasBits0 & 64) != 0) { return lastTradingDate_; } else { return LastTradingDateDefaultValue; } }
      set {
        _hasBits0 |= 64;
        lastTradingDate_ = value;
      }
    }
    /// <summary>Gets whether the "last_trading_date" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasLastTradingDate {
      get { return (_hasBits0 & 64) != 0; }
    }
    /// <summary>Clears the value of the "last_trading_date" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearLastTradingDate() {
      _hasBits0 &= ~64;
    }

    /// <summary>Field number for the "first_notice_date" field.</summary>
    public const int FirstNoticeDateFieldNumber = 13;
    private readonly static long FirstNoticeDateDefaultValue = 0L;

    private long firstNoticeDate_;
    /// <summary>
    /// Contract first notice date
    /// (local exchange date in time format, use date part only).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long FirstNoticeDate {
      get { if ((_hasBits0 & 128) != 0) { return firstNoticeDate_; } else { return FirstNoticeDateDefaultValue; } }
      set {
        _hasBits0 |= 128;
        firstNoticeDate_ = value;
      }
    }
    /// <summary>Gets whether the "first_notice_date" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasFirstNoticeDate {
      get { return (_hasBits0 & 128) != 0; }
    }
    /// <summary>Clears the value of the "first_notice_date" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearFirstNoticeDate() {
      _hasBits0 &= ~128;
    }

    /// <summary>Field number for the "underlying_contract_symbol" field.</summary>
    public const int UnderlyingContractSymbolFieldNumber = 14;
    private readonly static string UnderlyingContractSymbolDefaultValue = "";

    private string underlyingContractSymbol_;
    /// <summary>
    /// Underlying contract symbol (e.g. for options).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string UnderlyingContractSymbol {
      get { return underlyingContractSymbol_ ?? UnderlyingContractSymbolDefaultValue; }
      set {
        underlyingContractSymbol_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "underlying_contract_symbol" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasUnderlyingContractSymbol {
      get { return underlyingContractSymbol_ != null; }
    }
    /// <summary>Clears the value of the "underlying_contract_symbol" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearUnderlyingContractSymbol() {
      underlyingContractSymbol_ = null;
    }

    /// <summary>Field number for the "margin_style" field.</summary>
    public const int MarginStyleFieldNumber = 15;
    private readonly static uint MarginStyleDefaultValue = 0;

    private uint marginStyle_;
    /// <summary>
    /// This field is associated with MarginStyle enum type.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint MarginStyle {
      get { if ((_hasBits0 & 256) != 0) { return marginStyle_; } else { return MarginStyleDefaultValue; } }
      set {
        _hasBits0 |= 256;
        marginStyle_ = value;
      }
    }
    /// <summary>Gets whether the "margin_style" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasMarginStyle {
      get { return (_hasBits0 & 256) != 0; }
    }
    /// <summary>Clears the value of the "margin_style" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearMarginStyle() {
      _hasBits0 &= ~256;
    }

    /// <summary>Field number for the "instrument_group_name" field.</summary>
    public const int InstrumentGroupNameFieldNumber = 16;
    private readonly static string InstrumentGroupNameDefaultValue = "";

    private string instrumentGroupName_;
    /// <summary>
    /// Name of a group of contracts that share the same properties (e.g. commodity name for futures and options).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string InstrumentGroupName {
      get { return instrumentGroupName_ ?? InstrumentGroupNameDefaultValue; }
      set {
        instrumentGroupName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "instrument_group_name" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasInstrumentGroupName {
      get { return instrumentGroupName_ != null; }
    }
    /// <summary>Clears the value of the "instrument_group_name" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearInstrumentGroupName() {
      instrumentGroupName_ = null;
    }

    /// <summary>Field number for the "session_info_id" field.</summary>
    public const int SessionInfoIdFieldNumber = 17;
    private readonly static int SessionInfoIdDefaultValue = 0;

    private int sessionInfoId_;
    /// <summary>
    /// ID of a session information this contract is related to.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int SessionInfoId {
      get { if ((_hasBits0 & 512) != 0) { return sessionInfoId_; } else { return SessionInfoIdDefaultValue; } }
      set {
        _hasBits0 |= 512;
        sessionInfoId_ = value;
      }
    }
    /// <summary>Gets whether the "session_info_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasSessionInfoId {
      get { return (_hasBits0 & 512) != 0; }
    }
    /// <summary>Clears the value of the "session_info_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearSessionInfoId() {
      _hasBits0 &= ~512;
    }

    /// <summary>Field number for the "mic" field.</summary>
    public const int MicFieldNumber = 18;
    private readonly static string MicDefaultValue = "";

    private string mic_;
    /// <summary>
    /// Market segment MIC (ISO 10383) of the contract (if available), e.g. 'GLBX'.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Mic {
      get { return mic_ ?? MicDefaultValue; }
      set {
        mic_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "mic" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasMic {
      get { return mic_ != null; }
    }
    /// <summary>Clears the value of the "mic" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearMic() {
      mic_ = null;
    }

    /// <summary>Field number for the "mic_description" field.</summary>
    public const int MicDescriptionFieldNumber = 44;
    private readonly static string MicDescriptionDefaultValue = "";

    private string micDescription_;
    /// <summary>
    /// Market segment MIC description (ISO 10383) of the contract (if available), e.g. 'CME GLOBEX'.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string MicDescription {
      get { return micDescription_ ?? MicDescriptionDefaultValue; }
      set {
        micDescription_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "mic_description" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasMicDescription {
      get { return micDescription_ != null; }
    }
    /// <summary>Clears the value of the "mic_description" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearMicDescription() {
      micDescription_ = null;
    }

    /// <summary>Field number for the "market_data_delay" field.</summary>
    public const int MarketDataDelayFieldNumber = 20;
    private readonly static long MarketDataDelayDefaultValue = 0L;

    private long marketDataDelay_;
    /// <summary>
    /// If user is allowed to receive only delayed data of the contract
    /// then this parameter is set to the delay value in milliseconds.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long MarketDataDelay {
      get { if ((_hasBits0 & 1024) != 0) { return marketDataDelay_; } else { return MarketDataDelayDefaultValue; } }
      set {
        _hasBits0 |= 1024;
        marketDataDelay_ = value;
      }
    }
    /// <summary>Gets whether the "market_data_delay" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasMarketDataDelay {
      get { return (_hasBits0 & 1024) != 0; }
    }
    /// <summary>Clears the value of the "market_data_delay" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearMarketDataDelay() {
      _hasBits0 &= ~1024;
    }

    /// <summary>Field number for the "end_of_day_delay" field.</summary>
    public const int EndOfDayDelayFieldNumber = 59;
    private readonly static long EndOfDayDelayDefaultValue = 0L;

    private long endOfDayDelay_;
    /// <summary>
    /// If user is not allowed to receive quotes then End of Day (EOD) data for this contract can be allowed.
    /// In case of real-time market data subscriptions only level MARKET_VALUES is supported.
    /// In case of time bar requests only Daily (or larger) bars are supported.
    /// Note: Data for current and previous trading days are available only if corresponding trading day
    /// was closed |end_of_day_delay| milliseconds ago.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long EndOfDayDelay {
      get { if ((_hasBits0 & 1073741824) != 0) { return endOfDayDelay_; } else { return EndOfDayDelayDefaultValue; } }
      set {
        _hasBits0 |= 1073741824;
        endOfDayDelay_ = value;
      }
    }
    /// <summary>Gets whether the "end_of_day_delay" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasEndOfDayDelay {
      get { return (_hasBits0 & 1073741824) != 0; }
    }
    /// <summary>Clears the value of the "end_of_day_delay" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearEndOfDayDelay() {
      _hasBits0 &= ~1073741824;
    }

    /// <summary>Field number for the "short_instrument_group_name" field.</summary>
    public const int ShortInstrumentGroupNameFieldNumber = 21;
    private readonly static string ShortInstrumentGroupNameDefaultValue = "";

    private string shortInstrumentGroupName_;
    /// <summary>
    /// Instrument group name without the prefix.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ShortInstrumentGroupName {
      get { return shortInstrumentGroupName_ ?? ShortInstrumentGroupNameDefaultValue; }
      set {
        shortInstrumentGroupName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "short_instrument_group_name" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasShortInstrumentGroupName {
      get { return shortInstrumentGroupName_ != null; }
    }
    /// <summary>Clears the value of the "short_instrument_group_name" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearShortInstrumentGroupName() {
      shortInstrumentGroupName_ = null;
    }

    /// <summary>Field number for the "instrument_group_description" field.</summary>
    public const int InstrumentGroupDescriptionFieldNumber = 22;
    private readonly static string InstrumentGroupDescriptionDefaultValue = "";

    private string instrumentGroupDescription_;
    /// <summary>
    /// Description of the instrument group.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string InstrumentGroupDescription {
      get { return instrumentGroupDescription_ ?? InstrumentGroupDescriptionDefaultValue; }
      set {
        instrumentGroupDescription_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "instrument_group_description" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasInstrumentGroupDescription {
      get { return instrumentGroupDescription_ != null; }
    }
    /// <summary>Clears the value of the "instrument_group_description" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearInstrumentGroupDescription() {
      instrumentGroupDescription_ = null;
    }

    /// <summary>Field number for the "tick_sizes_by_price" field.</summary>
    public const int TickSizesByPriceFieldNumber = 23;
    private static readonly pb::FieldCodec<global::Metadata2.TickSizeByPrice> _repeated_tickSizesByPrice_codec
        = pb::FieldCodec.ForMessage(186, global::Metadata2.TickSizeByPrice.Parser);
    private readonly pbc::RepeatedField<global::Metadata2.TickSizeByPrice> tickSizesByPrice_ = new pbc::RepeatedField<global::Metadata2.TickSizeByPrice>();
    /// <summary>
    /// Variable tick size by contract price (if available for the contract).
    /// If variable tick sizes by contract price are available, tick_size and tick_value specify the minimal tick size
    /// and value among these.
    /// Only one of tick_sizes_by_price and tick_sizes_by_dte can be specified.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Metadata2.TickSizeByPrice> TickSizesByPrice {
      get { return tickSizesByPrice_; }
    }

    /// <summary>Field number for the "tick_sizes_by_dte" field.</summary>
    public const int TickSizesByDteFieldNumber = 24;
    private static readonly pb::FieldCodec<global::Metadata2.TickSizeByDateTillExpiration> _repeated_tickSizesByDte_codec
        = pb::FieldCodec.ForMessage(194, global::Metadata2.TickSizeByDateTillExpiration.Parser);
    private readonly pbc::RepeatedField<global::Metadata2.TickSizeByDateTillExpiration> tickSizesByDte_ = new pbc::RepeatedField<global::Metadata2.TickSizeByDateTillExpiration>();
    /// <summary>
    /// Variable tick size by date till expiration (if available for the contract).  Sorted by id in ascending order.
    /// If variable tick sizes by DTE are available, tick_size and tick_value specify the tick size and value applicable at
    /// the moment of symbol resolution.
    /// Only one of tick_sizes_by_price and tick_sizes_by_dte can be specified.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Metadata2.TickSizeByDateTillExpiration> TickSizesByDte {
      get { return tickSizesByDte_; }
    }

    /// <summary>Field number for the "tick_sizes_by_dte_id" field.</summary>
    public const int TickSizesByDteIdFieldNumber = 25;
    private readonly static uint TickSizesByDteIdDefaultValue = 0;

    private uint tickSizesByDteId_;
    /// <summary>
    /// Specifies which rule of TickSizeByDateTillExpiration applies now.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint TickSizesByDteId {
      get { if ((_hasBits0 & 2048) != 0) { return tickSizesByDteId_; } else { return TickSizesByDteIdDefaultValue; } }
      set {
        _hasBits0 |= 2048;
        tickSizesByDteId_ = value;
      }
    }
    /// <summary>Gets whether the "tick_sizes_by_dte_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasTickSizesByDteId {
      get { return (_hasBits0 & 2048) != 0; }
    }
    /// <summary>Clears the value of the "tick_sizes_by_dte_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearTickSizesByDteId() {
      _hasBits0 &= ~2048;
    }

    /// <summary>Field number for the "strike" field.</summary>
    public const int StrikeFieldNumber = 26;
    private readonly static int StrikeDefaultValue = 0;

    private int strike_;
    /// <summary>
    /// Option strike display value.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int Strike {
      get { if ((_hasBits0 & 4096) != 0) { return strike_; } else { return StrikeDefaultValue; } }
      set {
        _hasBits0 |= 4096;
        strike_ = value;
      }
    }
    /// <summary>Gets whether the "strike" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasStrike {
      get { return (_hasBits0 & 4096) != 0; }
    }
    /// <summary>Clears the value of the "strike" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearStrike() {
      _hasBits0 &= ~4096;
    }

    /// <summary>Field number for the "strike_price" field.</summary>
    public const int StrikePriceFieldNumber = 27;
    private readonly static double StrikePriceDefaultValue = 0D;

    private double strikePrice_;
    /// <summary>
    /// Option strike price value (directly in correct format).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double StrikePrice {
      get { if ((_hasBits0 & 8192) != 0) { return strikePrice_; } else { return StrikePriceDefaultValue; } }
      set {
        _hasBits0 |= 8192;
        strikePrice_ = value;
      }
    }
    /// <summary>Gets whether the "strike_price" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasStrikePrice {
      get { return (_hasBits0 & 8192) != 0; }
    }
    /// <summary>Clears the value of the "strike_price" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearStrikePrice() {
      _hasBits0 &= ~8192;
    }

    /// <summary>Field number for the "dialect_id" field.</summary>
    public const int DialectIdFieldNumber = 28;
    private readonly static string DialectIdDefaultValue = "";

    private string dialectId_;
    /// <summary>
    /// Dialect of the contract symbol.
    /// 0 - CQG dialect.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string DialectId {
      get { return dialectId_ ?? DialectIdDefaultValue; }
      set {
        dialectId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "dialect_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasDialectId {
      get { return dialectId_ != null; }
    }
    /// <summary>Clears the value of the "dialect_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearDialectId() {
      dialectId_ = null;
    }

    /// <summary>Field number for the "country_code" field.</summary>
    public const int CountryCodeFieldNumber = 29;
    private readonly static string CountryCodeDefaultValue = "";

    private string countryCode_;
    /// <summary>
    /// Two-letter exchange country code (ISO 3166-1 alpha 2).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string CountryCode {
      get { return countryCode_ ?? CountryCodeDefaultValue; }
      set {
        countryCode_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "country_code" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasCountryCode {
      get { return countryCode_ != null; }
    }
    /// <summary>Clears the value of the "country_code" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearCountryCode() {
      countryCode_ = null;
    }

    /// <summary>Field number for the "strategy_definition" field.</summary>
    public const int StrategyDefinitionFieldNumber = 30;
    private global::StrategyDefinition2.StrategyDefinition strategyDefinition_;
    /// <summary>
    /// Strategy definition if the contract is of a synthetic or a user defined strategy.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::StrategyDefinition2.StrategyDefinition StrategyDefinition {
      get { return strategyDefinition_; }
      set {
        strategyDefinition_ = value;
      }
    }

    /// <summary>Field number for the "contract_size" field.</summary>
    public const int ContractSizeFieldNumber = 31;
    private readonly static string ContractSizeDefaultValue = "";

    private string contractSize_;
    /// <summary>
    /// The deliverable quantity of commodities or financial instruments underlying contract.
    /// E.g. "1,000 U.S. Barrels (42,000) Gallons", "125,000 Euro"
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ContractSize {
      get { return contractSize_ ?? ContractSizeDefaultValue; }
      set {
        contractSize_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "contract_size" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasContractSize {
      get { return contractSize_ != null; }
    }
    /// <summary>Clears the value of the "contract_size" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearContractSize() {
      contractSize_ = null;
    }

    /// <summary>Field number for the "position_tracking" field.</summary>
    public const int PositionTrackingFieldNumber = 32;
    private readonly static uint PositionTrackingDefaultValue = 0;

    private uint positionTracking_;
    /// <summary>
    /// Setting which regulates how to calculate contract open positions.
    /// POSITION_TRACKING_TYPE_NET_POSITION, if not set.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint PositionTracking {
      get { if ((_hasBits0 & 16384) != 0) { return positionTracking_; } else { return PositionTrackingDefaultValue; } }
      set {
        _hasBits0 |= 16384;
        positionTracking_ = value;
      }
    }
    /// <summary>Gets whether the "position_tracking" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasPositionTracking {
      get { return (_hasBits0 & 16384) != 0; }
    }
    /// <summary>Clears the value of the "position_tracking" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearPositionTracking() {
      _hasBits0 &= ~16384;
    }

    /// <summary>Field number for the "speculation_type_required" field.</summary>
    public const int SpeculationTypeRequiredFieldNumber = 33;
    private readonly static bool SpeculationTypeRequiredDefaultValue = false;

    private bool speculationTypeRequired_;
    /// <summary>
    /// Setting which requires whether every contract order has to specify SpeculationType instruction or not.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool SpeculationTypeRequired {
      get { if ((_hasBits0 & 32768) != 0) { return speculationTypeRequired_; } else { return SpeculationTypeRequiredDefaultValue; } }
      set {
        _hasBits0 |= 32768;
        speculationTypeRequired_ = value;
      }
    }
    /// <summary>Gets whether the "speculation_type_required" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasSpeculationTypeRequired {
      get { return (_hasBits0 & 32768) != 0; }
    }
    /// <summary>Clears the value of the "speculation_type_required" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearSpeculationTypeRequired() {
      _hasBits0 &= ~32768;
    }

    /// <summary>Field number for the "maturity_month_year" field.</summary>
    public const int MaturityMonthYearFieldNumber = 34;
    private readonly static string MaturityMonthYearDefaultValue = "";

    private string maturityMonthYear_;
    /// <summary>
    /// Month letter and 2-digit year identifying the maturity month of the contract (if applicable).
    /// Doesn't depend on dialect.
    /// Month and corresponding letter:
    /// January   F
    /// February  G
    /// March     H
    /// April     J
    /// May       K
    /// June      M
    /// July      N
    /// August    Q
    /// September U
    /// October   V
    /// November  X
    /// December  Z
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string MaturityMonthYear {
      get { return maturityMonthYear_ ?? MaturityMonthYearDefaultValue; }
      set {
        maturityMonthYear_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "maturity_month_year" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasMaturityMonthYear {
      get { return maturityMonthYear_ != null; }
    }
    /// <summary>Clears the value of the "maturity_month_year" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearMaturityMonthYear() {
      maturityMonthYear_ = null;
    }

    /// <summary>Field number for the "maturity_date" field.</summary>
    public const int MaturityDateFieldNumber = 53;
    private readonly static long MaturityDateDefaultValue = 0L;

    private long maturityDate_;
    /// <summary>
    /// Contract's maturity date (e.g. for daily futures, when maturity_month_year is not enough).
    /// (local exchange date in time format, use date part only).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long MaturityDate {
      get { if ((_hasBits0 & 67108864) != 0) { return maturityDate_; } else { return MaturityDateDefaultValue; } }
      set {
        _hasBits0 |= 67108864;
        maturityDate_ = value;
      }
    }
    /// <summary>Gets whether the "maturity_date" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasMaturityDate {
      get { return (_hasBits0 & 67108864) != 0; }
    }
    /// <summary>Clears the value of the "maturity_date" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearMaturityDate() {
      _hasBits0 &= ~67108864;
    }

    /// <summary>Field number for the "price_display_mode" field.</summary>
    public const int PriceDisplayModeFieldNumber = 35;
    private readonly static global::Metadata2.PriceDisplayMode PriceDisplayModeDefaultValue = global::Metadata2.PriceDisplayMode.Numerator;

    private global::Metadata2.PriceDisplayMode priceDisplayMode_;
    /// <summary>
    /// Recommended display mode for prices. See the PriceDisplayMode description.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Metadata2.PriceDisplayMode PriceDisplayMode {
      get { if ((_hasBits0 & 65536) != 0) { return priceDisplayMode_; } else { return PriceDisplayModeDefaultValue; } }
      set {
        _hasBits0 |= 65536;
        priceDisplayMode_ = value;
      }
    }
    /// <summary>Gets whether the "price_display_mode" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasPriceDisplayMode {
      get { return (_hasBits0 & 65536) != 0; }
    }
    /// <summary>Clears the value of the "price_display_mode" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearPriceDisplayMode() {
      _hasBits0 &= ~65536;
    }

    /// <summary>Field number for the "discretionary_price_display_mode" field.</summary>
    public const int DiscretionaryPriceDisplayModeFieldNumber = 38;
    private readonly static global::Metadata2.PriceDisplayMode DiscretionaryPriceDisplayModeDefaultValue = global::Metadata2.PriceDisplayMode.Numerator;

    private global::Metadata2.PriceDisplayMode discretionaryPriceDisplayMode_;
    /// <summary>
    /// Discretionary Display Mode if applicable.
    /// See PriceDisplayMode description.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Metadata2.PriceDisplayMode DiscretionaryPriceDisplayMode {
      get { if ((_hasBits0 & 524288) != 0) { return discretionaryPriceDisplayMode_; } else { return DiscretionaryPriceDisplayModeDefaultValue; } }
      set {
        _hasBits0 |= 524288;
        discretionaryPriceDisplayMode_ = value;
      }
    }
    /// <summary>Gets whether the "discretionary_price_display_mode" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasDiscretionaryPriceDisplayMode {
      get { return (_hasBits0 & 524288) != 0; }
    }
    /// <summary>Clears the value of the "discretionary_price_display_mode" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearDiscretionaryPriceDisplayMode() {
      _hasBits0 &= ~524288;
    }

    /// <summary>Field number for the "foreign_currency" field.</summary>
    public const int ForeignCurrencyFieldNumber = 39;
    private readonly static string ForeignCurrencyDefaultValue = "";

    private string foreignCurrency_;
    /// <summary>
    /// Currency code (ISO 4217 based). For forex contracts only. Specifies the currency bought or sold.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ForeignCurrency {
      get { return foreignCurrency_ ?? ForeignCurrencyDefaultValue; }
      set {
        foreignCurrency_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "foreign_currency" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasForeignCurrency {
      get { return foreignCurrency_ != null; }
    }
    /// <summary>Clears the value of the "foreign_currency" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearForeignCurrency() {
      foreignCurrency_ = null;
    }

    /// <summary>Field number for the "volume_scale" field.</summary>
    public const int VolumeScaleFieldNumber = 40;
    private global::Cqg.Decimal volumeScale_;
    /// <summary>
    /// Specifies a volume unit of a contract, similar to correct_price_scale.
    /// If a message contains a volume as uint64 (like Quote or TimeBar), its correct volume is calculated as:
    ///   correct_volume = Quote.volume * volume_scale.
    /// If a message contains a volume as cqg.Decimal, it is the correct volume.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Cqg.Decimal VolumeScale {
      get { return volumeScale_; }
      set {
        volumeScale_ = value;
      }
    }

    /// <summary>Field number for the "volume_display_exponent" field.</summary>
    public const int VolumeDisplayExponentFieldNumber = 41;
    private readonly static int VolumeDisplayExponentDefaultValue = 0;

    private int volumeDisplayExponent_;
    /// <summary>
    /// Specifies the recommended representation of volumes to users:
    ///  - negative numbers - -N - mean that N decimal digits should be shown.
    ///  - positive numbers - N - mean that N digits can be hidden behind a unit prefix (or unit symbol),
    ///    e.g. if N = 3, volumes can be shown as "12k".
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int VolumeDisplayExponent {
      get { if ((_hasBits0 & 1048576) != 0) { return volumeDisplayExponent_; } else { return VolumeDisplayExponentDefaultValue; } }
      set {
        _hasBits0 |= 1048576;
        volumeDisplayExponent_ = value;
      }
    }
    /// <summary>Gets whether the "volume_display_exponent" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasVolumeDisplayExponent {
      get { return (_hasBits0 & 1048576) != 0; }
    }
    /// <summary>Clears the value of the "volume_display_exponent" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearVolumeDisplayExponent() {
      _hasBits0 &= ~1048576;
    }

    /// <summary>Field number for the "trade_size_increment" field.</summary>
    public const int TradeSizeIncrementFieldNumber = 42;
    private global::Cqg.Decimal tradeSizeIncrement_;
    /// <summary>
    /// Trade volume is required to be a multiple of trade_size_increment.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Cqg.Decimal TradeSizeIncrement {
      get { return tradeSizeIncrement_; }
      set {
        tradeSizeIncrement_ = value;
      }
    }

    /// <summary>Field number for the "has_inverted_price_ladder" field.</summary>
    public const int HasInvertedPriceLadderFieldNumber = 60;
    private readonly static bool HasInvertedPriceLadderDefaultValue = false;

    private bool hasInvertedPriceLadder_;
    /// <summary>
    /// True if DOM views should be inverted: low numbers are at the top, high numbers are at the bottom.
    /// This field is usually set for fixed income contracts with "prices are yields" model.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasInvertedPriceLadder {
      get { if ((_hasBits0 & -2147483648) != 0) { return hasInvertedPriceLadder_; } else { return HasInvertedPriceLadderDefaultValue; } }
      set {
        _hasBits0 |= -2147483648;
        hasInvertedPriceLadder_ = value;
      }
    }
    /// <summary>Gets whether the "has_inverted_price_ladder" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasHasInvertedPriceLadder {
      get { return (_hasBits0 & -2147483648) != 0; }
    }
    /// <summary>Clears the value of the "has_inverted_price_ladder" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearHasInvertedPriceLadder() {
      _hasBits0 &= ~-2147483648;
    }

    /// <summary>Field number for the "dom_ladder_compression_ratio" field.</summary>
    public const int DomLadderCompressionRatioFieldNumber = 45;
    private readonly static uint DomLadderCompressionRatioDefaultValue = 0;

    private uint domLadderCompressionRatio_;
    /// <summary>
    /// The denominator (numerator is 1) of the DOM ladder compression ratio
    /// to compress the ladder to eliminate all the extra/non-quoting values.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint DomLadderCompressionRatio {
      get { if ((_hasBits0 & 2097152) != 0) { return domLadderCompressionRatio_; } else { return DomLadderCompressionRatioDefaultValue; } }
      set {
        _hasBits0 |= 2097152;
        domLadderCompressionRatio_ = value;
      }
    }
    /// <summary>Gets whether the "dom_ladder_compression_ratio" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasDomLadderCompressionRatio {
      get { return (_hasBits0 & 2097152) != 0; }
    }
    /// <summary>Clears the value of the "dom_ladder_compression_ratio" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearDomLadderCompressionRatio() {
      _hasBits0 &= ~2097152;
    }

    /// <summary>Field number for the "expect_off_tick_prices" field.</summary>
    public const int ExpectOffTickPricesFieldNumber = 46;
    private readonly static bool ExpectOffTickPricesDefaultValue = false;

    private bool expectOffTickPrices_;
    /// <summary>
    /// Whether to expect that prices may appear not on the nominal tick prices
    /// (not products of any tick_size: ordinal, variable, discretionary, etc.) to changes DOM UI behavior.
    /// Format such prices according to display_price_scale rule.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool ExpectOffTickPrices {
      get { if ((_hasBits0 & 4194304) != 0) { return expectOffTickPrices_; } else { return ExpectOffTickPricesDefaultValue; } }
      set {
        _hasBits0 |= 4194304;
        expectOffTickPrices_ = value;
      }
    }
    /// <summary>Gets whether the "expect_off_tick_prices" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasExpectOffTickPrices {
      get { return (_hasBits0 & 4194304) != 0; }
    }
    /// <summary>Clears the value of the "expect_off_tick_prices" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearExpectOffTickPrices() {
      _hasBits0 &= ~4194304;
    }

    /// <summary>Field number for the "has_exchange_volume" field.</summary>
    public const int HasExchangeVolumeFieldNumber = 47;
    private readonly static bool HasExchangeVolumeDefaultValue = true;

    private bool hasExchangeVolume_;
    /// <summary>
    /// Specifies whether exchange provides volume data or not.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasExchangeVolume {
      get { if ((_hasBits0 & 8388608) != 0) { return hasExchangeVolume_; } else { return HasExchangeVolumeDefaultValue; } }
      set {
        _hasBits0 |= 8388608;
        hasExchangeVolume_ = value;
      }
    }
    /// <summary>Gets whether the "has_exchange_volume" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasHasExchangeVolume {
      get { return (_hasBits0 & 8388608) != 0; }
    }
    /// <summary>Clears the value of the "has_exchange_volume" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearHasExchangeVolume() {
      _hasBits0 &= ~8388608;
    }

    /// <summary>Field number for the "has_yields" field.</summary>
    public const int HasYieldsFieldNumber = 61;
    private readonly static bool HasYieldsDefaultValue = false;

    private bool hasYields_;
    /// <summary>
    /// True if the contract supports yields and you can request them with MarketDataSubscription.include_yields.
    /// Note: In case the contract has "prices are yields" model this field is false and yields are provided
    /// through the price field.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasYields {
      get { if ((_hasBits1 & 1) != 0) { return hasYields_; } else { return HasYieldsDefaultValue; } }
      set {
        _hasBits1 |= 1;
        hasYields_ = value;
      }
    }
    /// <summary>Gets whether the "has_yields" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasHasYields {
      get { return (_hasBits1 & 1) != 0; }
    }
    /// <summary>Clears the value of the "has_yields" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearHasYields() {
      _hasBits1 &= ~1;
    }

    /// <summary>Field number for the "isin" field.</summary>
    public const int IsinFieldNumber = 48;
    private readonly static string IsinDefaultValue = "";

    private string isin_;
    /// <summary>
    /// The ISIN code acts an identifier for the securities.
    /// And as such is the only common denominator securities identification number that is universally recognized.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Isin {
      get { return isin_ ?? IsinDefaultValue; }
      set {
        isin_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "isin" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasIsin {
      get { return isin_ != null; }
    }
    /// <summary>Clears the value of the "isin" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearIsin() {
      isin_ = null;
    }

    /// <summary>Field number for the "maintenance_margin" field.</summary>
    public const int MaintenanceMarginFieldNumber = 49;
    private readonly static double MaintenanceMarginDefaultValue = 0D;

    private double maintenanceMargin_;
    /// <summary>
    /// Reference value for maintenance margin (required to maintain 1 lot position
    /// in this contract), expressed as money value in the contract's currency.
    /// Note the value is informational only, not updated real-time, and does not
    /// consider the account's portfolio or risk settings/parameters.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double MaintenanceMargin {
      get { if ((_hasBits0 & 16777216) != 0) { return maintenanceMargin_; } else { return MaintenanceMarginDefaultValue; } }
      set {
        _hasBits0 |= 16777216;
        maintenanceMargin_ = value;
      }
    }
    /// <summary>Gets whether the "maintenance_margin" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasMaintenanceMargin {
      get { return (_hasBits0 & 16777216) != 0; }
    }
    /// <summary>Clears the value of the "maintenance_margin" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearMaintenanceMargin() {
      _hasBits0 &= ~16777216;
    }

    /// <summary>Field number for the "contract_size_in_units" field.</summary>
    public const int ContractSizeInUnitsFieldNumber = 50;
    private global::Cqg.Decimal contractSizeInUnits_;
    /// <summary>
    /// Contract size in the number of units (where defined). Unit is defined by contract_size_unit filed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Cqg.Decimal ContractSizeInUnits {
      get { return contractSizeInUnits_; }
      set {
        contractSizeInUnits_ = value;
      }
    }

    /// <summary>Field number for the "contract_size_unit" field.</summary>
    public const int ContractSizeUnitFieldNumber = 51;
    private global::Shared1.Text contractSizeUnit_;
    /// <summary>
    /// Unit label for the contract size.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Shared1.Text ContractSizeUnit {
      get { return contractSizeUnit_; }
      set {
        contractSizeUnit_ = value;
      }
    }

    /// <summary>Field number for the "last_delivery_date" field.</summary>
    public const int LastDeliveryDateFieldNumber = 52;
    private readonly static long LastDeliveryDateDefaultValue = 0L;

    private long lastDeliveryDate_;
    /// <summary>
    /// Contract last delivery date
    /// (local exchange date in time format, use date part only).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long LastDeliveryDate {
      get { if ((_hasBits0 & 33554432) != 0) { return lastDeliveryDate_; } else { return LastDeliveryDateDefaultValue; } }
      set {
        _hasBits0 |= 33554432;
        lastDeliveryDate_ = value;
      }
    }
    /// <summary>Gets whether the "last_delivery_date" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasLastDeliveryDate {
      get { return (_hasBits0 & 33554432) != 0; }
    }
    /// <summary>Clears the value of the "last_delivery_date" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearLastDeliveryDate() {
      _hasBits0 &= ~33554432;
    }

    /// <summary>Field number for the "contributor_parameters" field.</summary>
    public const int ContributorParametersFieldNumber = 54;
    private static readonly pb::FieldCodec<global::MetadataAdmin2.ContributorParameters> _repeated_contributorParameters_codec
        = pb::FieldCodec.ForMessage(434, global::MetadataAdmin2.ContributorParameters.Parser);
    private readonly pbc::RepeatedField<global::MetadataAdmin2.ContributorParameters> contributorParameters_ = new pbc::RepeatedField<global::MetadataAdmin2.ContributorParameters>();
    /// <summary>
    /// Optional custom contract parameters per associated contributor (if any).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::MetadataAdmin2.ContributorParameters> ContributorParameters {
      get { return contributorParameters_; }
    }

    /// <summary>Field number for the "period_type" field.</summary>
    public const int PeriodTypeFieldNumber = 55;
    private readonly static uint PeriodTypeDefaultValue = 0;

    private uint periodType_;
    /// <summary>
    /// Period type. This field is associated with PeriodType enum type.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint PeriodType {
      get { if ((_hasBits0 & 134217728) != 0) { return periodType_; } else { return PeriodTypeDefaultValue; } }
      set {
        _hasBits0 |= 134217728;
        periodType_ = value;
      }
    }
    /// <summary>Gets whether the "period_type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasPeriodType {
      get { return (_hasBits0 & 134217728) != 0; }
    }
    /// <summary>Clears the value of the "period_type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearPeriodType() {
      _hasBits0 &= ~134217728;
    }

    /// <summary>Field number for the "period_value" field.</summary>
    public const int PeriodValueFieldNumber = 56;
    private readonly static uint PeriodValueDefaultValue = 0;

    private uint periodValue_;
    /// <summary>
    /// Period value in period_type units.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint PeriodValue {
      get { if ((_hasBits0 & 268435456) != 0) { return periodValue_; } else { return PeriodValueDefaultValue; } }
      set {
        _hasBits0 |= 268435456;
        periodValue_ = value;
      }
    }
    /// <summary>Gets whether the "period_value" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasPeriodValue {
      get { return (_hasBits0 & 268435456) != 0; }
    }
    /// <summary>Clears the value of the "period_value" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearPeriodValue() {
      _hasBits0 &= ~268435456;
    }

    /// <summary>Field number for the "symbol_id" field.</summary>
    public const int SymbolIdFieldNumber = 57;
    private readonly static string SymbolIdDefaultValue = "";

    private string symbolId_;
    /// <summary>
    /// ID of the symbol the contract represents (Symbol.id attribute).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string SymbolId {
      get { return symbolId_ ?? SymbolIdDefaultValue; }
      set {
        symbolId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "symbol_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasSymbolId {
      get { return symbolId_ != null; }
    }
    /// <summary>Clears the value of the "symbol_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearSymbolId() {
      symbolId_ = null;
    }

    /// <summary>Field number for the "deleted" field.</summary>
    public const int DeletedFieldNumber = 58;
    private readonly static bool DeletedDefaultValue = false;

    private bool deleted_;
    /// <summary>
    /// If contract metadata is "deleted", corresponding contract id can't be referred to in requests anymore
    /// (this happens e.g. when published contract gets unpublished).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Deleted {
      get { if ((_hasBits0 & 536870912) != 0) { return deleted_; } else { return DeletedDefaultValue; } }
      set {
        _hasBits0 |= 536870912;
        deleted_ = value;
      }
    }
    /// <summary>Gets whether the "deleted" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasDeleted {
      get { return (_hasBits0 & 536870912) != 0; }
    }
    /// <summary>Clears the value of the "deleted" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearDeleted() {
      _hasBits0 &= ~536870912;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ContractMetadata);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ContractMetadata other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (ContractId != other.ContractId) return false;
      if (ContractSymbol != other.ContractSymbol) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(CorrectPriceScale, other.CorrectPriceScale)) return false;
      if (DisplayPriceScale != other.DisplayPriceScale) return false;
      if (DiscretionaryDisplayPriceScale != other.DiscretionaryDisplayPriceScale) return false;
      if (Description != other.Description) return false;
      if (ExtendedDescription != other.ExtendedDescription) return false;
      if (Title != other.Title) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(TickSize, other.TickSize)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(DiscretionaryTickSize, other.DiscretionaryTickSize)) return false;
      if (Currency != other.Currency) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(TickValue, other.TickValue)) return false;
      if (CfiCode != other.CfiCode) return false;
      if (IsMostActive != other.IsMostActive) return false;
      if (LastTradingDate != other.LastTradingDate) return false;
      if (FirstNoticeDate != other.FirstNoticeDate) return false;
      if (UnderlyingContractSymbol != other.UnderlyingContractSymbol) return false;
      if (MarginStyle != other.MarginStyle) return false;
      if (InstrumentGroupName != other.InstrumentGroupName) return false;
      if (SessionInfoId != other.SessionInfoId) return false;
      if (Mic != other.Mic) return false;
      if (MicDescription != other.MicDescription) return false;
      if (MarketDataDelay != other.MarketDataDelay) return false;
      if (EndOfDayDelay != other.EndOfDayDelay) return false;
      if (ShortInstrumentGroupName != other.ShortInstrumentGroupName) return false;
      if (InstrumentGroupDescription != other.InstrumentGroupDescription) return false;
      if(!tickSizesByPrice_.Equals(other.tickSizesByPrice_)) return false;
      if(!tickSizesByDte_.Equals(other.tickSizesByDte_)) return false;
      if (TickSizesByDteId != other.TickSizesByDteId) return false;
      if (Strike != other.Strike) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(StrikePrice, other.StrikePrice)) return false;
      if (DialectId != other.DialectId) return false;
      if (CountryCode != other.CountryCode) return false;
      if (!object.Equals(StrategyDefinition, other.StrategyDefinition)) return false;
      if (ContractSize != other.ContractSize) return false;
      if (PositionTracking != other.PositionTracking) return false;
      if (SpeculationTypeRequired != other.SpeculationTypeRequired) return false;
      if (MaturityMonthYear != other.MaturityMonthYear) return false;
      if (MaturityDate != other.MaturityDate) return false;
      if (PriceDisplayMode != other.PriceDisplayMode) return false;
      if (DiscretionaryPriceDisplayMode != other.DiscretionaryPriceDisplayMode) return false;
      if (ForeignCurrency != other.ForeignCurrency) return false;
      if (!object.Equals(VolumeScale, other.VolumeScale)) return false;
      if (VolumeDisplayExponent != other.VolumeDisplayExponent) return false;
      if (!object.Equals(TradeSizeIncrement, other.TradeSizeIncrement)) return false;
      if (HasInvertedPriceLadder != other.HasInvertedPriceLadder) return false;
      if (DomLadderCompressionRatio != other.DomLadderCompressionRatio) return false;
      if (ExpectOffTickPrices != other.ExpectOffTickPrices) return false;
      if (HasExchangeVolume != other.HasExchangeVolume) return false;
      if (HasYields != other.HasYields) return false;
      if (Isin != other.Isin) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(MaintenanceMargin, other.MaintenanceMargin)) return false;
      if (!object.Equals(ContractSizeInUnits, other.ContractSizeInUnits)) return false;
      if (!object.Equals(ContractSizeUnit, other.ContractSizeUnit)) return false;
      if (LastDeliveryDate != other.LastDeliveryDate) return false;
      if(!contributorParameters_.Equals(other.contributorParameters_)) return false;
      if (PeriodType != other.PeriodType) return false;
      if (PeriodValue != other.PeriodValue) return false;
      if (SymbolId != other.SymbolId) return false;
      if (Deleted != other.Deleted) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasContractId) hash ^= ContractId.GetHashCode();
      if (HasContractSymbol) hash ^= ContractSymbol.GetHashCode();
      if (HasCorrectPriceScale) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(CorrectPriceScale);
      if (HasDisplayPriceScale) hash ^= DisplayPriceScale.GetHashCode();
      if (HasDiscretionaryDisplayPriceScale) hash ^= DiscretionaryDisplayPriceScale.GetHashCode();
      if (HasDescription) hash ^= Description.GetHashCode();
      if (HasExtendedDescription) hash ^= ExtendedDescription.GetHashCode();
      if (HasTitle) hash ^= Title.GetHashCode();
      if (HasTickSize) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(TickSize);
      if (HasDiscretionaryTickSize) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(DiscretionaryTickSize);
      if (HasCurrency) hash ^= Currency.GetHashCode();
      if (HasTickValue) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(TickValue);
      if (HasCfiCode) hash ^= CfiCode.GetHashCode();
      if (HasIsMostActive) hash ^= IsMostActive.GetHashCode();
      if (HasLastTradingDate) hash ^= LastTradingDate.GetHashCode();
      if (HasFirstNoticeDate) hash ^= FirstNoticeDate.GetHashCode();
      if (HasUnderlyingContractSymbol) hash ^= UnderlyingContractSymbol.GetHashCode();
      if (HasMarginStyle) hash ^= MarginStyle.GetHashCode();
      if (HasInstrumentGroupName) hash ^= InstrumentGroupName.GetHashCode();
      if (HasSessionInfoId) hash ^= SessionInfoId.GetHashCode();
      if (HasMic) hash ^= Mic.GetHashCode();
      if (HasMicDescription) hash ^= MicDescription.GetHashCode();
      if (HasMarketDataDelay) hash ^= MarketDataDelay.GetHashCode();
      if (HasEndOfDayDelay) hash ^= EndOfDayDelay.GetHashCode();
      if (HasShortInstrumentGroupName) hash ^= ShortInstrumentGroupName.GetHashCode();
      if (HasInstrumentGroupDescription) hash ^= InstrumentGroupDescription.GetHashCode();
      hash ^= tickSizesByPrice_.GetHashCode();
      hash ^= tickSizesByDte_.GetHashCode();
      if (HasTickSizesByDteId) hash ^= TickSizesByDteId.GetHashCode();
      if (HasStrike) hash ^= Strike.GetHashCode();
      if (HasStrikePrice) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(StrikePrice);
      if (HasDialectId) hash ^= DialectId.GetHashCode();
      if (HasCountryCode) hash ^= CountryCode.GetHashCode();
      if (strategyDefinition_ != null) hash ^= StrategyDefinition.GetHashCode();
      if (HasContractSize) hash ^= ContractSize.GetHashCode();
      if (HasPositionTracking) hash ^= PositionTracking.GetHashCode();
      if (HasSpeculationTypeRequired) hash ^= SpeculationTypeRequired.GetHashCode();
      if (HasMaturityMonthYear) hash ^= MaturityMonthYear.GetHashCode();
      if (HasMaturityDate) hash ^= MaturityDate.GetHashCode();
      if (HasPriceDisplayMode) hash ^= PriceDisplayMode.GetHashCode();
      if (HasDiscretionaryPriceDisplayMode) hash ^= DiscretionaryPriceDisplayMode.GetHashCode();
      if (HasForeignCurrency) hash ^= ForeignCurrency.GetHashCode();
      if (volumeScale_ != null) hash ^= VolumeScale.GetHashCode();
      if (HasVolumeDisplayExponent) hash ^= VolumeDisplayExponent.GetHashCode();
      if (tradeSizeIncrement_ != null) hash ^= TradeSizeIncrement.GetHashCode();
      if (HasHasInvertedPriceLadder) hash ^= HasInvertedPriceLadder.GetHashCode();
      if (HasDomLadderCompressionRatio) hash ^= DomLadderCompressionRatio.GetHashCode();
      if (HasExpectOffTickPrices) hash ^= ExpectOffTickPrices.GetHashCode();
      if (HasHasExchangeVolume) hash ^= HasExchangeVolume.GetHashCode();
      if (HasHasYields) hash ^= HasYields.GetHashCode();
      if (HasIsin) hash ^= Isin.GetHashCode();
      if (HasMaintenanceMargin) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(MaintenanceMargin);
      if (contractSizeInUnits_ != null) hash ^= ContractSizeInUnits.GetHashCode();
      if (contractSizeUnit_ != null) hash ^= ContractSizeUnit.GetHashCode();
      if (HasLastDeliveryDate) hash ^= LastDeliveryDate.GetHashCode();
      hash ^= contributorParameters_.GetHashCode();
      if (HasPeriodType) hash ^= PeriodType.GetHashCode();
      if (HasPeriodValue) hash ^= PeriodValue.GetHashCode();
      if (HasSymbolId) hash ^= SymbolId.GetHashCode();
      if (HasDeleted) hash ^= Deleted.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasContractId) {
        output.WriteRawTag(8);
        output.WriteUInt32(ContractId);
      }
      if (HasContractSymbol) {
        output.WriteRawTag(18);
        output.WriteString(ContractSymbol);
      }
      if (HasCorrectPriceScale) {
        output.WriteRawTag(25);
        output.WriteDouble(CorrectPriceScale);
      }
      if (HasDisplayPriceScale) {
        output.WriteRawTag(32);
        output.WriteUInt32(DisplayPriceScale);
      }
      if (HasDescription) {
        output.WriteRawTag(42);
        output.WriteString(Description);
      }
      if (HasTitle) {
        output.WriteRawTag(50);
        output.WriteString(Title);
      }
      if (HasTickSize) {
        output.WriteRawTag(57);
        output.WriteDouble(TickSize);
      }
      if (HasCurrency) {
        output.WriteRawTag(66);
        output.WriteString(Currency);
      }
      if (HasTickValue) {
        output.WriteRawTag(73);
        output.WriteDouble(TickValue);
      }
      if (HasCfiCode) {
        output.WriteRawTag(82);
        output.WriteString(CfiCode);
      }
      if (HasIsMostActive) {
        output.WriteRawTag(88);
        output.WriteBool(IsMostActive);
      }
      if (HasLastTradingDate) {
        output.WriteRawTag(96);
        output.WriteSInt64(LastTradingDate);
      }
      if (HasFirstNoticeDate) {
        output.WriteRawTag(104);
        output.WriteSInt64(FirstNoticeDate);
      }
      if (HasUnderlyingContractSymbol) {
        output.WriteRawTag(114);
        output.WriteString(UnderlyingContractSymbol);
      }
      if (HasMarginStyle) {
        output.WriteRawTag(120);
        output.WriteUInt32(MarginStyle);
      }
      if (HasInstrumentGroupName) {
        output.WriteRawTag(130, 1);
        output.WriteString(InstrumentGroupName);
      }
      if (HasSessionInfoId) {
        output.WriteRawTag(136, 1);
        output.WriteSInt32(SessionInfoId);
      }
      if (HasMic) {
        output.WriteRawTag(146, 1);
        output.WriteString(Mic);
      }
      if (HasMarketDataDelay) {
        output.WriteRawTag(160, 1);
        output.WriteSInt64(MarketDataDelay);
      }
      if (HasShortInstrumentGroupName) {
        output.WriteRawTag(170, 1);
        output.WriteString(ShortInstrumentGroupName);
      }
      if (HasInstrumentGroupDescription) {
        output.WriteRawTag(178, 1);
        output.WriteString(InstrumentGroupDescription);
      }
      tickSizesByPrice_.WriteTo(output, _repeated_tickSizesByPrice_codec);
      tickSizesByDte_.WriteTo(output, _repeated_tickSizesByDte_codec);
      if (HasTickSizesByDteId) {
        output.WriteRawTag(200, 1);
        output.WriteUInt32(TickSizesByDteId);
      }
      if (HasStrike) {
        output.WriteRawTag(208, 1);
        output.WriteSInt32(Strike);
      }
      if (HasStrikePrice) {
        output.WriteRawTag(217, 1);
        output.WriteDouble(StrikePrice);
      }
      if (HasDialectId) {
        output.WriteRawTag(226, 1);
        output.WriteString(DialectId);
      }
      if (HasCountryCode) {
        output.WriteRawTag(234, 1);
        output.WriteString(CountryCode);
      }
      if (strategyDefinition_ != null) {
        output.WriteRawTag(242, 1);
        output.WriteMessage(StrategyDefinition);
      }
      if (HasContractSize) {
        output.WriteRawTag(250, 1);
        output.WriteString(ContractSize);
      }
      if (HasPositionTracking) {
        output.WriteRawTag(128, 2);
        output.WriteUInt32(PositionTracking);
      }
      if (HasSpeculationTypeRequired) {
        output.WriteRawTag(136, 2);
        output.WriteBool(SpeculationTypeRequired);
      }
      if (HasMaturityMonthYear) {
        output.WriteRawTag(146, 2);
        output.WriteString(MaturityMonthYear);
      }
      if (HasPriceDisplayMode) {
        output.WriteRawTag(152, 2);
        output.WriteEnum((int) PriceDisplayMode);
      }
      if (HasDiscretionaryTickSize) {
        output.WriteRawTag(161, 2);
        output.WriteDouble(DiscretionaryTickSize);
      }
      if (HasDiscretionaryDisplayPriceScale) {
        output.WriteRawTag(168, 2);
        output.WriteUInt32(DiscretionaryDisplayPriceScale);
      }
      if (HasDiscretionaryPriceDisplayMode) {
        output.WriteRawTag(176, 2);
        output.WriteEnum((int) DiscretionaryPriceDisplayMode);
      }
      if (HasForeignCurrency) {
        output.WriteRawTag(186, 2);
        output.WriteString(ForeignCurrency);
      }
      if (volumeScale_ != null) {
        output.WriteRawTag(194, 2);
        output.WriteMessage(VolumeScale);
      }
      if (HasVolumeDisplayExponent) {
        output.WriteRawTag(200, 2);
        output.WriteSInt32(VolumeDisplayExponent);
      }
      if (tradeSizeIncrement_ != null) {
        output.WriteRawTag(210, 2);
        output.WriteMessage(TradeSizeIncrement);
      }
      if (HasExtendedDescription) {
        output.WriteRawTag(218, 2);
        output.WriteString(ExtendedDescription);
      }
      if (HasMicDescription) {
        output.WriteRawTag(226, 2);
        output.WriteString(MicDescription);
      }
      if (HasDomLadderCompressionRatio) {
        output.WriteRawTag(232, 2);
        output.WriteUInt32(DomLadderCompressionRatio);
      }
      if (HasExpectOffTickPrices) {
        output.WriteRawTag(240, 2);
        output.WriteBool(ExpectOffTickPrices);
      }
      if (HasHasExchangeVolume) {
        output.WriteRawTag(248, 2);
        output.WriteBool(HasExchangeVolume);
      }
      if (HasIsin) {
        output.WriteRawTag(130, 3);
        output.WriteString(Isin);
      }
      if (HasMaintenanceMargin) {
        output.WriteRawTag(137, 3);
        output.WriteDouble(MaintenanceMargin);
      }
      if (contractSizeInUnits_ != null) {
        output.WriteRawTag(146, 3);
        output.WriteMessage(ContractSizeInUnits);
      }
      if (contractSizeUnit_ != null) {
        output.WriteRawTag(154, 3);
        output.WriteMessage(ContractSizeUnit);
      }
      if (HasLastDeliveryDate) {
        output.WriteRawTag(160, 3);
        output.WriteSInt64(LastDeliveryDate);
      }
      if (HasMaturityDate) {
        output.WriteRawTag(168, 3);
        output.WriteSInt64(MaturityDate);
      }
      contributorParameters_.WriteTo(output, _repeated_contributorParameters_codec);
      if (HasPeriodType) {
        output.WriteRawTag(184, 3);
        output.WriteUInt32(PeriodType);
      }
      if (HasPeriodValue) {
        output.WriteRawTag(192, 3);
        output.WriteUInt32(PeriodValue);
      }
      if (HasSymbolId) {
        output.WriteRawTag(202, 3);
        output.WriteString(SymbolId);
      }
      if (HasDeleted) {
        output.WriteRawTag(208, 3);
        output.WriteBool(Deleted);
      }
      if (HasEndOfDayDelay) {
        output.WriteRawTag(216, 3);
        output.WriteSInt64(EndOfDayDelay);
      }
      if (HasHasInvertedPriceLadder) {
        output.WriteRawTag(224, 3);
        output.WriteBool(HasInvertedPriceLadder);
      }
      if (HasHasYields) {
        output.WriteRawTag(232, 3);
        output.WriteBool(HasYields);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasContractId) {
        output.WriteRawTag(8);
        output.WriteUInt32(ContractId);
      }
      if (HasContractSymbol) {
        output.WriteRawTag(18);
        output.WriteString(ContractSymbol);
      }
      if (HasCorrectPriceScale) {
        output.WriteRawTag(25);
        output.WriteDouble(CorrectPriceScale);
      }
      if (HasDisplayPriceScale) {
        output.WriteRawTag(32);
        output.WriteUInt32(DisplayPriceScale);
      }
      if (HasDescription) {
        output.WriteRawTag(42);
        output.WriteString(Description);
      }
      if (HasTitle) {
        output.WriteRawTag(50);
        output.WriteString(Title);
      }
      if (HasTickSize) {
        output.WriteRawTag(57);
        output.WriteDouble(TickSize);
      }
      if (HasCurrency) {
        output.WriteRawTag(66);
        output.WriteString(Currency);
      }
      if (HasTickValue) {
        output.WriteRawTag(73);
        output.WriteDouble(TickValue);
      }
      if (HasCfiCode) {
        output.WriteRawTag(82);
        output.WriteString(CfiCode);
      }
      if (HasIsMostActive) {
        output.WriteRawTag(88);
        output.WriteBool(IsMostActive);
      }
      if (HasLastTradingDate) {
        output.WriteRawTag(96);
        output.WriteSInt64(LastTradingDate);
      }
      if (HasFirstNoticeDate) {
        output.WriteRawTag(104);
        output.WriteSInt64(FirstNoticeDate);
      }
      if (HasUnderlyingContractSymbol) {
        output.WriteRawTag(114);
        output.WriteString(UnderlyingContractSymbol);
      }
      if (HasMarginStyle) {
        output.WriteRawTag(120);
        output.WriteUInt32(MarginStyle);
      }
      if (HasInstrumentGroupName) {
        output.WriteRawTag(130, 1);
        output.WriteString(InstrumentGroupName);
      }
      if (HasSessionInfoId) {
        output.WriteRawTag(136, 1);
        output.WriteSInt32(SessionInfoId);
      }
      if (HasMic) {
        output.WriteRawTag(146, 1);
        output.WriteString(Mic);
      }
      if (HasMarketDataDelay) {
        output.WriteRawTag(160, 1);
        output.WriteSInt64(MarketDataDelay);
      }
      if (HasShortInstrumentGroupName) {
        output.WriteRawTag(170, 1);
        output.WriteString(ShortInstrumentGroupName);
      }
      if (HasInstrumentGroupDescription) {
        output.WriteRawTag(178, 1);
        output.WriteString(InstrumentGroupDescription);
      }
      tickSizesByPrice_.WriteTo(ref output, _repeated_tickSizesByPrice_codec);
      tickSizesByDte_.WriteTo(ref output, _repeated_tickSizesByDte_codec);
      if (HasTickSizesByDteId) {
        output.WriteRawTag(200, 1);
        output.WriteUInt32(TickSizesByDteId);
      }
      if (HasStrike) {
        output.WriteRawTag(208, 1);
        output.WriteSInt32(Strike);
      }
      if (HasStrikePrice) {
        output.WriteRawTag(217, 1);
        output.WriteDouble(StrikePrice);
      }
      if (HasDialectId) {
        output.WriteRawTag(226, 1);
        output.WriteString(DialectId);
      }
      if (HasCountryCode) {
        output.WriteRawTag(234, 1);
        output.WriteString(CountryCode);
      }
      if (strategyDefinition_ != null) {
        output.WriteRawTag(242, 1);
        output.WriteMessage(StrategyDefinition);
      }
      if (HasContractSize) {
        output.WriteRawTag(250, 1);
        output.WriteString(ContractSize);
      }
      if (HasPositionTracking) {
        output.WriteRawTag(128, 2);
        output.WriteUInt32(PositionTracking);
      }
      if (HasSpeculationTypeRequired) {
        output.WriteRawTag(136, 2);
        output.WriteBool(SpeculationTypeRequired);
      }
      if (HasMaturityMonthYear) {
        output.WriteRawTag(146, 2);
        output.WriteString(MaturityMonthYear);
      }
      if (HasPriceDisplayMode) {
        output.WriteRawTag(152, 2);
        output.WriteEnum((int) PriceDisplayMode);
      }
      if (HasDiscretionaryTickSize) {
        output.WriteRawTag(161, 2);
        output.WriteDouble(DiscretionaryTickSize);
      }
      if (HasDiscretionaryDisplayPriceScale) {
        output.WriteRawTag(168, 2);
        output.WriteUInt32(DiscretionaryDisplayPriceScale);
      }
      if (HasDiscretionaryPriceDisplayMode) {
        output.WriteRawTag(176, 2);
        output.WriteEnum((int) DiscretionaryPriceDisplayMode);
      }
      if (HasForeignCurrency) {
        output.WriteRawTag(186, 2);
        output.WriteString(ForeignCurrency);
      }
      if (volumeScale_ != null) {
        output.WriteRawTag(194, 2);
        output.WriteMessage(VolumeScale);
      }
      if (HasVolumeDisplayExponent) {
        output.WriteRawTag(200, 2);
        output.WriteSInt32(VolumeDisplayExponent);
      }
      if (tradeSizeIncrement_ != null) {
        output.WriteRawTag(210, 2);
        output.WriteMessage(TradeSizeIncrement);
      }
      if (HasExtendedDescription) {
        output.WriteRawTag(218, 2);
        output.WriteString(ExtendedDescription);
      }
      if (HasMicDescription) {
        output.WriteRawTag(226, 2);
        output.WriteString(MicDescription);
      }
      if (HasDomLadderCompressionRatio) {
        output.WriteRawTag(232, 2);
        output.WriteUInt32(DomLadderCompressionRatio);
      }
      if (HasExpectOffTickPrices) {
        output.WriteRawTag(240, 2);
        output.WriteBool(ExpectOffTickPrices);
      }
      if (HasHasExchangeVolume) {
        output.WriteRawTag(248, 2);
        output.WriteBool(HasExchangeVolume);
      }
      if (HasIsin) {
        output.WriteRawTag(130, 3);
        output.WriteString(Isin);
      }
      if (HasMaintenanceMargin) {
        output.WriteRawTag(137, 3);
        output.WriteDouble(MaintenanceMargin);
      }
      if (contractSizeInUnits_ != null) {
        output.WriteRawTag(146, 3);
        output.WriteMessage(ContractSizeInUnits);
      }
      if (contractSizeUnit_ != null) {
        output.WriteRawTag(154, 3);
        output.WriteMessage(ContractSizeUnit);
      }
      if (HasLastDeliveryDate) {
        output.WriteRawTag(160, 3);
        output.WriteSInt64(LastDeliveryDate);
      }
      if (HasMaturityDate) {
        output.WriteRawTag(168, 3);
        output.WriteSInt64(MaturityDate);
      }
      contributorParameters_.WriteTo(ref output, _repeated_contributorParameters_codec);
      if (HasPeriodType) {
        output.WriteRawTag(184, 3);
        output.WriteUInt32(PeriodType);
      }
      if (HasPeriodValue) {
        output.WriteRawTag(192, 3);
        output.WriteUInt32(PeriodValue);
      }
      if (HasSymbolId) {
        output.WriteRawTag(202, 3);
        output.WriteString(SymbolId);
      }
      if (HasDeleted) {
        output.WriteRawTag(208, 3);
        output.WriteBool(Deleted);
      }
      if (HasEndOfDayDelay) {
        output.WriteRawTag(216, 3);
        output.WriteSInt64(EndOfDayDelay);
      }
      if (HasHasInvertedPriceLadder) {
        output.WriteRawTag(224, 3);
        output.WriteBool(HasInvertedPriceLadder);
      }
      if (HasHasYields) {
        output.WriteRawTag(232, 3);
        output.WriteBool(HasYields);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (HasContractId) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(ContractId);
      }
      if (HasContractSymbol) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ContractSymbol);
      }
      if (HasCorrectPriceScale) {
        size += 1 + 8;
      }
      if (HasDisplayPriceScale) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(DisplayPriceScale);
      }
      if (HasDiscretionaryDisplayPriceScale) {
        size += 2 + pb::CodedOutputStream.ComputeUInt32Size(DiscretionaryDisplayPriceScale);
      }
      if (HasDescription) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Description);
      }
      if (HasExtendedDescription) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(ExtendedDescription);
      }
      if (HasTitle) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Title);
      }
      if (HasTickSize) {
        size += 1 + 8;
      }
      if (HasDiscretionaryTickSize) {
        size += 2 + 8;
      }
      if (HasCurrency) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Currency);
      }
      if (HasTickValue) {
        size += 1 + 8;
      }
      if (HasCfiCode) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(CfiCode);
      }
      if (HasIsMostActive) {
        size += 1 + 1;
      }
      if (HasLastTradingDate) {
        size += 1 + pb::CodedOutputStream.ComputeSInt64Size(LastTradingDate);
      }
      if (HasFirstNoticeDate) {
        size += 1 + pb::CodedOutputStream.ComputeSInt64Size(FirstNoticeDate);
      }
      if (HasUnderlyingContractSymbol) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(UnderlyingContractSymbol);
      }
      if (HasMarginStyle) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(MarginStyle);
      }
      if (HasInstrumentGroupName) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(InstrumentGroupName);
      }
      if (HasSessionInfoId) {
        size += 2 + pb::CodedOutputStream.ComputeSInt32Size(SessionInfoId);
      }
      if (HasMic) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(Mic);
      }
      if (HasMicDescription) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(MicDescription);
      }
      if (HasMarketDataDelay) {
        size += 2 + pb::CodedOutputStream.ComputeSInt64Size(MarketDataDelay);
      }
      if (HasEndOfDayDelay) {
        size += 2 + pb::CodedOutputStream.ComputeSInt64Size(EndOfDayDelay);
      }
      if (HasShortInstrumentGroupName) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(ShortInstrumentGroupName);
      }
      if (HasInstrumentGroupDescription) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(InstrumentGroupDescription);
      }
      size += tickSizesByPrice_.CalculateSize(_repeated_tickSizesByPrice_codec);
      size += tickSizesByDte_.CalculateSize(_repeated_tickSizesByDte_codec);
      if (HasTickSizesByDteId) {
        size += 2 + pb::CodedOutputStream.ComputeUInt32Size(TickSizesByDteId);
      }
      if (HasStrike) {
        size += 2 + pb::CodedOutputStream.ComputeSInt32Size(Strike);
      }
      if (HasStrikePrice) {
        size += 2 + 8;
      }
      if (HasDialectId) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(DialectId);
      }
      if (HasCountryCode) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(CountryCode);
      }
      if (strategyDefinition_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(StrategyDefinition);
      }
      if (HasContractSize) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(ContractSize);
      }
      if (HasPositionTracking) {
        size += 2 + pb::CodedOutputStream.ComputeUInt32Size(PositionTracking);
      }
      if (HasSpeculationTypeRequired) {
        size += 2 + 1;
      }
      if (HasMaturityMonthYear) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(MaturityMonthYear);
      }
      if (HasMaturityDate) {
        size += 2 + pb::CodedOutputStream.ComputeSInt64Size(MaturityDate);
      }
      if (HasPriceDisplayMode) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) PriceDisplayMode);
      }
      if (HasDiscretionaryPriceDisplayMode) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) DiscretionaryPriceDisplayMode);
      }
      if (HasForeignCurrency) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(ForeignCurrency);
      }
      if (volumeScale_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(VolumeScale);
      }
      if (HasVolumeDisplayExponent) {
        size += 2 + pb::CodedOutputStream.ComputeSInt32Size(VolumeDisplayExponent);
      }
      if (tradeSizeIncrement_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(TradeSizeIncrement);
      }
      if (HasHasInvertedPriceLadder) {
        size += 2 + 1;
      }
      if (HasDomLadderCompressionRatio) {
        size += 2 + pb::CodedOutputStream.ComputeUInt32Size(DomLadderCompressionRatio);
      }
      if (HasExpectOffTickPrices) {
        size += 2 + 1;
      }
      if (HasHasExchangeVolume) {
        size += 2 + 1;
      }
      if (HasHasYields) {
        size += 2 + 1;
      }
      if (HasIsin) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(Isin);
      }
      if (HasMaintenanceMargin) {
        size += 2 + 8;
      }
      if (contractSizeInUnits_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(ContractSizeInUnits);
      }
      if (contractSizeUnit_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(ContractSizeUnit);
      }
      if (HasLastDeliveryDate) {
        size += 2 + pb::CodedOutputStream.ComputeSInt64Size(LastDeliveryDate);
      }
      size += contributorParameters_.CalculateSize(_repeated_contributorParameters_codec);
      if (HasPeriodType) {
        size += 2 + pb::CodedOutputStream.ComputeUInt32Size(PeriodType);
      }
      if (HasPeriodValue) {
        size += 2 + pb::CodedOutputStream.ComputeUInt32Size(PeriodValue);
      }
      if (HasSymbolId) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(SymbolId);
      }
      if (HasDeleted) {
        size += 2 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ContractMetadata other) {
      if (other == null) {
        return;
      }
      if (other.HasContractId) {
        ContractId = other.ContractId;
      }
      if (other.HasContractSymbol) {
        ContractSymbol = other.ContractSymbol;
      }
      if (other.HasCorrectPriceScale) {
        CorrectPriceScale = other.CorrectPriceScale;
      }
      if (other.HasDisplayPriceScale) {
        DisplayPriceScale = other.DisplayPriceScale;
      }
      if (other.HasDiscretionaryDisplayPriceScale) {
        DiscretionaryDisplayPriceScale = other.DiscretionaryDisplayPriceScale;
      }
      if (other.HasDescription) {
        Description = other.Description;
      }
      if (other.HasExtendedDescription) {
        ExtendedDescription = other.ExtendedDescription;
      }
      if (other.HasTitle) {
        Title = other.Title;
      }
      if (other.HasTickSize) {
        TickSize = other.TickSize;
      }
      if (other.HasDiscretionaryTickSize) {
        DiscretionaryTickSize = other.DiscretionaryTickSize;
      }
      if (other.HasCurrency) {
        Currency = other.Currency;
      }
      if (other.HasTickValue) {
        TickValue = other.TickValue;
      }
      if (other.HasCfiCode) {
        CfiCode = other.CfiCode;
      }
      if (other.HasIsMostActive) {
        IsMostActive = other.IsMostActive;
      }
      if (other.HasLastTradingDate) {
        LastTradingDate = other.LastTradingDate;
      }
      if (other.HasFirstNoticeDate) {
        FirstNoticeDate = other.FirstNoticeDate;
      }
      if (other.HasUnderlyingContractSymbol) {
        UnderlyingContractSymbol = other.UnderlyingContractSymbol;
      }
      if (other.HasMarginStyle) {
        MarginStyle = other.MarginStyle;
      }
      if (other.HasInstrumentGroupName) {
        InstrumentGroupName = other.InstrumentGroupName;
      }
      if (other.HasSessionInfoId) {
        SessionInfoId = other.SessionInfoId;
      }
      if (other.HasMic) {
        Mic = other.Mic;
      }
      if (other.HasMicDescription) {
        MicDescription = other.MicDescription;
      }
      if (other.HasMarketDataDelay) {
        MarketDataDelay = other.MarketDataDelay;
      }
      if (other.HasEndOfDayDelay) {
        EndOfDayDelay = other.EndOfDayDelay;
      }
      if (other.HasShortInstrumentGroupName) {
        ShortInstrumentGroupName = other.ShortInstrumentGroupName;
      }
      if (other.HasInstrumentGroupDescription) {
        InstrumentGroupDescription = other.InstrumentGroupDescription;
      }
      tickSizesByPrice_.Add(other.tickSizesByPrice_);
      tickSizesByDte_.Add(other.tickSizesByDte_);
      if (other.HasTickSizesByDteId) {
        TickSizesByDteId = other.TickSizesByDteId;
      }
      if (other.HasStrike) {
        Strike = other.Strike;
      }
      if (other.HasStrikePrice) {
        StrikePrice = other.StrikePrice;
      }
      if (other.HasDialectId) {
        DialectId = other.DialectId;
      }
      if (other.HasCountryCode) {
        CountryCode = other.CountryCode;
      }
      if (other.strategyDefinition_ != null) {
        if (strategyDefinition_ == null) {
          StrategyDefinition = new global::StrategyDefinition2.StrategyDefinition();
        }
        StrategyDefinition.MergeFrom(other.StrategyDefinition);
      }
      if (other.HasContractSize) {
        ContractSize = other.ContractSize;
      }
      if (other.HasPositionTracking) {
        PositionTracking = other.PositionTracking;
      }
      if (other.HasSpeculationTypeRequired) {
        SpeculationTypeRequired = other.SpeculationTypeRequired;
      }
      if (other.HasMaturityMonthYear) {
        MaturityMonthYear = other.MaturityMonthYear;
      }
      if (other.HasMaturityDate) {
        MaturityDate = other.MaturityDate;
      }
      if (other.HasPriceDisplayMode) {
        PriceDisplayMode = other.PriceDisplayMode;
      }
      if (other.HasDiscretionaryPriceDisplayMode) {
        DiscretionaryPriceDisplayMode = other.DiscretionaryPriceDisplayMode;
      }
      if (other.HasForeignCurrency) {
        ForeignCurrency = other.ForeignCurrency;
      }
      if (other.volumeScale_ != null) {
        if (volumeScale_ == null) {
          VolumeScale = new global::Cqg.Decimal();
        }
        VolumeScale.MergeFrom(other.VolumeScale);
      }
      if (other.HasVolumeDisplayExponent) {
        VolumeDisplayExponent = other.VolumeDisplayExponent;
      }
      if (other.tradeSizeIncrement_ != null) {
        if (tradeSizeIncrement_ == null) {
          TradeSizeIncrement = new global::Cqg.Decimal();
        }
        TradeSizeIncrement.MergeFrom(other.TradeSizeIncrement);
      }
      if (other.HasHasInvertedPriceLadder) {
        HasInvertedPriceLadder = other.HasInvertedPriceLadder;
      }
      if (other.HasDomLadderCompressionRatio) {
        DomLadderCompressionRatio = other.DomLadderCompressionRatio;
      }
      if (other.HasExpectOffTickPrices) {
        ExpectOffTickPrices = other.ExpectOffTickPrices;
      }
      if (other.HasHasExchangeVolume) {
        HasExchangeVolume = other.HasExchangeVolume;
      }
      if (other.HasHasYields) {
        HasYields = other.HasYields;
      }
      if (other.HasIsin) {
        Isin = other.Isin;
      }
      if (other.HasMaintenanceMargin) {
        MaintenanceMargin = other.MaintenanceMargin;
      }
      if (other.contractSizeInUnits_ != null) {
        if (contractSizeInUnits_ == null) {
          ContractSizeInUnits = new global::Cqg.Decimal();
        }
        ContractSizeInUnits.MergeFrom(other.ContractSizeInUnits);
      }
      if (other.contractSizeUnit_ != null) {
        if (contractSizeUnit_ == null) {
          ContractSizeUnit = new global::Shared1.Text();
        }
        ContractSizeUnit.MergeFrom(other.ContractSizeUnit);
      }
      if (other.HasLastDeliveryDate) {
        LastDeliveryDate = other.LastDeliveryDate;
      }
      contributorParameters_.Add(other.contributorParameters_);
      if (other.HasPeriodType) {
        PeriodType = other.PeriodType;
      }
      if (other.HasPeriodValue) {
        PeriodValue = other.PeriodValue;
      }
      if (other.HasSymbolId) {
        SymbolId = other.SymbolId;
      }
      if (other.HasDeleted) {
        Deleted = other.Deleted;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            ContractId = input.ReadUInt32();
            break;
          }
          case 18: {
            ContractSymbol = input.ReadString();
            break;
          }
          case 25: {
            CorrectPriceScale = input.ReadDouble();
            break;
          }
          case 32: {
            DisplayPriceScale = input.ReadUInt32();
            break;
          }
          case 42: {
            Description = input.ReadString();
            break;
          }
          case 50: {
            Title = input.ReadString();
            break;
          }
          case 57: {
            TickSize = input.ReadDouble();
            break;
          }
          case 66: {
            Currency = input.ReadString();
            break;
          }
          case 73: {
            TickValue = input.ReadDouble();
            break;
          }
          case 82: {
            CfiCode = input.ReadString();
            break;
          }
          case 88: {
            IsMostActive = input.ReadBool();
            break;
          }
          case 96: {
            LastTradingDate = input.ReadSInt64();
            break;
          }
          case 104: {
            FirstNoticeDate = input.ReadSInt64();
            break;
          }
          case 114: {
            UnderlyingContractSymbol = input.ReadString();
            break;
          }
          case 120: {
            MarginStyle = input.ReadUInt32();
            break;
          }
          case 130: {
            InstrumentGroupName = input.ReadString();
            break;
          }
          case 136: {
            SessionInfoId = input.ReadSInt32();
            break;
          }
          case 146: {
            Mic = input.ReadString();
            break;
          }
          case 160: {
            MarketDataDelay = input.ReadSInt64();
            break;
          }
          case 170: {
            ShortInstrumentGroupName = input.ReadString();
            break;
          }
          case 178: {
            InstrumentGroupDescription = input.ReadString();
            break;
          }
          case 186: {
            tickSizesByPrice_.AddEntriesFrom(input, _repeated_tickSizesByPrice_codec);
            break;
          }
          case 194: {
            tickSizesByDte_.AddEntriesFrom(input, _repeated_tickSizesByDte_codec);
            break;
          }
          case 200: {
            TickSizesByDteId = input.ReadUInt32();
            break;
          }
          case 208: {
            Strike = input.ReadSInt32();
            break;
          }
          case 217: {
            StrikePrice = input.ReadDouble();
            break;
          }
          case 226: {
            DialectId = input.ReadString();
            break;
          }
          case 234: {
            CountryCode = input.ReadString();
            break;
          }
          case 242: {
            if (strategyDefinition_ == null) {
              StrategyDefinition = new global::StrategyDefinition2.StrategyDefinition();
            }
            input.ReadMessage(StrategyDefinition);
            break;
          }
          case 250: {
            ContractSize = input.ReadString();
            break;
          }
          case 256: {
            PositionTracking = input.ReadUInt32();
            break;
          }
          case 264: {
            SpeculationTypeRequired = input.ReadBool();
            break;
          }
          case 274: {
            MaturityMonthYear = input.ReadString();
            break;
          }
          case 280: {
            PriceDisplayMode = (global::Metadata2.PriceDisplayMode) input.ReadEnum();
            break;
          }
          case 289: {
            DiscretionaryTickSize = input.ReadDouble();
            break;
          }
          case 296: {
            DiscretionaryDisplayPriceScale = input.ReadUInt32();
            break;
          }
          case 304: {
            DiscretionaryPriceDisplayMode = (global::Metadata2.PriceDisplayMode) input.ReadEnum();
            break;
          }
          case 314: {
            ForeignCurrency = input.ReadString();
            break;
          }
          case 322: {
            if (volumeScale_ == null) {
              VolumeScale = new global::Cqg.Decimal();
            }
            input.ReadMessage(VolumeScale);
            break;
          }
          case 328: {
            VolumeDisplayExponent = input.ReadSInt32();
            break;
          }
          case 338: {
            if (tradeSizeIncrement_ == null) {
              TradeSizeIncrement = new global::Cqg.Decimal();
            }
            input.ReadMessage(TradeSizeIncrement);
            break;
          }
          case 346: {
            ExtendedDescription = input.ReadString();
            break;
          }
          case 354: {
            MicDescription = input.ReadString();
            break;
          }
          case 360: {
            DomLadderCompressionRatio = input.ReadUInt32();
            break;
          }
          case 368: {
            ExpectOffTickPrices = input.ReadBool();
            break;
          }
          case 376: {
            HasExchangeVolume = input.ReadBool();
            break;
          }
          case 386: {
            Isin = input.ReadString();
            break;
          }
          case 393: {
            MaintenanceMargin = input.ReadDouble();
            break;
          }
          case 402: {
            if (contractSizeInUnits_ == null) {
              ContractSizeInUnits = new global::Cqg.Decimal();
            }
            input.ReadMessage(ContractSizeInUnits);
            break;
          }
          case 410: {
            if (contractSizeUnit_ == null) {
              ContractSizeUnit = new global::Shared1.Text();
            }
            input.ReadMessage(ContractSizeUnit);
            break;
          }
          case 416: {
            LastDeliveryDate = input.ReadSInt64();
            break;
          }
          case 424: {
            MaturityDate = input.ReadSInt64();
            break;
          }
          case 434: {
            contributorParameters_.AddEntriesFrom(input, _repeated_contributorParameters_codec);
            break;
          }
          case 440: {
            PeriodType = input.ReadUInt32();
            break;
          }
          case 448: {
            PeriodValue = input.ReadUInt32();
            break;
          }
          case 458: {
            SymbolId = input.ReadString();
            break;
          }
          case 464: {
            Deleted = input.ReadBool();
            break;
          }
          case 472: {
            EndOfDayDelay = input.ReadSInt64();
            break;
          }
          case 480: {
            HasInvertedPriceLadder = input.ReadBool();
            break;
          }
          case 488: {
            HasYields = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            ContractId = input.ReadUInt32();
            break;
          }
          case 18: {
            ContractSymbol = input.ReadString();
            break;
          }
          case 25: {
            CorrectPriceScale = input.ReadDouble();
            break;
          }
          case 32: {
            DisplayPriceScale = input.ReadUInt32();
            break;
          }
          case 42: {
            Description = input.ReadString();
            break;
          }
          case 50: {
            Title = input.ReadString();
            break;
          }
          case 57: {
            TickSize = input.ReadDouble();
            break;
          }
          case 66: {
            Currency = input.ReadString();
            break;
          }
          case 73: {
            TickValue = input.ReadDouble();
            break;
          }
          case 82: {
            CfiCode = input.ReadString();
            break;
          }
          case 88: {
            IsMostActive = input.ReadBool();
            break;
          }
          case 96: {
            LastTradingDate = input.ReadSInt64();
            break;
          }
          case 104: {
            FirstNoticeDate = input.ReadSInt64();
            break;
          }
          case 114: {
            UnderlyingContractSymbol = input.ReadString();
            break;
          }
          case 120: {
            MarginStyle = input.ReadUInt32();
            break;
          }
          case 130: {
            InstrumentGroupName = input.ReadString();
            break;
          }
          case 136: {
            SessionInfoId = input.ReadSInt32();
            break;
          }
          case 146: {
            Mic = input.ReadString();
            break;
          }
          case 160: {
            MarketDataDelay = input.ReadSInt64();
            break;
          }
          case 170: {
            ShortInstrumentGroupName = input.ReadString();
            break;
          }
          case 178: {
            InstrumentGroupDescription = input.ReadString();
            break;
          }
          case 186: {
            tickSizesByPrice_.AddEntriesFrom(ref input, _repeated_tickSizesByPrice_codec);
            break;
          }
          case 194: {
            tickSizesByDte_.AddEntriesFrom(ref input, _repeated_tickSizesByDte_codec);
            break;
          }
          case 200: {
            TickSizesByDteId = input.ReadUInt32();
            break;
          }
          case 208: {
            Strike = input.ReadSInt32();
            break;
          }
          case 217: {
            StrikePrice = input.ReadDouble();
            break;
          }
          case 226: {
            DialectId = input.ReadString();
            break;
          }
          case 234: {
            CountryCode = input.ReadString();
            break;
          }
          case 242: {
            if (strategyDefinition_ == null) {
              StrategyDefinition = new global::StrategyDefinition2.StrategyDefinition();
            }
            input.ReadMessage(StrategyDefinition);
            break;
          }
          case 250: {
            ContractSize = input.ReadString();
            break;
          }
          case 256: {
            PositionTracking = input.ReadUInt32();
            break;
          }
          case 264: {
            SpeculationTypeRequired = input.ReadBool();
            break;
          }
          case 274: {
            MaturityMonthYear = input.ReadString();
            break;
          }
          case 280: {
            PriceDisplayMode = (global::Metadata2.PriceDisplayMode) input.ReadEnum();
            break;
          }
          case 289: {
            DiscretionaryTickSize = input.ReadDouble();
            break;
          }
          case 296: {
            DiscretionaryDisplayPriceScale = input.ReadUInt32();
            break;
          }
          case 304: {
            DiscretionaryPriceDisplayMode = (global::Metadata2.PriceDisplayMode) input.ReadEnum();
            break;
          }
          case 314: {
            ForeignCurrency = input.ReadString();
            break;
          }
          case 322: {
            if (volumeScale_ == null) {
              VolumeScale = new global::Cqg.Decimal();
            }
            input.ReadMessage(VolumeScale);
            break;
          }
          case 328: {
            VolumeDisplayExponent = input.ReadSInt32();
            break;
          }
          case 338: {
            if (tradeSizeIncrement_ == null) {
              TradeSizeIncrement = new global::Cqg.Decimal();
            }
            input.ReadMessage(TradeSizeIncrement);
            break;
          }
          case 346: {
            ExtendedDescription = input.ReadString();
            break;
          }
          case 354: {
            MicDescription = input.ReadString();
            break;
          }
          case 360: {
            DomLadderCompressionRatio = input.ReadUInt32();
            break;
          }
          case 368: {
            ExpectOffTickPrices = input.ReadBool();
            break;
          }
          case 376: {
            HasExchangeVolume = input.ReadBool();
            break;
          }
          case 386: {
            Isin = input.ReadString();
            break;
          }
          case 393: {
            MaintenanceMargin = input.ReadDouble();
            break;
          }
          case 402: {
            if (contractSizeInUnits_ == null) {
              ContractSizeInUnits = new global::Cqg.Decimal();
            }
            input.ReadMessage(ContractSizeInUnits);
            break;
          }
          case 410: {
            if (contractSizeUnit_ == null) {
              ContractSizeUnit = new global::Shared1.Text();
            }
            input.ReadMessage(ContractSizeUnit);
            break;
          }
          case 416: {
            LastDeliveryDate = input.ReadSInt64();
            break;
          }
          case 424: {
            MaturityDate = input.ReadSInt64();
            break;
          }
          case 434: {
            contributorParameters_.AddEntriesFrom(ref input, _repeated_contributorParameters_codec);
            break;
          }
          case 440: {
            PeriodType = input.ReadUInt32();
            break;
          }
          case 448: {
            PeriodValue = input.ReadUInt32();
            break;
          }
          case 458: {
            SymbolId = input.ReadString();
            break;
          }
          case 464: {
            Deleted = input.ReadBool();
            break;
          }
          case 472: {
            EndOfDayDelay = input.ReadSInt64();
            break;
          }
          case 480: {
            HasInvertedPriceLadder = input.ReadBool();
            break;
          }
          case 488: {
            HasYields = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the ContractMetadata message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// Margin style (for options).
      /// </summary>
      public enum MarginStyle {
        /// <summary>
        /// The premium is paid on exercise/ expiry (position is included to OTE calculation).
        /// </summary>
        [pbr::OriginalName("MARGIN_STYLE_FUTURE")] Future = 1,
        /// <summary>
        /// Premium is subtracted from account balance when order is filled (position is included to MVO/UPL calculation).
        /// </summary>
        [pbr::OriginalName("MARGIN_STYLE_PREMIUM")] Premium = 2,
      }

    }
    #endregion

  }

  #endregion

}

#endregion Designer generated code
