// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: WebAPI/strategy_definition_2.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace StrategyDefinition2 {

  /// <summary>Holder for reflection information generated from WebAPI/strategy_definition_2.proto</summary>
  public static partial class StrategyDefinition2Reflection {

    #region Descriptor
    /// <summary>File descriptor for WebAPI/strategy_definition_2.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static StrategyDefinition2Reflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CiJXZWJBUEkvc3RyYXRlZ3lfZGVmaW5pdGlvbl8yLnByb3RvEhVzdHJhdGVn",
            "eV9kZWZpbml0aW9uXzIi/gIKElN0cmF0ZWd5RGVmaW5pdGlvbhITCgthZ2dy",
            "ZWdhdGlvbhgBIAEoCBJCChFleGNoYW5nZV9zdHJhdGVneRgCIAEoCzInLnN0",
            "cmF0ZWd5X2RlZmluaXRpb25fMi5FeGNoYW5nZVN0cmF0ZWd5EhEKCXRpY2tf",
            "c2l6ZRgDIAEoARIUCgxwcmljZV9vZmZzZXQYBCABKAESFgoOcm91bmRfbGVn",
            "X21vZGUYBSABKA0SEgoKbm9kZV9pbmRleBgGIAIoDRJHChBub2RlX2RlZmlu",
            "aXRpb25zGAcgAygLMi0uc3RyYXRlZ3lfZGVmaW5pdGlvbl8yLlN0cmF0ZWd5",
            "Tm9kZURlZmluaXRpb24SGAoQdXNlcl9kZXNjcmlwdGlvbhgIIAEoCSJXCgxS",
            "b3VuZExlZ01vZGUSFwoTUk9VTkRfTEVHX01PREVfRE9XThABEhUKEVJPVU5E",
            "X0xFR19NT0RFX1VQEAISFwoTUk9VTkRfTEVHX01PREVfTUFUSBADIjIKEEV4",
            "Y2hhbmdlU3RyYXRlZ3kSHgoWZXhjaGFuZ2Vfc3RyYXRlZ3lfdHlwZRgBIAEo",
            "CSJ2Cg1MZWdEZWZpbml0aW9uEhMKC2NvbnRyYWN0X2lkGAEgAigNEhIKCm5v",
            "ZGVfaW5kZXgYAiACKA0SEQoJcXR5X3JhdGlvGAMgAigBEhMKC3ByaWNlX3Jh",
            "dGlvGAQgASgBEhQKDHByaWNlX29mZnNldBgFIAEoASJ3Cg5OZXN0ZWRTdHJh",
            "dGVneRI9CgpkZWZpbml0aW9uGAEgAigLMikuc3RyYXRlZ3lfZGVmaW5pdGlv",
            "bl8yLlN0cmF0ZWd5RGVmaW5pdGlvbhIRCglxdHlfcmF0aW8YAiABKAESEwoL",
            "cHJpY2VfcmF0aW8YAyABKAEi/AEKFlN0cmF0ZWd5Tm9kZURlZmluaXRpb24S",
            "FgoObm9kZV9vcGVyYXRpb24YAiABKA0SMQoDbGVnGAMgASgLMiQuc3RyYXRl",
            "Z3lfZGVmaW5pdGlvbl8yLkxlZ0RlZmluaXRpb24SPgoPbmVzdGVkX3N0cmF0",
            "ZWd5GAQgASgLMiUuc3RyYXRlZ3lfZGVmaW5pdGlvbl8yLk5lc3RlZFN0cmF0",
            "ZWd5IlcKDU5vZGVPcGVyYXRpb24SFgoSTk9ERV9PUEVSQVRJT05fU1VNEAES",
            "FgoSTk9ERV9PUEVSQVRJT05fTVVMEAISFgoSTk9ERV9PUEVSQVRJT05fRElW",
            "EAM="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::StrategyDefinition2.StrategyDefinition), global::StrategyDefinition2.StrategyDefinition.Parser, new[]{ "Aggregation", "ExchangeStrategy", "TickSize", "PriceOffset", "RoundLegMode", "NodeIndex", "NodeDefinitions", "UserDescription" }, null, new[]{ typeof(global::StrategyDefinition2.StrategyDefinition.Types.RoundLegMode) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::StrategyDefinition2.ExchangeStrategy), global::StrategyDefinition2.ExchangeStrategy.Parser, new[]{ "ExchangeStrategyType" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::StrategyDefinition2.LegDefinition), global::StrategyDefinition2.LegDefinition.Parser, new[]{ "ContractId", "NodeIndex", "QtyRatio", "PriceRatio", "PriceOffset" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::StrategyDefinition2.NestedStrategy), global::StrategyDefinition2.NestedStrategy.Parser, new[]{ "Definition", "QtyRatio", "PriceRatio" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::StrategyDefinition2.StrategyNodeDefinition), global::StrategyDefinition2.StrategyNodeDefinition.Parser, new[]{ "NodeOperation", "Leg", "NestedStrategy" }, null, new[]{ typeof(global::StrategyDefinition2.StrategyNodeDefinition.Types.NodeOperation) }, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// Message to define a synthetic or a user defined strategy, a tree where terminal nodes (legs) are concrete contracts,
  /// non-terminal ones are nested strategies.
  /// Nodes are defined from the BUY perspective.
  /// Maximum strategy nesting level is 2, i.e. strategy of strategies of legs.
  /// Maximum number of leg in the whole strategy is 40.
  /// </summary>
  public sealed partial class StrategyDefinition : pb::IMessage<StrategyDefinition>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<StrategyDefinition> _parser = new pb::MessageParser<StrategyDefinition>(() => new StrategyDefinition());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<StrategyDefinition> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::StrategyDefinition2.StrategyDefinition2Reflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public StrategyDefinition() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public StrategyDefinition(StrategyDefinition other) : this() {
      _hasBits0 = other._hasBits0;
      aggregation_ = other.aggregation_;
      exchangeStrategy_ = other.exchangeStrategy_ != null ? other.exchangeStrategy_.Clone() : null;
      tickSize_ = other.tickSize_;
      priceOffset_ = other.priceOffset_;
      roundLegMode_ = other.roundLegMode_;
      nodeIndex_ = other.nodeIndex_;
      nodeDefinitions_ = other.nodeDefinitions_.Clone();
      userDescription_ = other.userDescription_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public StrategyDefinition Clone() {
      return new StrategyDefinition(this);
    }

    /// <summary>Field number for the "aggregation" field.</summary>
    public const int AggregationFieldNumber = 1;
    private readonly static bool AggregationDefaultValue = false;

    private bool aggregation_;
    /// <summary>
    /// The strategy is of the aggregation type.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Aggregation {
      get { if ((_hasBits0 & 1) != 0) { return aggregation_; } else { return AggregationDefaultValue; } }
      set {
        _hasBits0 |= 1;
        aggregation_ = value;
      }
    }
    /// <summary>Gets whether the "aggregation" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasAggregation {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "aggregation" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearAggregation() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "exchange_strategy" field.</summary>
    public const int ExchangeStrategyFieldNumber = 2;
    private global::StrategyDefinition2.ExchangeStrategy exchangeStrategy_;
    /// <summary>
    /// If specified defines exchange strategy.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::StrategyDefinition2.ExchangeStrategy ExchangeStrategy {
      get { return exchangeStrategy_; }
      set {
        exchangeStrategy_ = value;
      }
    }

    /// <summary>Field number for the "tick_size" field.</summary>
    public const int TickSizeFieldNumber = 3;
    private readonly static double TickSizeDefaultValue = 0D;

    private double tickSize_;
    /// <summary>
    /// Strategy tick size (correct price format). The tick size of the 1st leg is default.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double TickSize {
      get { if ((_hasBits0 & 2) != 0) { return tickSize_; } else { return TickSizeDefaultValue; } }
      set {
        _hasBits0 |= 2;
        tickSize_ = value;
      }
    }
    /// <summary>Gets whether the "tick_size" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasTickSize {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "tick_size" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearTickSize() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "price_offset" field.</summary>
    public const int PriceOffsetFieldNumber = 4;
    private readonly static double PriceOffsetDefaultValue = 0D;

    private double priceOffset_;
    /// <summary>
    /// Additive offset for computation of strategy price.
    /// 0 is default.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double PriceOffset {
      get { if ((_hasBits0 & 4) != 0) { return priceOffset_; } else { return PriceOffsetDefaultValue; } }
      set {
        _hasBits0 |= 4;
        priceOffset_ = value;
      }
    }
    /// <summary>Gets whether the "price_offset" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasPriceOffset {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "price_offset" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearPriceOffset() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "round_leg_mode" field.</summary>
    public const int RoundLegModeFieldNumber = 5;
    private readonly static uint RoundLegModeDefaultValue = 0;

    private uint roundLegMode_;
    /// <summary>
    /// Controls how to handle fractional quantities when calculating leg quantities for an order on this strategy,
    /// One of RoundLegMode enums, ROUND_LEG_MODE_DOWN is default. Ignored for aggregations and exchange strategies.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint RoundLegMode {
      get { if ((_hasBits0 & 8) != 0) { return roundLegMode_; } else { return RoundLegModeDefaultValue; } }
      set {
        _hasBits0 |= 8;
        roundLegMode_ = value;
      }
    }
    /// <summary>Gets whether the "round_leg_mode" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasRoundLegMode {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "round_leg_mode" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearRoundLegMode() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "node_index" field.</summary>
    public const int NodeIndexFieldNumber = 6;
    private readonly static uint NodeIndexDefaultValue = 0;

    private uint nodeIndex_;
    /// <summary>
    /// Unique node index within the root strategy to apply strategy trading parameters and to associate an order.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint NodeIndex {
      get { if ((_hasBits0 & 16) != 0) { return nodeIndex_; } else { return NodeIndexDefaultValue; } }
      set {
        _hasBits0 |= 16;
        nodeIndex_ = value;
      }
    }
    /// <summary>Gets whether the "node_index" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasNodeIndex {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "node_index" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearNodeIndex() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "node_definitions" field.</summary>
    public const int NodeDefinitionsFieldNumber = 7;
    private static readonly pb::FieldCodec<global::StrategyDefinition2.StrategyNodeDefinition> _repeated_nodeDefinitions_codec
        = pb::FieldCodec.ForMessage(58, global::StrategyDefinition2.StrategyNodeDefinition.Parser);
    private readonly pbc::RepeatedField<global::StrategyDefinition2.StrategyNodeDefinition> nodeDefinitions_ = new pbc::RepeatedField<global::StrategyDefinition2.StrategyNodeDefinition>();
    /// <summary>
    /// Legs or nested strategies.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::StrategyDefinition2.StrategyNodeDefinition> NodeDefinitions {
      get { return nodeDefinitions_; }
    }

    /// <summary>Field number for the "user_description" field.</summary>
    public const int UserDescriptionFieldNumber = 8;
    private readonly static string UserDescriptionDefaultValue = "";

    private string userDescription_;
    /// <summary>
    /// User text associated with the strategy. Allowed to be specified only for non-exchange strategies.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string UserDescription {
      get { return userDescription_ ?? UserDescriptionDefaultValue; }
      set {
        userDescription_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "user_description" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasUserDescription {
      get { return userDescription_ != null; }
    }
    /// <summary>Clears the value of the "user_description" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearUserDescription() {
      userDescription_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as StrategyDefinition);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(StrategyDefinition other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Aggregation != other.Aggregation) return false;
      if (!object.Equals(ExchangeStrategy, other.ExchangeStrategy)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(TickSize, other.TickSize)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(PriceOffset, other.PriceOffset)) return false;
      if (RoundLegMode != other.RoundLegMode) return false;
      if (NodeIndex != other.NodeIndex) return false;
      if(!nodeDefinitions_.Equals(other.nodeDefinitions_)) return false;
      if (UserDescription != other.UserDescription) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasAggregation) hash ^= Aggregation.GetHashCode();
      if (exchangeStrategy_ != null) hash ^= ExchangeStrategy.GetHashCode();
      if (HasTickSize) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(TickSize);
      if (HasPriceOffset) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(PriceOffset);
      if (HasRoundLegMode) hash ^= RoundLegMode.GetHashCode();
      if (HasNodeIndex) hash ^= NodeIndex.GetHashCode();
      hash ^= nodeDefinitions_.GetHashCode();
      if (HasUserDescription) hash ^= UserDescription.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasAggregation) {
        output.WriteRawTag(8);
        output.WriteBool(Aggregation);
      }
      if (exchangeStrategy_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(ExchangeStrategy);
      }
      if (HasTickSize) {
        output.WriteRawTag(25);
        output.WriteDouble(TickSize);
      }
      if (HasPriceOffset) {
        output.WriteRawTag(33);
        output.WriteDouble(PriceOffset);
      }
      if (HasRoundLegMode) {
        output.WriteRawTag(40);
        output.WriteUInt32(RoundLegMode);
      }
      if (HasNodeIndex) {
        output.WriteRawTag(48);
        output.WriteUInt32(NodeIndex);
      }
      nodeDefinitions_.WriteTo(output, _repeated_nodeDefinitions_codec);
      if (HasUserDescription) {
        output.WriteRawTag(66);
        output.WriteString(UserDescription);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasAggregation) {
        output.WriteRawTag(8);
        output.WriteBool(Aggregation);
      }
      if (exchangeStrategy_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(ExchangeStrategy);
      }
      if (HasTickSize) {
        output.WriteRawTag(25);
        output.WriteDouble(TickSize);
      }
      if (HasPriceOffset) {
        output.WriteRawTag(33);
        output.WriteDouble(PriceOffset);
      }
      if (HasRoundLegMode) {
        output.WriteRawTag(40);
        output.WriteUInt32(RoundLegMode);
      }
      if (HasNodeIndex) {
        output.WriteRawTag(48);
        output.WriteUInt32(NodeIndex);
      }
      nodeDefinitions_.WriteTo(ref output, _repeated_nodeDefinitions_codec);
      if (HasUserDescription) {
        output.WriteRawTag(66);
        output.WriteString(UserDescription);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (HasAggregation) {
        size += 1 + 1;
      }
      if (exchangeStrategy_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ExchangeStrategy);
      }
      if (HasTickSize) {
        size += 1 + 8;
      }
      if (HasPriceOffset) {
        size += 1 + 8;
      }
      if (HasRoundLegMode) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(RoundLegMode);
      }
      if (HasNodeIndex) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(NodeIndex);
      }
      size += nodeDefinitions_.CalculateSize(_repeated_nodeDefinitions_codec);
      if (HasUserDescription) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(UserDescription);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(StrategyDefinition other) {
      if (other == null) {
        return;
      }
      if (other.HasAggregation) {
        Aggregation = other.Aggregation;
      }
      if (other.exchangeStrategy_ != null) {
        if (exchangeStrategy_ == null) {
          ExchangeStrategy = new global::StrategyDefinition2.ExchangeStrategy();
        }
        ExchangeStrategy.MergeFrom(other.ExchangeStrategy);
      }
      if (other.HasTickSize) {
        TickSize = other.TickSize;
      }
      if (other.HasPriceOffset) {
        PriceOffset = other.PriceOffset;
      }
      if (other.HasRoundLegMode) {
        RoundLegMode = other.RoundLegMode;
      }
      if (other.HasNodeIndex) {
        NodeIndex = other.NodeIndex;
      }
      nodeDefinitions_.Add(other.nodeDefinitions_);
      if (other.HasUserDescription) {
        UserDescription = other.UserDescription;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Aggregation = input.ReadBool();
            break;
          }
          case 18: {
            if (exchangeStrategy_ == null) {
              ExchangeStrategy = new global::StrategyDefinition2.ExchangeStrategy();
            }
            input.ReadMessage(ExchangeStrategy);
            break;
          }
          case 25: {
            TickSize = input.ReadDouble();
            break;
          }
          case 33: {
            PriceOffset = input.ReadDouble();
            break;
          }
          case 40: {
            RoundLegMode = input.ReadUInt32();
            break;
          }
          case 48: {
            NodeIndex = input.ReadUInt32();
            break;
          }
          case 58: {
            nodeDefinitions_.AddEntriesFrom(input, _repeated_nodeDefinitions_codec);
            break;
          }
          case 66: {
            UserDescription = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Aggregation = input.ReadBool();
            break;
          }
          case 18: {
            if (exchangeStrategy_ == null) {
              ExchangeStrategy = new global::StrategyDefinition2.ExchangeStrategy();
            }
            input.ReadMessage(ExchangeStrategy);
            break;
          }
          case 25: {
            TickSize = input.ReadDouble();
            break;
          }
          case 33: {
            PriceOffset = input.ReadDouble();
            break;
          }
          case 40: {
            RoundLegMode = input.ReadUInt32();
            break;
          }
          case 48: {
            NodeIndex = input.ReadUInt32();
            break;
          }
          case 58: {
            nodeDefinitions_.AddEntriesFrom(ref input, _repeated_nodeDefinitions_codec);
            break;
          }
          case 66: {
            UserDescription = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the StrategyDefinition message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// Using a fractional trade ratio may result in fractional lots. If so, the number of lots has to be rounded.
      /// Rounding applies only to complex strategies with fractional quantity ratios.
      /// </summary>
      public enum RoundLegMode {
        /// <summary>
        /// always round down, e.g. 1.1 -> 1 and -2.1 -> -2
        /// </summary>
        [pbr::OriginalName("ROUND_LEG_MODE_DOWN")] Down = 1,
        /// <summary>
        /// always round up, e.g. 1.1 -> 2 and -2.1 -> -3
        /// </summary>
        [pbr::OriginalName("ROUND_LEG_MODE_UP")] Up = 2,
        /// <summary>
        /// round up when fractional part is 5 or greater; round down when fractional part is less than 5, e.g. 1.1 -> 1 and 1.6 -> 2
        /// </summary>
        [pbr::OriginalName("ROUND_LEG_MODE_MATH")] Math = 3,
      }

    }
    #endregion

  }

  /// <summary>
  /// Defines a strategy created by an individual and registered by an exchange for general open market trading.
  /// Must be a root strategy without nested nodes and cannot be an aggregation.
  /// </summary>
  public sealed partial class ExchangeStrategy : pb::IMessage<ExchangeStrategy>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ExchangeStrategy> _parser = new pb::MessageParser<ExchangeStrategy>(() => new ExchangeStrategy());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ExchangeStrategy> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::StrategyDefinition2.StrategyDefinition2Reflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ExchangeStrategy() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ExchangeStrategy(ExchangeStrategy other) : this() {
      exchangeStrategyType_ = other.exchangeStrategyType_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ExchangeStrategy Clone() {
      return new ExchangeStrategy(this);
    }

    /// <summary>Field number for the "exchange_strategy_type" field.</summary>
    public const int ExchangeStrategyTypeFieldNumber = 1;
    private readonly static string ExchangeStrategyTypeDefaultValue = "";

    private string exchangeStrategyType_;
    /// <summary>
    /// Value of this field might be chosen from the predefined list to specify exchange strategy type.
    /// Please contact CQG to get the list of supported types.
    /// "custom" if omitted.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ExchangeStrategyType {
      get { return exchangeStrategyType_ ?? ExchangeStrategyTypeDefaultValue; }
      set {
        exchangeStrategyType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "exchange_strategy_type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasExchangeStrategyType {
      get { return exchangeStrategyType_ != null; }
    }
    /// <summary>Clears the value of the "exchange_strategy_type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearExchangeStrategyType() {
      exchangeStrategyType_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ExchangeStrategy);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ExchangeStrategy other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (ExchangeStrategyType != other.ExchangeStrategyType) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasExchangeStrategyType) hash ^= ExchangeStrategyType.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasExchangeStrategyType) {
        output.WriteRawTag(10);
        output.WriteString(ExchangeStrategyType);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasExchangeStrategyType) {
        output.WriteRawTag(10);
        output.WriteString(ExchangeStrategyType);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (HasExchangeStrategyType) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ExchangeStrategyType);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ExchangeStrategy other) {
      if (other == null) {
        return;
      }
      if (other.HasExchangeStrategyType) {
        ExchangeStrategyType = other.ExchangeStrategyType;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            ExchangeStrategyType = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            ExchangeStrategyType = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Defines a leg (resolved contract) of a strategy.
  /// </summary>
  public sealed partial class LegDefinition : pb::IMessage<LegDefinition>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<LegDefinition> _parser = new pb::MessageParser<LegDefinition>(() => new LegDefinition());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<LegDefinition> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::StrategyDefinition2.StrategyDefinition2Reflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LegDefinition() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LegDefinition(LegDefinition other) : this() {
      _hasBits0 = other._hasBits0;
      contractId_ = other.contractId_;
      nodeIndex_ = other.nodeIndex_;
      qtyRatio_ = other.qtyRatio_;
      priceRatio_ = other.priceRatio_;
      priceOffset_ = other.priceOffset_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LegDefinition Clone() {
      return new LegDefinition(this);
    }

    /// <summary>Field number for the "contract_id" field.</summary>
    public const int ContractIdFieldNumber = 1;
    private readonly static uint ContractIdDefaultValue = 0;

    private uint contractId_;
    /// <summary>
    /// Id of the leg contract.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint ContractId {
      get { if ((_hasBits0 & 1) != 0) { return contractId_; } else { return ContractIdDefaultValue; } }
      set {
        _hasBits0 |= 1;
        contractId_ = value;
      }
    }
    /// <summary>Gets whether the "contract_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasContractId {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "contract_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearContractId() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "node_index" field.</summary>
    public const int NodeIndexFieldNumber = 2;
    private readonly static uint NodeIndexDefaultValue = 0;

    private uint nodeIndex_;
    /// <summary>
    /// Unique node index within the root strategy to apply strategy trading parameters and to associate an order.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint NodeIndex {
      get { if ((_hasBits0 & 2) != 0) { return nodeIndex_; } else { return NodeIndexDefaultValue; } }
      set {
        _hasBits0 |= 2;
        nodeIndex_ = value;
      }
    }
    /// <summary>Gets whether the "node_index" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasNodeIndex {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "node_index" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearNodeIndex() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "qty_ratio" field.</summary>
    public const int QtyRatioFieldNumber = 3;
    private readonly static double QtyRatioDefaultValue = 0D;

    private double qtyRatio_;
    /// <summary>
    /// Leg quantity ratio, signed decimal, number of leg contracts to buy(positive) or sell(negative). Must be integer for an aggregation.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double QtyRatio {
      get { if ((_hasBits0 & 4) != 0) { return qtyRatio_; } else { return QtyRatioDefaultValue; } }
      set {
        _hasBits0 |= 4;
        qtyRatio_ = value;
      }
    }
    /// <summary>Gets whether the "qty_ratio" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasQtyRatio {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "qty_ratio" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearQtyRatio() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "price_ratio" field.</summary>
    public const int PriceRatioFieldNumber = 4;
    private readonly static double PriceRatioDefaultValue = 0D;

    private double priceRatio_;
    /// <summary>
    /// Leg price calculation ratio, signed decimal, coefficient in strategy price formula before the leg contract.
    /// Same as qty_ratio if omitted.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double PriceRatio {
      get { if ((_hasBits0 & 8) != 0) { return priceRatio_; } else { return PriceRatioDefaultValue; } }
      set {
        _hasBits0 |= 8;
        priceRatio_ = value;
      }
    }
    /// <summary>Gets whether the "price_ratio" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasPriceRatio {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "price_ratio" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearPriceRatio() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "price_offset" field.</summary>
    public const int PriceOffsetFieldNumber = 5;
    private readonly static double PriceOffsetDefaultValue = 0D;

    private double priceOffset_;
    /// <summary>
    /// Price offset for this leg (correct price format), only specified for legs of an aggregation or a multiplicative strategy.
    /// 0 is default.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double PriceOffset {
      get { if ((_hasBits0 & 16) != 0) { return priceOffset_; } else { return PriceOffsetDefaultValue; } }
      set {
        _hasBits0 |= 16;
        priceOffset_ = value;
      }
    }
    /// <summary>Gets whether the "price_offset" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasPriceOffset {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "price_offset" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearPriceOffset() {
      _hasBits0 &= ~16;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as LegDefinition);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(LegDefinition other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (ContractId != other.ContractId) return false;
      if (NodeIndex != other.NodeIndex) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(QtyRatio, other.QtyRatio)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(PriceRatio, other.PriceRatio)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(PriceOffset, other.PriceOffset)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasContractId) hash ^= ContractId.GetHashCode();
      if (HasNodeIndex) hash ^= NodeIndex.GetHashCode();
      if (HasQtyRatio) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(QtyRatio);
      if (HasPriceRatio) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(PriceRatio);
      if (HasPriceOffset) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(PriceOffset);
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasContractId) {
        output.WriteRawTag(8);
        output.WriteUInt32(ContractId);
      }
      if (HasNodeIndex) {
        output.WriteRawTag(16);
        output.WriteUInt32(NodeIndex);
      }
      if (HasQtyRatio) {
        output.WriteRawTag(25);
        output.WriteDouble(QtyRatio);
      }
      if (HasPriceRatio) {
        output.WriteRawTag(33);
        output.WriteDouble(PriceRatio);
      }
      if (HasPriceOffset) {
        output.WriteRawTag(41);
        output.WriteDouble(PriceOffset);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasContractId) {
        output.WriteRawTag(8);
        output.WriteUInt32(ContractId);
      }
      if (HasNodeIndex) {
        output.WriteRawTag(16);
        output.WriteUInt32(NodeIndex);
      }
      if (HasQtyRatio) {
        output.WriteRawTag(25);
        output.WriteDouble(QtyRatio);
      }
      if (HasPriceRatio) {
        output.WriteRawTag(33);
        output.WriteDouble(PriceRatio);
      }
      if (HasPriceOffset) {
        output.WriteRawTag(41);
        output.WriteDouble(PriceOffset);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (HasContractId) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(ContractId);
      }
      if (HasNodeIndex) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(NodeIndex);
      }
      if (HasQtyRatio) {
        size += 1 + 8;
      }
      if (HasPriceRatio) {
        size += 1 + 8;
      }
      if (HasPriceOffset) {
        size += 1 + 8;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(LegDefinition other) {
      if (other == null) {
        return;
      }
      if (other.HasContractId) {
        ContractId = other.ContractId;
      }
      if (other.HasNodeIndex) {
        NodeIndex = other.NodeIndex;
      }
      if (other.HasQtyRatio) {
        QtyRatio = other.QtyRatio;
      }
      if (other.HasPriceRatio) {
        PriceRatio = other.PriceRatio;
      }
      if (other.HasPriceOffset) {
        PriceOffset = other.PriceOffset;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            ContractId = input.ReadUInt32();
            break;
          }
          case 16: {
            NodeIndex = input.ReadUInt32();
            break;
          }
          case 25: {
            QtyRatio = input.ReadDouble();
            break;
          }
          case 33: {
            PriceRatio = input.ReadDouble();
            break;
          }
          case 41: {
            PriceOffset = input.ReadDouble();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            ContractId = input.ReadUInt32();
            break;
          }
          case 16: {
            NodeIndex = input.ReadUInt32();
            break;
          }
          case 25: {
            QtyRatio = input.ReadDouble();
            break;
          }
          case 33: {
            PriceRatio = input.ReadDouble();
            break;
          }
          case 41: {
            PriceOffset = input.ReadDouble();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Defines a strategy nested inside a parent strategy.
  /// </summary>
  public sealed partial class NestedStrategy : pb::IMessage<NestedStrategy>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<NestedStrategy> _parser = new pb::MessageParser<NestedStrategy>(() => new NestedStrategy());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<NestedStrategy> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::StrategyDefinition2.StrategyDefinition2Reflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NestedStrategy() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NestedStrategy(NestedStrategy other) : this() {
      _hasBits0 = other._hasBits0;
      definition_ = other.definition_ != null ? other.definition_.Clone() : null;
      qtyRatio_ = other.qtyRatio_;
      priceRatio_ = other.priceRatio_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NestedStrategy Clone() {
      return new NestedStrategy(this);
    }

    /// <summary>Field number for the "definition" field.</summary>
    public const int DefinitionFieldNumber = 1;
    private global::StrategyDefinition2.StrategyDefinition definition_;
    /// <summary>
    /// Nested strategy definition.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::StrategyDefinition2.StrategyDefinition Definition {
      get { return definition_; }
      set {
        definition_ = value;
      }
    }

    /// <summary>Field number for the "qty_ratio" field.</summary>
    public const int QtyRatioFieldNumber = 2;
    private readonly static double QtyRatioDefaultValue = 0D;

    private double qtyRatio_;
    /// <summary>
    /// Quantity ratio, signed decimal, number of leg contracts to buy(positive) or sell(negative).
    /// Default is 1.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double QtyRatio {
      get { if ((_hasBits0 & 1) != 0) { return qtyRatio_; } else { return QtyRatioDefaultValue; } }
      set {
        _hasBits0 |= 1;
        qtyRatio_ = value;
      }
    }
    /// <summary>Gets whether the "qty_ratio" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasQtyRatio {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "qty_ratio" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearQtyRatio() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "price_ratio" field.</summary>
    public const int PriceRatioFieldNumber = 3;
    private readonly static double PriceRatioDefaultValue = 0D;

    private double priceRatio_;
    /// <summary>
    /// Leg price calculation ratio, signed decimal, coefficient in strategy price formula.
    /// Same as qty_ratio if omitted.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double PriceRatio {
      get { if ((_hasBits0 & 2) != 0) { return priceRatio_; } else { return PriceRatioDefaultValue; } }
      set {
        _hasBits0 |= 2;
        priceRatio_ = value;
      }
    }
    /// <summary>Gets whether the "price_ratio" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasPriceRatio {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "price_ratio" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearPriceRatio() {
      _hasBits0 &= ~2;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as NestedStrategy);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(NestedStrategy other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Definition, other.Definition)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(QtyRatio, other.QtyRatio)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(PriceRatio, other.PriceRatio)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (definition_ != null) hash ^= Definition.GetHashCode();
      if (HasQtyRatio) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(QtyRatio);
      if (HasPriceRatio) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(PriceRatio);
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (definition_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Definition);
      }
      if (HasQtyRatio) {
        output.WriteRawTag(17);
        output.WriteDouble(QtyRatio);
      }
      if (HasPriceRatio) {
        output.WriteRawTag(25);
        output.WriteDouble(PriceRatio);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (definition_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Definition);
      }
      if (HasQtyRatio) {
        output.WriteRawTag(17);
        output.WriteDouble(QtyRatio);
      }
      if (HasPriceRatio) {
        output.WriteRawTag(25);
        output.WriteDouble(PriceRatio);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (definition_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Definition);
      }
      if (HasQtyRatio) {
        size += 1 + 8;
      }
      if (HasPriceRatio) {
        size += 1 + 8;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(NestedStrategy other) {
      if (other == null) {
        return;
      }
      if (other.definition_ != null) {
        if (definition_ == null) {
          Definition = new global::StrategyDefinition2.StrategyDefinition();
        }
        Definition.MergeFrom(other.Definition);
      }
      if (other.HasQtyRatio) {
        QtyRatio = other.QtyRatio;
      }
      if (other.HasPriceRatio) {
        PriceRatio = other.PriceRatio;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (definition_ == null) {
              Definition = new global::StrategyDefinition2.StrategyDefinition();
            }
            input.ReadMessage(Definition);
            break;
          }
          case 17: {
            QtyRatio = input.ReadDouble();
            break;
          }
          case 25: {
            PriceRatio = input.ReadDouble();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (definition_ == null) {
              Definition = new global::StrategyDefinition2.StrategyDefinition();
            }
            input.ReadMessage(Definition);
            break;
          }
          case 17: {
            QtyRatio = input.ReadDouble();
            break;
          }
          case 25: {
            PriceRatio = input.ReadDouble();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Child node definition within the parent strategy tree. Can be either a resolved contract (leg) or a nested strategy.
  /// </summary>
  public sealed partial class StrategyNodeDefinition : pb::IMessage<StrategyNodeDefinition>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<StrategyNodeDefinition> _parser = new pb::MessageParser<StrategyNodeDefinition>(() => new StrategyNodeDefinition());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<StrategyNodeDefinition> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::StrategyDefinition2.StrategyDefinition2Reflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public StrategyNodeDefinition() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public StrategyNodeDefinition(StrategyNodeDefinition other) : this() {
      _hasBits0 = other._hasBits0;
      nodeOperation_ = other.nodeOperation_;
      leg_ = other.leg_ != null ? other.leg_.Clone() : null;
      nestedStrategy_ = other.nestedStrategy_ != null ? other.nestedStrategy_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public StrategyNodeDefinition Clone() {
      return new StrategyNodeDefinition(this);
    }

    /// <summary>Field number for the "node_operation" field.</summary>
    public const int NodeOperationFieldNumber = 2;
    private readonly static uint NodeOperationDefaultValue = 0;

    private uint nodeOperation_;
    /// <summary>
    /// Specified node operation, one of NodeOperation enums, the default is SUM.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint NodeOperation {
      get { if ((_hasBits0 & 1) != 0) { return nodeOperation_; } else { return NodeOperationDefaultValue; } }
      set {
        _hasBits0 |= 1;
        nodeOperation_ = value;
      }
    }
    /// <summary>Gets whether the "node_operation" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasNodeOperation {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "node_operation" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearNodeOperation() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "leg" field.</summary>
    public const int LegFieldNumber = 3;
    private global::StrategyDefinition2.LegDefinition leg_;
    /// <summary>
    /// Leg definition, if the node is a resolved contract.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::StrategyDefinition2.LegDefinition Leg {
      get { return leg_; }
      set {
        leg_ = value;
      }
    }

    /// <summary>Field number for the "nested_strategy" field.</summary>
    public const int NestedStrategyFieldNumber = 4;
    private global::StrategyDefinition2.NestedStrategy nestedStrategy_;
    /// <summary>
    /// Nested strategy, mutually exclusive with 'leg' attribute.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::StrategyDefinition2.NestedStrategy NestedStrategy {
      get { return nestedStrategy_; }
      set {
        nestedStrategy_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as StrategyNodeDefinition);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(StrategyNodeDefinition other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (NodeOperation != other.NodeOperation) return false;
      if (!object.Equals(Leg, other.Leg)) return false;
      if (!object.Equals(NestedStrategy, other.NestedStrategy)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasNodeOperation) hash ^= NodeOperation.GetHashCode();
      if (leg_ != null) hash ^= Leg.GetHashCode();
      if (nestedStrategy_ != null) hash ^= NestedStrategy.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasNodeOperation) {
        output.WriteRawTag(16);
        output.WriteUInt32(NodeOperation);
      }
      if (leg_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Leg);
      }
      if (nestedStrategy_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(NestedStrategy);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasNodeOperation) {
        output.WriteRawTag(16);
        output.WriteUInt32(NodeOperation);
      }
      if (leg_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Leg);
      }
      if (nestedStrategy_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(NestedStrategy);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (HasNodeOperation) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(NodeOperation);
      }
      if (leg_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Leg);
      }
      if (nestedStrategy_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(NestedStrategy);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(StrategyNodeDefinition other) {
      if (other == null) {
        return;
      }
      if (other.HasNodeOperation) {
        NodeOperation = other.NodeOperation;
      }
      if (other.leg_ != null) {
        if (leg_ == null) {
          Leg = new global::StrategyDefinition2.LegDefinition();
        }
        Leg.MergeFrom(other.Leg);
      }
      if (other.nestedStrategy_ != null) {
        if (nestedStrategy_ == null) {
          NestedStrategy = new global::StrategyDefinition2.NestedStrategy();
        }
        NestedStrategy.MergeFrom(other.NestedStrategy);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 16: {
            NodeOperation = input.ReadUInt32();
            break;
          }
          case 26: {
            if (leg_ == null) {
              Leg = new global::StrategyDefinition2.LegDefinition();
            }
            input.ReadMessage(Leg);
            break;
          }
          case 34: {
            if (nestedStrategy_ == null) {
              NestedStrategy = new global::StrategyDefinition2.NestedStrategy();
            }
            input.ReadMessage(NestedStrategy);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 16: {
            NodeOperation = input.ReadUInt32();
            break;
          }
          case 26: {
            if (leg_ == null) {
              Leg = new global::StrategyDefinition2.LegDefinition();
            }
            input.ReadMessage(Leg);
            break;
          }
          case 34: {
            if (nestedStrategy_ == null) {
              NestedStrategy = new global::StrategyDefinition2.NestedStrategy();
            }
            input.ReadMessage(NestedStrategy);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the StrategyNodeDefinition message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// Operation on a node of the synthetic strategy.
      /// Associating an operation with a node allows using different operations, e.g. multiplication and subtraction,
      /// without introducing intermediate StrategyDefinition entities.
      /// MUL and DIV cannot be mixed with SUM within the same StrategyDefinition.node_definition array.
      /// i.e. node1 / node2 * node3 is allowed, but node1 / node2 + node3 is not.
      /// </summary>
      public enum NodeOperation {
        /// <summary>
        /// Add the quantity and the price.
        /// </summary>
        [pbr::OriginalName("NODE_OPERATION_SUM")] Sum = 1,
        /// <summary>
        /// Add the quantity but multiply the price.
        /// </summary>
        [pbr::OriginalName("NODE_OPERATION_MUL")] Mul = 2,
        /// <summary>
        /// Subtract the quantity but divide the price.
        /// </summary>
        [pbr::OriginalName("NODE_OPERATION_DIV")] Div = 3,
      }

    }
    #endregion

  }

  #endregion

}

#endregion Designer generated code
