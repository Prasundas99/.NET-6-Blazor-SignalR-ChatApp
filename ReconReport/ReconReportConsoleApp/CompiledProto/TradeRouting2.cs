// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: WebAPI/trade_routing_2.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace TradeRouting2 {

  /// <summary>Holder for reflection information generated from WebAPI/trade_routing_2.proto</summary>
  public static partial class TradeRouting2Reflection {

    #region Descriptor
    /// <summary>File descriptor for WebAPI/trade_routing_2.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static TradeRouting2Reflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "ChxXZWJBUEkvdHJhZGVfcm91dGluZ18yLnByb3RvEg90cmFkZV9yb3V0aW5n",
            "XzIaFGNvbW1vbi9kZWNpbWFsLnByb3RvGhZjb21tb24vdGltZXN0YW1wLnBy",
            "b3RvGhdXZWJBUEkvbWV0YWRhdGFfMi5wcm90bxoUV2ViQVBJL29yZGVyXzIu",
            "cHJvdG8i2wYKEVRyYWRlU3Vic2NyaXB0aW9uEgoKAmlkGAEgAigNEhsKE3N1",
            "YnNjcmlwdGlvbl9zY29wZXMYAiADKA0SGAoQcHVibGljYXRpb25fdHlwZRgD",
            "IAEoDRISCgphY2NvdW50X2lkGAQgASgNEhsKE3NhbGVzX3Nlcmllc19udW1i",
            "ZXIYBSABKAkSFAoMYnJva2VyYWdlX2lkGAYgASgNEhEKCXN1YnNjcmliZRgH",
            "IAIoCBImChpsYXN0X29yZGVyX3VwZGF0ZV91dGNfdGltZRgIIAEoEkICGAES",
            "QwofbGFzdF9vcmRlcl91cGRhdGVfdXRjX3RpbWVzdGFtcBgOIAEoCzIaLmdv",
            "b2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASHAoUc2tpcF9vcmRlcnNfc25hcHNo",
            "b3QYCSABKAgSIAoYY29uZmlybWVkX3Bvc2l0aW9uc19vbmx5GAogASgIEhoK",
            "Em1hdGNoaW5nX2FsZ29yaXRobRgLIAEoDRIcChRtYXRjaF9pbnRyYWRheV9m",
            "aXJzdBgMIAEoCBIlCh1oaXN0b3JpY2FsX21hdGNoaW5nX2FsZ29yaXRobRgN",
            "IAEoDRIcChRpbmNsdWRlX2Nyb3NzX29yZGVycxgPIAEoCCJ3ChFTdWJzY3Jp",
            "cHRpb25TY29wZRIdChlTVUJTQ1JJUFRJT05fU0NPUEVfT1JERVJTEAESIAoc",
            "U1VCU0NSSVBUSU9OX1NDT1BFX1BPU0lUSU9OUxACEiEKHVNVQlNDUklQVElP",
            "Tl9TQ09QRV9DT0xMQVRFUkFMEAMilwEKD1B1YmxpY2F0aW9uVHlwZRIcChhQ",
            "VUJMSUNBVElPTl9UWVBFX0FDQ09VTlQQARIhCh1QVUJMSUNBVElPTl9UWVBF",
            "X1NBTEVTX1NFUklFUxACEh4KGlBVQkxJQ0FUSU9OX1RZUEVfQlJPS0VSQUdF",
            "EAMSIwofUFVCTElDQVRJT05fVFlQRV9BTExfQVVUSE9SSVpFRBAEImoKEU1h",
            "dGNoaW5nQWxnb3JpdGhtEhsKF01BVENISU5HX0FMR09SSVRITV9GSUZPEAES",
            "GwoXTUFUQ0hJTkdfQUxHT1JJVEhNX0hCSFMQAhIbChdNQVRDSElOR19BTEdP",
            "UklUSE1fTElGTxADIroCChdUcmFkZVN1YnNjcmlwdGlvblN0YXR1cxIKCgJp",
            "ZBgBIAIoDRITCgtzdGF0dXNfY29kZRgCIAIoDRIUCgx0ZXh0X21lc3NhZ2UY",
            "AyABKAki5wEKClN0YXR1c0NvZGUSFwoTU1RBVFVTX0NPREVfU1VDQ0VTUxAA",
            "EhwKGFNUQVRVU19DT0RFX0RJU0NPTk5FQ1RFRBABEhcKE1NUQVRVU19DT0RF",
            "X0ZBSUxVUkUQZRIsCihTVEFUVVNfQ09ERV9TVUJTQ1JJUFRJT05fTElNSVRf",
            "VklPTEFUSU9OEGYSJgoiU1RBVFVTX0NPREVfSU5WQUxJRF9QVUJMSUNBVElP",
            "Tl9JRBBnEjMKL1NUQVRVU19DT0RFX1NVQlNDUklCRURfQUNDT1VOVFNfTElN",
            "SVRfVklPTEFUSU9OEGgiTwoXVHJhZGVTbmFwc2hvdENvbXBsZXRpb24SFwoP",
            "c3Vic2NyaXB0aW9uX2lkGAEgAigNEhsKE3N1YnNjcmlwdGlvbl9zY29wZXMY",
            "AiADKA0i/AIKDlBvc2l0aW9uU3RhdHVzEhgKEHN1YnNjcmlwdGlvbl9pZHMY",
            "ASADKA0SEwoLaXNfc25hcHNob3QYAiABKAgSEgoKYWNjb3VudF9pZBgDIAIo",
            "ERITCgtjb250cmFjdF9pZBgEIAIoDRIiChZpc19zaG9ydF9vcGVuX3Bvc2l0",
            "aW9uGAUgAigIQgIYARI1Cg5vcGVuX3Bvc2l0aW9ucxgGIAMoCzIdLnRyYWRl",
            "X3JvdXRpbmdfMi5PcGVuUG9zaXRpb24SSQoZcHVyY2hhc2VfYW5kX3NhbGVz",
            "X2dyb3VwcxgHIAMoCzImLnRyYWRlX3JvdXRpbmdfMi5QdXJjaGFzZUFuZFNh",
            "bGVzR3JvdXASNwoRY29udHJhY3RfbWV0YWRhdGEYCCABKAsyHC5tZXRhZGF0",
            "YV8yLkNvbnRyYWN0TWV0YWRhdGESMwoWdG9kYXlfZmlsbF9jb21taXNzaW9u",
            "cxgJIAMoCzITLm9yZGVyXzIuQ29tbWlzc2lvbiLFAgoMT3BlblBvc2l0aW9u",
            "EgoKAmlkGAEgAigREhYKCnVpbnQzMl9xdHkYAiABKA1CAhgBEhkKA3F0eRgM",
            "IAEoCzIMLmNxZy5EZWNpbWFsEhUKDXByaWNlX2NvcnJlY3QYAyACKAESEgoK",
            "dHJhZGVfZGF0ZRgEIAIoEhIWCg5zdGF0ZW1lbnRfZGF0ZRgFIAIoEhIaCg50",
            "cmFkZV91dGNfdGltZRgGIAEoEkICGAESNwoTdHJhZGVfdXRjX3RpbWVzdGFt",
            "cBgIIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASFQoNaXNfYWdn",
            "cmVnYXRlZBgHIAIoCBIQCghpc19zaG9ydBgJIAIoCBIbCgxpc195ZXN0ZXJk",
            "YXkYCiABKAg6BWZhbHNlEhgKEHNwZWN1bGF0aW9uX3R5cGUYCyABKA0ieAoV",
            "UHVyY2hhc2VBbmRTYWxlc0dyb3VwEgoKAmlkGAEgAigREhwKFHJlYWxpemVk",
            "X3Byb2ZpdF9sb3NzGAIgAigBEjUKDm1hdGNoZWRfdHJhZGVzGAMgAygLMh0u",
            "dHJhZGVfcm91dGluZ18yLk1hdGNoZWRUcmFkZSLDAgoMTWF0Y2hlZFRyYWRl",
            "EhYKCnVpbnQzMl9xdHkYASABKA1CAhgBEhkKA3F0eRgMIAEoCzIMLmNxZy5E",
            "ZWNpbWFsEhAKCGlzX3Nob3J0GAIgASgIEg0KBXByaWNlGAMgAigBEhIKCnRy",
            "YWRlX2RhdGUYBCACKBISFgoOc3RhdGVtZW50X2RhdGUYBSACKBISGgoOdHJh",
            "ZGVfdXRjX3RpbWUYBiABKBJCAhgBEjcKE3RyYWRlX3V0Y190aW1lc3RhbXAY",
            "CCABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEhUKDWlzX2FnZ3Jl",
            "Z2F0ZWQYByACKAgSGwoMaXNfeWVzdGVyZGF5GAkgASgIOgVmYWxzZRIQCghp",
            "c19jbG9zZRgKIAEoCBIYChBzcGVjdWxhdGlvbl90eXBlGAsgASgNIu4BChBD",
            "b2xsYXRlcmFsU3RhdHVzEhgKEHN1YnNjcmlwdGlvbl9pZHMYASADKA0SEwoL",
            "aXNfc25hcHNob3QYAiABKAgSEgoKYWNjb3VudF9pZBgDIAIoERIQCghjdXJy",
            "ZW5jeRgEIAIoCRIUCgx0b3RhbF9tYXJnaW4YBSACKAESFwoPcG9zaXRpb25f",
            "bWFyZ2luGAsgASgBEhgKEHB1cmNoYXNpbmdfcG93ZXIYBiACKAESCwoDb3Rl",
            "GAcgASgBEgsKA212bxgIIAEoARILCgNtdmYYCiABKAESFQoNbWFyZ2luX2Ny",
            "ZWRpdBgJIAEoASJwChdIaXN0b3JpY2FsT3JkZXJzUmVxdWVzdBIRCglmcm9t",
            "X2RhdGUYASACKBISDwoHdG9fZGF0ZRgCIAEoEhITCgthY2NvdW50X2lkcxgD",
            "IAMoERIcChRpbmNsdWRlX2Nyb3NzX29yZGVycxgEIAEoCCJGChZIaXN0b3Jp",
            "Y2FsT3JkZXJzUmVwb3J0EiwKDm9yZGVyX3N0YXR1c2VzGAEgAygLMhQub3Jk",
            "ZXJfMi5PcmRlclN0YXR1cw=="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Cqg.DecimalReflection.Descriptor, global::Google.Protobuf.TimestampReflection.Descriptor, global::Metadata2.Metadata2Reflection.Descriptor, global::Order2.Order2Reflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::TradeRouting2.TradeSubscription), global::TradeRouting2.TradeSubscription.Parser, new[]{ "Id", "SubscriptionScopes", "PublicationType", "AccountId", "SalesSeriesNumber", "BrokerageId", "Subscribe", "LastOrderUpdateUtcTime", "LastOrderUpdateUtcTimestamp", "SkipOrdersSnapshot", "ConfirmedPositionsOnly", "MatchingAlgorithm", "MatchIntradayFirst", "HistoricalMatchingAlgorithm", "IncludeCrossOrders" }, null, new[]{ typeof(global::TradeRouting2.TradeSubscription.Types.SubscriptionScope), typeof(global::TradeRouting2.TradeSubscription.Types.PublicationType), typeof(global::TradeRouting2.TradeSubscription.Types.MatchingAlgorithm) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::TradeRouting2.TradeSubscriptionStatus), global::TradeRouting2.TradeSubscriptionStatus.Parser, new[]{ "Id", "StatusCode", "TextMessage" }, null, new[]{ typeof(global::TradeRouting2.TradeSubscriptionStatus.Types.StatusCode) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::TradeRouting2.TradeSnapshotCompletion), global::TradeRouting2.TradeSnapshotCompletion.Parser, new[]{ "SubscriptionId", "SubscriptionScopes" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::TradeRouting2.PositionStatus), global::TradeRouting2.PositionStatus.Parser, new[]{ "SubscriptionIds", "IsSnapshot", "AccountId", "ContractId", "IsShortOpenPosition", "OpenPositions", "PurchaseAndSalesGroups", "ContractMetadata", "TodayFillCommissions" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::TradeRouting2.OpenPosition), global::TradeRouting2.OpenPosition.Parser, new[]{ "Id", "Uint32Qty", "Qty", "PriceCorrect", "TradeDate", "StatementDate", "TradeUtcTime", "TradeUtcTimestamp", "IsAggregated", "IsShort", "IsYesterday", "SpeculationType" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::TradeRouting2.PurchaseAndSalesGroup), global::TradeRouting2.PurchaseAndSalesGroup.Parser, new[]{ "Id", "RealizedProfitLoss", "MatchedTrades" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::TradeRouting2.MatchedTrade), global::TradeRouting2.MatchedTrade.Parser, new[]{ "Uint32Qty", "Qty", "IsShort", "Price", "TradeDate", "StatementDate", "TradeUtcTime", "TradeUtcTimestamp", "IsAggregated", "IsYesterday", "IsClose", "SpeculationType" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::TradeRouting2.CollateralStatus), global::TradeRouting2.CollateralStatus.Parser, new[]{ "SubscriptionIds", "IsSnapshot", "AccountId", "Currency", "TotalMargin", "PositionMargin", "PurchasingPower", "Ote", "Mvo", "Mvf", "MarginCredit" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::TradeRouting2.HistoricalOrdersRequest), global::TradeRouting2.HistoricalOrdersRequest.Parser, new[]{ "FromDate", "ToDate", "AccountIds", "IncludeCrossOrders" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::TradeRouting2.HistoricalOrdersReport), global::TradeRouting2.HistoricalOrdersReport.Parser, new[]{ "OrderStatuses" }, null, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// Subscription to trade routing data and notifications about trading information updates.
  /// Client can be subscribed to several publications.
  /// If some account is subscribed by several publications then client will receive a separate snapshot per subscription
  /// but one real time update with a list of subscriptions.
  /// </summary>
  public sealed partial class TradeSubscription : pb::IMessage<TradeSubscription>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<TradeSubscription> _parser = new pb::MessageParser<TradeSubscription>(() => new TradeSubscription());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<TradeSubscription> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::TradeRouting2.TradeRouting2Reflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TradeSubscription() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TradeSubscription(TradeSubscription other) : this() {
      _hasBits0 = other._hasBits0;
      id_ = other.id_;
      subscriptionScopes_ = other.subscriptionScopes_.Clone();
      publicationType_ = other.publicationType_;
      accountId_ = other.accountId_;
      salesSeriesNumber_ = other.salesSeriesNumber_;
      brokerageId_ = other.brokerageId_;
      subscribe_ = other.subscribe_;
      lastOrderUpdateUtcTime_ = other.lastOrderUpdateUtcTime_;
      lastOrderUpdateUtcTimestamp_ = other.lastOrderUpdateUtcTimestamp_ != null ? other.lastOrderUpdateUtcTimestamp_.Clone() : null;
      skipOrdersSnapshot_ = other.skipOrdersSnapshot_;
      confirmedPositionsOnly_ = other.confirmedPositionsOnly_;
      matchingAlgorithm_ = other.matchingAlgorithm_;
      matchIntradayFirst_ = other.matchIntradayFirst_;
      historicalMatchingAlgorithm_ = other.historicalMatchingAlgorithm_;
      includeCrossOrders_ = other.includeCrossOrders_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TradeSubscription Clone() {
      return new TradeSubscription(this);
    }

    /// <summary>Field number for the "id" field.</summary>
    public const int IdFieldNumber = 1;
    private readonly static uint IdDefaultValue = 0;

    private uint id_;
    /// <summary>
    /// ID of a subscription that should be unique enough to match responses and updates with corresponding requests.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint Id {
      get { if ((_hasBits0 & 1) != 0) { return id_; } else { return IdDefaultValue; } }
      set {
        _hasBits0 |= 1;
        id_ = value;
      }
    }
    /// <summary>Gets whether the "id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasId {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearId() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "subscription_scopes" field.</summary>
    public const int SubscriptionScopesFieldNumber = 2;
    private static readonly pb::FieldCodec<uint> _repeated_subscriptionScopes_codec
        = pb::FieldCodec.ForUInt32(16);
    private readonly pbc::RepeatedField<uint> subscriptionScopes_ = new pbc::RepeatedField<uint>();
    /// <summary>
    /// This field is associated with SubscriptionScope enum type.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<uint> SubscriptionScopes {
      get { return subscriptionScopes_; }
    }

    /// <summary>Field number for the "publication_type" field.</summary>
    public const int PublicationTypeFieldNumber = 3;
    private readonly static uint PublicationTypeDefaultValue = 0;

    private uint publicationType_;
    /// <summary>
    /// This field is associated with PublicationType enum type.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint PublicationType {
      get { if ((_hasBits0 & 2) != 0) { return publicationType_; } else { return PublicationTypeDefaultValue; } }
      set {
        _hasBits0 |= 2;
        publicationType_ = value;
      }
    }
    /// <summary>Gets whether the "publication_type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasPublicationType {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "publication_type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearPublicationType() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "account_id" field.</summary>
    public const int AccountIdFieldNumber = 4;
    private readonly static uint AccountIdDefaultValue = 0;

    private uint accountId_;
    /// <summary>
    /// Account ID when publicationType = PUBLICATION_TYPE_ACCOUNT.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint AccountId {
      get { if ((_hasBits0 & 4) != 0) { return accountId_; } else { return AccountIdDefaultValue; } }
      set {
        _hasBits0 |= 4;
        accountId_ = value;
      }
    }
    /// <summary>Gets whether the "account_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasAccountId {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "account_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearAccountId() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "sales_series_number" field.</summary>
    public const int SalesSeriesNumberFieldNumber = 5;
    private readonly static string SalesSeriesNumberDefaultValue = "";

    private string salesSeriesNumber_;
    /// <summary>
    /// Sales series number when publicationType = PUBLICATION_TYPE_SALES_SERIES.
    /// Note: sales_series_number might be not enough to find specific sales series,
    /// so brokerage_id is needed to be specified as well.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string SalesSeriesNumber {
      get { return salesSeriesNumber_ ?? SalesSeriesNumberDefaultValue; }
      set {
        salesSeriesNumber_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "sales_series_number" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasSalesSeriesNumber {
      get { return salesSeriesNumber_ != null; }
    }
    /// <summary>Clears the value of the "sales_series_number" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearSalesSeriesNumber() {
      salesSeriesNumber_ = null;
    }

    /// <summary>Field number for the "brokerage_id" field.</summary>
    public const int BrokerageIdFieldNumber = 6;
    private readonly static uint BrokerageIdDefaultValue = 0;

    private uint brokerageId_;
    /// <summary>
    /// Brokerage ID when publicationType = PUBLICATION_TYPE_BROKERAGE or PUBLICATION_TYPE_SALES_SERIES.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint BrokerageId {
      get { if ((_hasBits0 & 8) != 0) { return brokerageId_; } else { return BrokerageIdDefaultValue; } }
      set {
        _hasBits0 |= 8;
        brokerageId_ = value;
      }
    }
    /// <summary>Gets whether the "brokerage_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasBrokerageId {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "brokerage_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearBrokerageId() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "subscribe" field.</summary>
    public const int SubscribeFieldNumber = 7;
    private readonly static bool SubscribeDefaultValue = false;

    private bool subscribe_;
    /// <summary>
    /// True to subscribe, false to unsubscribe (only id value is used to unsubscribe).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Subscribe {
      get { if ((_hasBits0 & 16) != 0) { return subscribe_; } else { return SubscribeDefaultValue; } }
      set {
        _hasBits0 |= 16;
        subscribe_ = value;
      }
    }
    /// <summary>Gets whether the "subscribe" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasSubscribe {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "subscribe" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearSubscribe() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "last_order_update_utc_time" field.</summary>
    public const int LastOrderUpdateUtcTimeFieldNumber = 8;
    private readonly static long LastOrderUpdateUtcTimeDefaultValue = 0L;

    private long lastOrderUpdateUtcTime_;
    /// <summary>
    /// Optionally limit request to receive information about orders that were updated/ added after specified server related time (inclusive).
    /// It is used to reduce amount of information necessary to send after re-connection.
    /// Client should set this time equal to the last received order status time ('status_utc_time' field) in UTC to avoid gaps and
    /// be ready for duplicates that have to be detected by corresponding IDs.
    /// Note: use last_order_update_utc_timestamp field instead.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long LastOrderUpdateUtcTime {
      get { if ((_hasBits0 & 32) != 0) { return lastOrderUpdateUtcTime_; } else { return LastOrderUpdateUtcTimeDefaultValue; } }
      set {
        _hasBits0 |= 32;
        lastOrderUpdateUtcTime_ = value;
      }
    }
    /// <summary>Gets whether the "last_order_update_utc_time" field is set</summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasLastOrderUpdateUtcTime {
      get { return (_hasBits0 & 32) != 0; }
    }
    /// <summary>Clears the value of the "last_order_update_utc_time" field</summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearLastOrderUpdateUtcTime() {
      _hasBits0 &= ~32;
    }

    /// <summary>Field number for the "last_order_update_utc_timestamp" field.</summary>
    public const int LastOrderUpdateUtcTimestampFieldNumber = 14;
    private global::Google.Protobuf.Timestamp lastOrderUpdateUtcTimestamp_;
    /// <summary>
    /// Optionally limit request to receive information about orders that were updated/ added after specified server related time (inclusive).
    /// It is used to reduce amount of information necessary to send after re-connection.
    /// Client should set this time equal to the last received order status time ('status_utc_time' field) in UTC to avoid gaps and
    /// be ready for duplicates that have to be detected by corresponding IDs.
    /// If specified it's used instead of last_order_update_utc_time field.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.Timestamp LastOrderUpdateUtcTimestamp {
      get { return lastOrderUpdateUtcTimestamp_; }
      set {
        lastOrderUpdateUtcTimestamp_ = value;
      }
    }

    /// <summary>Field number for the "skip_orders_snapshot" field.</summary>
    public const int SkipOrdersSnapshotFieldNumber = 9;
    private readonly static bool SkipOrdersSnapshotDefaultValue = false;

    private bool skipOrdersSnapshot_;
    /// <summary>
    /// True means sending only real time data and skip sending an initial orders snapshot, send initial snapshot otherwise.
    /// NOTE: do not set this attribute after restoring session since some events might be missed to be delivered,
    /// use last_order_update_utc_time instead.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool SkipOrdersSnapshot {
      get { if ((_hasBits0 & 64) != 0) { return skipOrdersSnapshot_; } else { return SkipOrdersSnapshotDefaultValue; } }
      set {
        _hasBits0 |= 64;
        skipOrdersSnapshot_ = value;
      }
    }
    /// <summary>Gets whether the "skip_orders_snapshot" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasSkipOrdersSnapshot {
      get { return (_hasBits0 & 64) != 0; }
    }
    /// <summary>Clears the value of the "skip_orders_snapshot" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearSkipOrdersSnapshot() {
      _hasBits0 &= ~64;
    }

    /// <summary>Field number for the "confirmed_positions_only" field.</summary>
    public const int ConfirmedPositionsOnlyFieldNumber = 10;
    private readonly static bool ConfirmedPositionsOnlyDefaultValue = false;

    private bool confirmedPositionsOnly_;
    /// <summary>
    /// True means sending only FCM confirmed positions and their updates (if subscribed)
    /// without matching with current day fills, send matched net positions otherwise.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool ConfirmedPositionsOnly {
      get { if ((_hasBits0 & 128) != 0) { return confirmedPositionsOnly_; } else { return ConfirmedPositionsOnlyDefaultValue; } }
      set {
        _hasBits0 |= 128;
        confirmedPositionsOnly_ = value;
      }
    }
    /// <summary>Gets whether the "confirmed_positions_only" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasConfirmedPositionsOnly {
      get { return (_hasBits0 & 128) != 0; }
    }
    /// <summary>Clears the value of the "confirmed_positions_only" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearConfirmedPositionsOnly() {
      _hasBits0 &= ~128;
    }

    /// <summary>Field number for the "matching_algorithm" field.</summary>
    public const int MatchingAlgorithmFieldNumber = 11;
    private readonly static uint MatchingAlgorithmDefaultValue = 0;

    private uint matchingAlgorithm_;
    /// <summary>
    /// This field is associated with MatchingAlgorithm enum type.
    /// MATCHING_ALGORITHM_FIFO is used if omitted.
    /// Applicable only for contracts with ContractMetadata.position_tracking = POSITION_TRACKING_TYPE_NET_POSITION.
    /// For other contract types it is always MATCHING_ALGORITHM_FIFO.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint MatchingAlgorithm {
      get { if ((_hasBits0 & 256) != 0) { return matchingAlgorithm_; } else { return MatchingAlgorithmDefaultValue; } }
      set {
        _hasBits0 |= 256;
        matchingAlgorithm_ = value;
      }
    }
    /// <summary>Gets whether the "matching_algorithm" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasMatchingAlgorithm {
      get { return (_hasBits0 & 256) != 0; }
    }
    /// <summary>Clears the value of the "matching_algorithm" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearMatchingAlgorithm() {
      _hasBits0 &= ~256;
    }

    /// <summary>Field number for the "match_intraday_first" field.</summary>
    public const int MatchIntradayFirstFieldNumber = 12;
    private readonly static bool MatchIntradayFirstDefaultValue = false;

    private bool matchIntradayFirst_;
    /// <summary>
    /// If true or omitted then intraday trades are matched first and then intraday leftover is matched against previous close positions.
    /// If false then previous day open positions and intraday fills are matched in a single pass.
    /// Applicable only for contracts with ContractMetadata.position_tracking = POSITION_TRACKING_TYPE_NET_POSITION.
    /// For other contract types it is always false.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool MatchIntradayFirst {
      get { if ((_hasBits0 & 512) != 0) { return matchIntradayFirst_; } else { return MatchIntradayFirstDefaultValue; } }
      set {
        _hasBits0 |= 512;
        matchIntradayFirst_ = value;
      }
    }
    /// <summary>Gets whether the "match_intraday_first" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasMatchIntradayFirst {
      get { return (_hasBits0 & 512) != 0; }
    }
    /// <summary>Clears the value of the "match_intraday_first" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearMatchIntradayFirst() {
      _hasBits0 &= ~512;
    }

    /// <summary>Field number for the "historical_matching_algorithm" field.</summary>
    public const int HistoricalMatchingAlgorithmFieldNumber = 13;
    private readonly static uint HistoricalMatchingAlgorithmDefaultValue = 0;

    private uint historicalMatchingAlgorithm_;
    /// <summary>
    /// This field is associated with MatchingAlgorithm enum type.
    /// Historical positions Matching algorithm. The same as matching_algorithm if omitted.
    /// It is ignored if match_intraday_first is false.
    /// Applicable only for contracts with ContractMetadata.position_tracking = POSITION_TRACKING_TYPE_NET_POSITION.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint HistoricalMatchingAlgorithm {
      get { if ((_hasBits0 & 1024) != 0) { return historicalMatchingAlgorithm_; } else { return HistoricalMatchingAlgorithmDefaultValue; } }
      set {
        _hasBits0 |= 1024;
        historicalMatchingAlgorithm_ = value;
      }
    }
    /// <summary>Gets whether the "historical_matching_algorithm" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasHistoricalMatchingAlgorithm {
      get { return (_hasBits0 & 1024) != 0; }
    }
    /// <summary>Clears the value of the "historical_matching_algorithm" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearHistoricalMatchingAlgorithm() {
      _hasBits0 &= ~1024;
    }

    /// <summary>Field number for the "include_cross_orders" field.</summary>
    public const int IncludeCrossOrdersFieldNumber = 15;
    private readonly static bool IncludeCrossOrdersDefaultValue = false;

    private bool includeCrossOrders_;
    /// <summary>
    /// If this field set to true, statuses on orders with ORDER_TYPE_CROSS type will be
    /// included into responses. See CrossOrderParameters message.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IncludeCrossOrders {
      get { if ((_hasBits0 & 2048) != 0) { return includeCrossOrders_; } else { return IncludeCrossOrdersDefaultValue; } }
      set {
        _hasBits0 |= 2048;
        includeCrossOrders_ = value;
      }
    }
    /// <summary>Gets whether the "include_cross_orders" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasIncludeCrossOrders {
      get { return (_hasBits0 & 2048) != 0; }
    }
    /// <summary>Clears the value of the "include_cross_orders" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearIncludeCrossOrders() {
      _hasBits0 &= ~2048;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as TradeSubscription);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(TradeSubscription other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Id != other.Id) return false;
      if(!subscriptionScopes_.Equals(other.subscriptionScopes_)) return false;
      if (PublicationType != other.PublicationType) return false;
      if (AccountId != other.AccountId) return false;
      if (SalesSeriesNumber != other.SalesSeriesNumber) return false;
      if (BrokerageId != other.BrokerageId) return false;
      if (Subscribe != other.Subscribe) return false;
      if (LastOrderUpdateUtcTime != other.LastOrderUpdateUtcTime) return false;
      if (!object.Equals(LastOrderUpdateUtcTimestamp, other.LastOrderUpdateUtcTimestamp)) return false;
      if (SkipOrdersSnapshot != other.SkipOrdersSnapshot) return false;
      if (ConfirmedPositionsOnly != other.ConfirmedPositionsOnly) return false;
      if (MatchingAlgorithm != other.MatchingAlgorithm) return false;
      if (MatchIntradayFirst != other.MatchIntradayFirst) return false;
      if (HistoricalMatchingAlgorithm != other.HistoricalMatchingAlgorithm) return false;
      if (IncludeCrossOrders != other.IncludeCrossOrders) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasId) hash ^= Id.GetHashCode();
      hash ^= subscriptionScopes_.GetHashCode();
      if (HasPublicationType) hash ^= PublicationType.GetHashCode();
      if (HasAccountId) hash ^= AccountId.GetHashCode();
      if (HasSalesSeriesNumber) hash ^= SalesSeriesNumber.GetHashCode();
      if (HasBrokerageId) hash ^= BrokerageId.GetHashCode();
      if (HasSubscribe) hash ^= Subscribe.GetHashCode();
      if (HasLastOrderUpdateUtcTime) hash ^= LastOrderUpdateUtcTime.GetHashCode();
      if (lastOrderUpdateUtcTimestamp_ != null) hash ^= LastOrderUpdateUtcTimestamp.GetHashCode();
      if (HasSkipOrdersSnapshot) hash ^= SkipOrdersSnapshot.GetHashCode();
      if (HasConfirmedPositionsOnly) hash ^= ConfirmedPositionsOnly.GetHashCode();
      if (HasMatchingAlgorithm) hash ^= MatchingAlgorithm.GetHashCode();
      if (HasMatchIntradayFirst) hash ^= MatchIntradayFirst.GetHashCode();
      if (HasHistoricalMatchingAlgorithm) hash ^= HistoricalMatchingAlgorithm.GetHashCode();
      if (HasIncludeCrossOrders) hash ^= IncludeCrossOrders.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasId) {
        output.WriteRawTag(8);
        output.WriteUInt32(Id);
      }
      subscriptionScopes_.WriteTo(output, _repeated_subscriptionScopes_codec);
      if (HasPublicationType) {
        output.WriteRawTag(24);
        output.WriteUInt32(PublicationType);
      }
      if (HasAccountId) {
        output.WriteRawTag(32);
        output.WriteUInt32(AccountId);
      }
      if (HasSalesSeriesNumber) {
        output.WriteRawTag(42);
        output.WriteString(SalesSeriesNumber);
      }
      if (HasBrokerageId) {
        output.WriteRawTag(48);
        output.WriteUInt32(BrokerageId);
      }
      if (HasSubscribe) {
        output.WriteRawTag(56);
        output.WriteBool(Subscribe);
      }
      if (HasLastOrderUpdateUtcTime) {
        output.WriteRawTag(64);
        output.WriteSInt64(LastOrderUpdateUtcTime);
      }
      if (HasSkipOrdersSnapshot) {
        output.WriteRawTag(72);
        output.WriteBool(SkipOrdersSnapshot);
      }
      if (HasConfirmedPositionsOnly) {
        output.WriteRawTag(80);
        output.WriteBool(ConfirmedPositionsOnly);
      }
      if (HasMatchingAlgorithm) {
        output.WriteRawTag(88);
        output.WriteUInt32(MatchingAlgorithm);
      }
      if (HasMatchIntradayFirst) {
        output.WriteRawTag(96);
        output.WriteBool(MatchIntradayFirst);
      }
      if (HasHistoricalMatchingAlgorithm) {
        output.WriteRawTag(104);
        output.WriteUInt32(HistoricalMatchingAlgorithm);
      }
      if (lastOrderUpdateUtcTimestamp_ != null) {
        output.WriteRawTag(114);
        output.WriteMessage(LastOrderUpdateUtcTimestamp);
      }
      if (HasIncludeCrossOrders) {
        output.WriteRawTag(120);
        output.WriteBool(IncludeCrossOrders);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasId) {
        output.WriteRawTag(8);
        output.WriteUInt32(Id);
      }
      subscriptionScopes_.WriteTo(ref output, _repeated_subscriptionScopes_codec);
      if (HasPublicationType) {
        output.WriteRawTag(24);
        output.WriteUInt32(PublicationType);
      }
      if (HasAccountId) {
        output.WriteRawTag(32);
        output.WriteUInt32(AccountId);
      }
      if (HasSalesSeriesNumber) {
        output.WriteRawTag(42);
        output.WriteString(SalesSeriesNumber);
      }
      if (HasBrokerageId) {
        output.WriteRawTag(48);
        output.WriteUInt32(BrokerageId);
      }
      if (HasSubscribe) {
        output.WriteRawTag(56);
        output.WriteBool(Subscribe);
      }
      if (HasLastOrderUpdateUtcTime) {
        output.WriteRawTag(64);
        output.WriteSInt64(LastOrderUpdateUtcTime);
      }
      if (HasSkipOrdersSnapshot) {
        output.WriteRawTag(72);
        output.WriteBool(SkipOrdersSnapshot);
      }
      if (HasConfirmedPositionsOnly) {
        output.WriteRawTag(80);
        output.WriteBool(ConfirmedPositionsOnly);
      }
      if (HasMatchingAlgorithm) {
        output.WriteRawTag(88);
        output.WriteUInt32(MatchingAlgorithm);
      }
      if (HasMatchIntradayFirst) {
        output.WriteRawTag(96);
        output.WriteBool(MatchIntradayFirst);
      }
      if (HasHistoricalMatchingAlgorithm) {
        output.WriteRawTag(104);
        output.WriteUInt32(HistoricalMatchingAlgorithm);
      }
      if (lastOrderUpdateUtcTimestamp_ != null) {
        output.WriteRawTag(114);
        output.WriteMessage(LastOrderUpdateUtcTimestamp);
      }
      if (HasIncludeCrossOrders) {
        output.WriteRawTag(120);
        output.WriteBool(IncludeCrossOrders);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (HasId) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Id);
      }
      size += subscriptionScopes_.CalculateSize(_repeated_subscriptionScopes_codec);
      if (HasPublicationType) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(PublicationType);
      }
      if (HasAccountId) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(AccountId);
      }
      if (HasSalesSeriesNumber) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(SalesSeriesNumber);
      }
      if (HasBrokerageId) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(BrokerageId);
      }
      if (HasSubscribe) {
        size += 1 + 1;
      }
      if (HasLastOrderUpdateUtcTime) {
        size += 1 + pb::CodedOutputStream.ComputeSInt64Size(LastOrderUpdateUtcTime);
      }
      if (lastOrderUpdateUtcTimestamp_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(LastOrderUpdateUtcTimestamp);
      }
      if (HasSkipOrdersSnapshot) {
        size += 1 + 1;
      }
      if (HasConfirmedPositionsOnly) {
        size += 1 + 1;
      }
      if (HasMatchingAlgorithm) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(MatchingAlgorithm);
      }
      if (HasMatchIntradayFirst) {
        size += 1 + 1;
      }
      if (HasHistoricalMatchingAlgorithm) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(HistoricalMatchingAlgorithm);
      }
      if (HasIncludeCrossOrders) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(TradeSubscription other) {
      if (other == null) {
        return;
      }
      if (other.HasId) {
        Id = other.Id;
      }
      subscriptionScopes_.Add(other.subscriptionScopes_);
      if (other.HasPublicationType) {
        PublicationType = other.PublicationType;
      }
      if (other.HasAccountId) {
        AccountId = other.AccountId;
      }
      if (other.HasSalesSeriesNumber) {
        SalesSeriesNumber = other.SalesSeriesNumber;
      }
      if (other.HasBrokerageId) {
        BrokerageId = other.BrokerageId;
      }
      if (other.HasSubscribe) {
        Subscribe = other.Subscribe;
      }
      if (other.HasLastOrderUpdateUtcTime) {
        LastOrderUpdateUtcTime = other.LastOrderUpdateUtcTime;
      }
      if (other.lastOrderUpdateUtcTimestamp_ != null) {
        if (lastOrderUpdateUtcTimestamp_ == null) {
          LastOrderUpdateUtcTimestamp = new global::Google.Protobuf.Timestamp();
        }
        LastOrderUpdateUtcTimestamp.MergeFrom(other.LastOrderUpdateUtcTimestamp);
      }
      if (other.HasSkipOrdersSnapshot) {
        SkipOrdersSnapshot = other.SkipOrdersSnapshot;
      }
      if (other.HasConfirmedPositionsOnly) {
        ConfirmedPositionsOnly = other.ConfirmedPositionsOnly;
      }
      if (other.HasMatchingAlgorithm) {
        MatchingAlgorithm = other.MatchingAlgorithm;
      }
      if (other.HasMatchIntradayFirst) {
        MatchIntradayFirst = other.MatchIntradayFirst;
      }
      if (other.HasHistoricalMatchingAlgorithm) {
        HistoricalMatchingAlgorithm = other.HistoricalMatchingAlgorithm;
      }
      if (other.HasIncludeCrossOrders) {
        IncludeCrossOrders = other.IncludeCrossOrders;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Id = input.ReadUInt32();
            break;
          }
          case 18:
          case 16: {
            subscriptionScopes_.AddEntriesFrom(input, _repeated_subscriptionScopes_codec);
            break;
          }
          case 24: {
            PublicationType = input.ReadUInt32();
            break;
          }
          case 32: {
            AccountId = input.ReadUInt32();
            break;
          }
          case 42: {
            SalesSeriesNumber = input.ReadString();
            break;
          }
          case 48: {
            BrokerageId = input.ReadUInt32();
            break;
          }
          case 56: {
            Subscribe = input.ReadBool();
            break;
          }
          case 64: {
            LastOrderUpdateUtcTime = input.ReadSInt64();
            break;
          }
          case 72: {
            SkipOrdersSnapshot = input.ReadBool();
            break;
          }
          case 80: {
            ConfirmedPositionsOnly = input.ReadBool();
            break;
          }
          case 88: {
            MatchingAlgorithm = input.ReadUInt32();
            break;
          }
          case 96: {
            MatchIntradayFirst = input.ReadBool();
            break;
          }
          case 104: {
            HistoricalMatchingAlgorithm = input.ReadUInt32();
            break;
          }
          case 114: {
            if (lastOrderUpdateUtcTimestamp_ == null) {
              LastOrderUpdateUtcTimestamp = new global::Google.Protobuf.Timestamp();
            }
            input.ReadMessage(LastOrderUpdateUtcTimestamp);
            break;
          }
          case 120: {
            IncludeCrossOrders = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Id = input.ReadUInt32();
            break;
          }
          case 18:
          case 16: {
            subscriptionScopes_.AddEntriesFrom(ref input, _repeated_subscriptionScopes_codec);
            break;
          }
          case 24: {
            PublicationType = input.ReadUInt32();
            break;
          }
          case 32: {
            AccountId = input.ReadUInt32();
            break;
          }
          case 42: {
            SalesSeriesNumber = input.ReadString();
            break;
          }
          case 48: {
            BrokerageId = input.ReadUInt32();
            break;
          }
          case 56: {
            Subscribe = input.ReadBool();
            break;
          }
          case 64: {
            LastOrderUpdateUtcTime = input.ReadSInt64();
            break;
          }
          case 72: {
            SkipOrdersSnapshot = input.ReadBool();
            break;
          }
          case 80: {
            ConfirmedPositionsOnly = input.ReadBool();
            break;
          }
          case 88: {
            MatchingAlgorithm = input.ReadUInt32();
            break;
          }
          case 96: {
            MatchIntradayFirst = input.ReadBool();
            break;
          }
          case 104: {
            HistoricalMatchingAlgorithm = input.ReadUInt32();
            break;
          }
          case 114: {
            if (lastOrderUpdateUtcTimestamp_ == null) {
              LastOrderUpdateUtcTimestamp = new global::Google.Protobuf.Timestamp();
            }
            input.ReadMessage(LastOrderUpdateUtcTimestamp);
            break;
          }
          case 120: {
            IncludeCrossOrders = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the TradeSubscription message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// Scope of the subscription (provide a list).
      /// </summary>
      public enum SubscriptionScope {
        /// <summary>
        /// Subscribe to order updates.
        /// </summary>
        [pbr::OriginalName("SUBSCRIPTION_SCOPE_ORDERS")] Orders = 1,
        /// <summary>
        /// Subscribe to open positions and matched trades updates.
        /// </summary>
        [pbr::OriginalName("SUBSCRIPTION_SCOPE_POSITIONS")] Positions = 2,
        /// <summary>
        /// Subscribe to collateral updates (current margin and purchasing power).
        /// </summary>
        [pbr::OriginalName("SUBSCRIPTION_SCOPE_COLLATERAL")] Collateral = 3,
      }

      /// <summary>
      /// Type of the publication to subscribe.
      /// </summary>
      public enum PublicationType {
        /// <summary>
        /// Subscribe to a single account.
        /// </summary>
        [pbr::OriginalName("PUBLICATION_TYPE_ACCOUNT")] Account = 1,
        /// <summary>
        /// Subscribe to all accounts of a specific sales series.
        /// </summary>
        [pbr::OriginalName("PUBLICATION_TYPE_SALES_SERIES")] SalesSeries = 2,
        /// <summary>
        /// Subscribe to all accounts of a specific brokerage.
        /// </summary>
        [pbr::OriginalName("PUBLICATION_TYPE_BROKERAGE")] Brokerage = 3,
        /// <summary>
        /// Subscribe to all accounts this user is authorized for (default).
        /// </summary>
        [pbr::OriginalName("PUBLICATION_TYPE_ALL_AUTHORIZED")] AllAuthorized = 4,
      }

      /// <summary>
      /// Positions matching algorithm (for position subscription).
      /// </summary>
      public enum MatchingAlgorithm {
        /// <summary>
        /// First In, First Out. The first order filled is the first order offset when an order on the opposite side of the market is executed.
        /// </summary>
        [pbr::OriginalName("MATCHING_ALGORITHM_FIFO")] Fifo = 1,
        /// <summary>
        /// High Buy, High Sell. The highest buy is matched with the highest sell.
        /// </summary>
        [pbr::OriginalName("MATCHING_ALGORITHM_HBHS")] Hbhs = 2,
        /// <summary>
        /// Last In, First Out. The last order filled is the first order offset when an order on the opposite side of the market is executed.
        /// </summary>
        [pbr::OriginalName("MATCHING_ALGORITHM_LIFO")] Lifo = 3,
      }

    }
    #endregion

  }

  /// <summary>
  /// Server status for a trade subscription.
  /// It is sent before or along with a snapshot of initial status information.
  /// </summary>
  public sealed partial class TradeSubscriptionStatus : pb::IMessage<TradeSubscriptionStatus>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<TradeSubscriptionStatus> _parser = new pb::MessageParser<TradeSubscriptionStatus>(() => new TradeSubscriptionStatus());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<TradeSubscriptionStatus> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::TradeRouting2.TradeRouting2Reflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TradeSubscriptionStatus() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TradeSubscriptionStatus(TradeSubscriptionStatus other) : this() {
      _hasBits0 = other._hasBits0;
      id_ = other.id_;
      statusCode_ = other.statusCode_;
      textMessage_ = other.textMessage_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TradeSubscriptionStatus Clone() {
      return new TradeSubscriptionStatus(this);
    }

    /// <summary>Field number for the "id" field.</summary>
    public const int IdFieldNumber = 1;
    private readonly static uint IdDefaultValue = 0;

    private uint id_;
    /// <summary>
    /// Subscription Id this result is sent for.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint Id {
      get { if ((_hasBits0 & 1) != 0) { return id_; } else { return IdDefaultValue; } }
      set {
        _hasBits0 |= 1;
        id_ = value;
      }
    }
    /// <summary>Gets whether the "id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasId {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearId() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "status_code" field.</summary>
    public const int StatusCodeFieldNumber = 2;
    private readonly static uint StatusCodeDefaultValue = 0;

    private uint statusCode_;
    /// <summary>
    /// Subscription result.
    /// This field is associated with StatusCode enum type.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint StatusCode {
      get { if ((_hasBits0 & 2) != 0) { return statusCode_; } else { return StatusCodeDefaultValue; } }
      set {
        _hasBits0 |= 2;
        statusCode_ = value;
      }
    }
    /// <summary>Gets whether the "status_code" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasStatusCode {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "status_code" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearStatusCode() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "text_message" field.</summary>
    public const int TextMessageFieldNumber = 3;
    private readonly static string TextMessageDefaultValue = "";

    private string textMessage_;
    /// <summary>
    /// Optional details.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string TextMessage {
      get { return textMessage_ ?? TextMessageDefaultValue; }
      set {
        textMessage_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "text_message" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasTextMessage {
      get { return textMessage_ != null; }
    }
    /// <summary>Clears the value of the "text_message" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearTextMessage() {
      textMessage_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as TradeSubscriptionStatus);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(TradeSubscriptionStatus other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Id != other.Id) return false;
      if (StatusCode != other.StatusCode) return false;
      if (TextMessage != other.TextMessage) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasId) hash ^= Id.GetHashCode();
      if (HasStatusCode) hash ^= StatusCode.GetHashCode();
      if (HasTextMessage) hash ^= TextMessage.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasId) {
        output.WriteRawTag(8);
        output.WriteUInt32(Id);
      }
      if (HasStatusCode) {
        output.WriteRawTag(16);
        output.WriteUInt32(StatusCode);
      }
      if (HasTextMessage) {
        output.WriteRawTag(26);
        output.WriteString(TextMessage);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasId) {
        output.WriteRawTag(8);
        output.WriteUInt32(Id);
      }
      if (HasStatusCode) {
        output.WriteRawTag(16);
        output.WriteUInt32(StatusCode);
      }
      if (HasTextMessage) {
        output.WriteRawTag(26);
        output.WriteString(TextMessage);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (HasId) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Id);
      }
      if (HasStatusCode) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(StatusCode);
      }
      if (HasTextMessage) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(TextMessage);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(TradeSubscriptionStatus other) {
      if (other == null) {
        return;
      }
      if (other.HasId) {
        Id = other.Id;
      }
      if (other.HasStatusCode) {
        StatusCode = other.StatusCode;
      }
      if (other.HasTextMessage) {
        TextMessage = other.TextMessage;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Id = input.ReadUInt32();
            break;
          }
          case 16: {
            StatusCode = input.ReadUInt32();
            break;
          }
          case 26: {
            TextMessage = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Id = input.ReadUInt32();
            break;
          }
          case 16: {
            StatusCode = input.ReadUInt32();
            break;
          }
          case 26: {
            TextMessage = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the TradeSubscriptionStatus message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// Possible result codes.
      /// </summary>
      public enum StatusCode {
        /// <summary>
        /// success codes (0 - 99)
        /// </summary>
        [pbr::OriginalName("STATUS_CODE_SUCCESS")] Success = 0,
        /// <summary>
        /// Currently subscription is [partially] disconnect because of communication issues.
        /// NOTE: Clients should not resubscribe in this case, the server will restore subscription with
        /// sending SUCCESS status once communication issues are resolved following with all necessary data updates.
        /// </summary>
        [pbr::OriginalName("STATUS_CODE_DISCONNECTED")] Disconnected = 1,
        /// <summary>
        /// failure codes (100+)
        /// </summary>
        [pbr::OriginalName("STATUS_CODE_FAILURE")] Failure = 101,
        /// <summary>
        /// The limit of the subscriptions has been violated.
        /// </summary>
        [pbr::OriginalName("STATUS_CODE_SUBSCRIPTION_LIMIT_VIOLATION")] SubscriptionLimitViolation = 102,
        /// <summary>
        /// Unknown or ambiguous account, sales series number, or brokerage id in the subscription.
        /// </summary>
        [pbr::OriginalName("STATUS_CODE_INVALID_PUBLICATION_ID")] InvalidPublicationId = 103,
        /// <summary>
        /// The limit of subscribed accounts has been violated.
        /// </summary>
        [pbr::OriginalName("STATUS_CODE_SUBSCRIBED_ACCOUNTS_LIMIT_VIOLATION")] SubscribedAccountsLimitViolation = 104,
      }

    }
    #endregion

  }

  /// <summary>
  /// Indicator that a snapshot of requested information is delivered and corresponding data is complete.
  /// </summary>
  public sealed partial class TradeSnapshotCompletion : pb::IMessage<TradeSnapshotCompletion>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<TradeSnapshotCompletion> _parser = new pb::MessageParser<TradeSnapshotCompletion>(() => new TradeSnapshotCompletion());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<TradeSnapshotCompletion> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::TradeRouting2.TradeRouting2Reflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TradeSnapshotCompletion() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TradeSnapshotCompletion(TradeSnapshotCompletion other) : this() {
      _hasBits0 = other._hasBits0;
      subscriptionId_ = other.subscriptionId_;
      subscriptionScopes_ = other.subscriptionScopes_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TradeSnapshotCompletion Clone() {
      return new TradeSnapshotCompletion(this);
    }

    /// <summary>Field number for the "subscription_id" field.</summary>
    public const int SubscriptionIdFieldNumber = 1;
    private readonly static uint SubscriptionIdDefaultValue = 0;

    private uint subscriptionId_;
    /// <summary>
    /// ID of a corresponding trade subscription.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint SubscriptionId {
      get { if ((_hasBits0 & 1) != 0) { return subscriptionId_; } else { return SubscriptionIdDefaultValue; } }
      set {
        _hasBits0 |= 1;
        subscriptionId_ = value;
      }
    }
    /// <summary>Gets whether the "subscription_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasSubscriptionId {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "subscription_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearSubscriptionId() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "subscription_scopes" field.</summary>
    public const int SubscriptionScopesFieldNumber = 2;
    private static readonly pb::FieldCodec<uint> _repeated_subscriptionScopes_codec
        = pb::FieldCodec.ForUInt32(16);
    private readonly pbc::RepeatedField<uint> subscriptionScopes_ = new pbc::RepeatedField<uint>();
    /// <summary>
    /// List of subscription scopes whose snapshots are completed.
    /// Completion message for one scope is sent only once but they can be combined
    /// (e.g. one completion message might come for ORDERS and another one later for POSITIONS and COLLATERAL).
    /// This field is associated with TradeSubscription.SubscriptionScope enum type.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<uint> SubscriptionScopes {
      get { return subscriptionScopes_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as TradeSnapshotCompletion);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(TradeSnapshotCompletion other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (SubscriptionId != other.SubscriptionId) return false;
      if(!subscriptionScopes_.Equals(other.subscriptionScopes_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasSubscriptionId) hash ^= SubscriptionId.GetHashCode();
      hash ^= subscriptionScopes_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasSubscriptionId) {
        output.WriteRawTag(8);
        output.WriteUInt32(SubscriptionId);
      }
      subscriptionScopes_.WriteTo(output, _repeated_subscriptionScopes_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasSubscriptionId) {
        output.WriteRawTag(8);
        output.WriteUInt32(SubscriptionId);
      }
      subscriptionScopes_.WriteTo(ref output, _repeated_subscriptionScopes_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (HasSubscriptionId) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(SubscriptionId);
      }
      size += subscriptionScopes_.CalculateSize(_repeated_subscriptionScopes_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(TradeSnapshotCompletion other) {
      if (other == null) {
        return;
      }
      if (other.HasSubscriptionId) {
        SubscriptionId = other.SubscriptionId;
      }
      subscriptionScopes_.Add(other.subscriptionScopes_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            SubscriptionId = input.ReadUInt32();
            break;
          }
          case 18:
          case 16: {
            subscriptionScopes_.AddEntriesFrom(input, _repeated_subscriptionScopes_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            SubscriptionId = input.ReadUInt32();
            break;
          }
          case 18:
          case 16: {
            subscriptionScopes_.AddEntriesFrom(ref input, _repeated_subscriptionScopes_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Status of a contract open positions and purchase and sales for a specific account for the current day
  /// (contractId and accountId are used as a key for updates).
  /// Contract position is deleted when all open positions and purchase and sales groups are deleted.
  /// </summary>
  public sealed partial class PositionStatus : pb::IMessage<PositionStatus>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<PositionStatus> _parser = new pb::MessageParser<PositionStatus>(() => new PositionStatus());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<PositionStatus> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::TradeRouting2.TradeRouting2Reflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PositionStatus() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PositionStatus(PositionStatus other) : this() {
      _hasBits0 = other._hasBits0;
      subscriptionIds_ = other.subscriptionIds_.Clone();
      isSnapshot_ = other.isSnapshot_;
      accountId_ = other.accountId_;
      contractId_ = other.contractId_;
      isShortOpenPosition_ = other.isShortOpenPosition_;
      openPositions_ = other.openPositions_.Clone();
      purchaseAndSalesGroups_ = other.purchaseAndSalesGroups_.Clone();
      contractMetadata_ = other.contractMetadata_ != null ? other.contractMetadata_.Clone() : null;
      todayFillCommissions_ = other.todayFillCommissions_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PositionStatus Clone() {
      return new PositionStatus(this);
    }

    /// <summary>Field number for the "subscription_ids" field.</summary>
    public const int SubscriptionIdsFieldNumber = 1;
    private static readonly pb::FieldCodec<uint> _repeated_subscriptionIds_codec
        = pb::FieldCodec.ForUInt32(8);
    private readonly pbc::RepeatedField<uint> subscriptionIds_ = new pbc::RepeatedField<uint>();
    /// <summary>
    /// List of trade subscription IDs this status is related to.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<uint> SubscriptionIds {
      get { return subscriptionIds_; }
    }

    /// <summary>Field number for the "is_snapshot" field.</summary>
    public const int IsSnapshotFieldNumber = 2;
    private readonly static bool IsSnapshotDefaultValue = false;

    private bool isSnapshot_;
    /// <summary>
    /// True if this is a snapshot related message.
    /// Since snapshot might be sent in several messages (including none), client should use TradeSnapshotCompletion message as
    /// an indicator of complete snapshot delivery.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsSnapshot {
      get { if ((_hasBits0 & 1) != 0) { return isSnapshot_; } else { return IsSnapshotDefaultValue; } }
      set {
        _hasBits0 |= 1;
        isSnapshot_ = value;
      }
    }
    /// <summary>Gets whether the "is_snapshot" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasIsSnapshot {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "is_snapshot" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearIsSnapshot() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "account_id" field.</summary>
    public const int AccountIdFieldNumber = 3;
    private readonly static int AccountIdDefaultValue = 0;

    private int accountId_;
    /// <summary>
    /// Account this position belongs to.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int AccountId {
      get { if ((_hasBits0 & 2) != 0) { return accountId_; } else { return AccountIdDefaultValue; } }
      set {
        _hasBits0 |= 2;
        accountId_ = value;
      }
    }
    /// <summary>Gets whether the "account_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasAccountId {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "account_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearAccountId() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "contract_id" field.</summary>
    public const int ContractIdFieldNumber = 4;
    private readonly static uint ContractIdDefaultValue = 0;

    private uint contractId_;
    /// <summary>
    /// Contract ID assigned by server.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint ContractId {
      get { if ((_hasBits0 & 4) != 0) { return contractId_; } else { return ContractIdDefaultValue; } }
      set {
        _hasBits0 |= 4;
        contractId_ = value;
      }
    }
    /// <summary>Gets whether the "contract_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasContractId {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "contract_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearContractId() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "is_short_open_position" field.</summary>
    public const int IsShortOpenPositionFieldNumber = 5;
    private readonly static bool IsShortOpenPositionDefaultValue = false;

    private bool isShortOpenPosition_;
    /// <summary>
    /// True if open positions are short (result of sell operations), long otherwise.
    /// In case of separated long and short positions the value is true if the cumulative position is short,
    /// the value is false if the cumulative position is long or flat.
    /// The attribute is deprecated, refer to OpenPosition.is_short instead.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsShortOpenPosition {
      get { if ((_hasBits0 & 8) != 0) { return isShortOpenPosition_; } else { return IsShortOpenPositionDefaultValue; } }
      set {
        _hasBits0 |= 8;
        isShortOpenPosition_ = value;
      }
    }
    /// <summary>Gets whether the "is_short_open_position" field is set</summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasIsShortOpenPosition {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "is_short_open_position" field</summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearIsShortOpenPosition() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "open_positions" field.</summary>
    public const int OpenPositionsFieldNumber = 6;
    private static readonly pb::FieldCodec<global::TradeRouting2.OpenPosition> _repeated_openPositions_codec
        = pb::FieldCodec.ForMessage(50, global::TradeRouting2.OpenPosition.Parser);
    private readonly pbc::RepeatedField<global::TradeRouting2.OpenPosition> openPositions_ = new pbc::RepeatedField<global::TradeRouting2.OpenPosition>();
    /// <summary>
    /// List of new/ updated or deleted open positions.
    /// NOTE: full list is sent only in a snapshot, updates include only added, changed and deleted records.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::TradeRouting2.OpenPosition> OpenPositions {
      get { return openPositions_; }
    }

    /// <summary>Field number for the "purchase_and_sales_groups" field.</summary>
    public const int PurchaseAndSalesGroupsFieldNumber = 7;
    private static readonly pb::FieldCodec<global::TradeRouting2.PurchaseAndSalesGroup> _repeated_purchaseAndSalesGroups_codec
        = pb::FieldCodec.ForMessage(58, global::TradeRouting2.PurchaseAndSalesGroup.Parser);
    private readonly pbc::RepeatedField<global::TradeRouting2.PurchaseAndSalesGroup> purchaseAndSalesGroups_ = new pbc::RepeatedField<global::TradeRouting2.PurchaseAndSalesGroup>();
    /// <summary>
    /// List of purchase and sales groups. This group represent offset trades (usually one sell and one buy).
    /// NOTE: full list is sent only in a snapshot, updates include only added, changed and deleted records.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::TradeRouting2.PurchaseAndSalesGroup> PurchaseAndSalesGroups {
      get { return purchaseAndSalesGroups_; }
    }

    /// <summary>Field number for the "contract_metadata" field.</summary>
    public const int ContractMetadataFieldNumber = 8;
    private global::Metadata2.ContractMetadata contractMetadata_;
    /// <summary>
    /// Multiple OrderStatus and PositionStatus messages in a single ServerMsg can reference the same contract.
    /// If the contract is unknown to the client before this ServerMsg, contract meta-data will be added in at least one of them.
    /// If in your code you process orders first and positions second then during processing orders you may
    /// encounter order with yet unknown contract_id.
    /// In this case you should look for matching contract metadata in positions.
    /// The opposite is also true: contract metadata for positions can be in order status messages.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Metadata2.ContractMetadata ContractMetadata {
      get { return contractMetadata_; }
      set {
        contractMetadata_ = value;
      }
    }

    /// <summary>Field number for the "today_fill_commissions" field.</summary>
    public const int TodayFillCommissionsFieldNumber = 9;
    private static readonly pb::FieldCodec<global::Order2.Commission> _repeated_todayFillCommissions_codec
        = pb::FieldCodec.ForMessage(74, global::Order2.Commission.Parser);
    private readonly pbc::RepeatedField<global::Order2.Commission> todayFillCommissions_ = new pbc::RepeatedField<global::Order2.Commission>();
    /// <summary>
    /// Sum of today fill commissions per currency for the contract.
    /// Aggregated value from TransactionStatus.fill_commission for current day orders.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Order2.Commission> TodayFillCommissions {
      get { return todayFillCommissions_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as PositionStatus);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(PositionStatus other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!subscriptionIds_.Equals(other.subscriptionIds_)) return false;
      if (IsSnapshot != other.IsSnapshot) return false;
      if (AccountId != other.AccountId) return false;
      if (ContractId != other.ContractId) return false;
      if (IsShortOpenPosition != other.IsShortOpenPosition) return false;
      if(!openPositions_.Equals(other.openPositions_)) return false;
      if(!purchaseAndSalesGroups_.Equals(other.purchaseAndSalesGroups_)) return false;
      if (!object.Equals(ContractMetadata, other.ContractMetadata)) return false;
      if(!todayFillCommissions_.Equals(other.todayFillCommissions_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= subscriptionIds_.GetHashCode();
      if (HasIsSnapshot) hash ^= IsSnapshot.GetHashCode();
      if (HasAccountId) hash ^= AccountId.GetHashCode();
      if (HasContractId) hash ^= ContractId.GetHashCode();
      if (HasIsShortOpenPosition) hash ^= IsShortOpenPosition.GetHashCode();
      hash ^= openPositions_.GetHashCode();
      hash ^= purchaseAndSalesGroups_.GetHashCode();
      if (contractMetadata_ != null) hash ^= ContractMetadata.GetHashCode();
      hash ^= todayFillCommissions_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      subscriptionIds_.WriteTo(output, _repeated_subscriptionIds_codec);
      if (HasIsSnapshot) {
        output.WriteRawTag(16);
        output.WriteBool(IsSnapshot);
      }
      if (HasAccountId) {
        output.WriteRawTag(24);
        output.WriteSInt32(AccountId);
      }
      if (HasContractId) {
        output.WriteRawTag(32);
        output.WriteUInt32(ContractId);
      }
      if (HasIsShortOpenPosition) {
        output.WriteRawTag(40);
        output.WriteBool(IsShortOpenPosition);
      }
      openPositions_.WriteTo(output, _repeated_openPositions_codec);
      purchaseAndSalesGroups_.WriteTo(output, _repeated_purchaseAndSalesGroups_codec);
      if (contractMetadata_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(ContractMetadata);
      }
      todayFillCommissions_.WriteTo(output, _repeated_todayFillCommissions_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      subscriptionIds_.WriteTo(ref output, _repeated_subscriptionIds_codec);
      if (HasIsSnapshot) {
        output.WriteRawTag(16);
        output.WriteBool(IsSnapshot);
      }
      if (HasAccountId) {
        output.WriteRawTag(24);
        output.WriteSInt32(AccountId);
      }
      if (HasContractId) {
        output.WriteRawTag(32);
        output.WriteUInt32(ContractId);
      }
      if (HasIsShortOpenPosition) {
        output.WriteRawTag(40);
        output.WriteBool(IsShortOpenPosition);
      }
      openPositions_.WriteTo(ref output, _repeated_openPositions_codec);
      purchaseAndSalesGroups_.WriteTo(ref output, _repeated_purchaseAndSalesGroups_codec);
      if (contractMetadata_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(ContractMetadata);
      }
      todayFillCommissions_.WriteTo(ref output, _repeated_todayFillCommissions_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += subscriptionIds_.CalculateSize(_repeated_subscriptionIds_codec);
      if (HasIsSnapshot) {
        size += 1 + 1;
      }
      if (HasAccountId) {
        size += 1 + pb::CodedOutputStream.ComputeSInt32Size(AccountId);
      }
      if (HasContractId) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(ContractId);
      }
      if (HasIsShortOpenPosition) {
        size += 1 + 1;
      }
      size += openPositions_.CalculateSize(_repeated_openPositions_codec);
      size += purchaseAndSalesGroups_.CalculateSize(_repeated_purchaseAndSalesGroups_codec);
      if (contractMetadata_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ContractMetadata);
      }
      size += todayFillCommissions_.CalculateSize(_repeated_todayFillCommissions_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(PositionStatus other) {
      if (other == null) {
        return;
      }
      subscriptionIds_.Add(other.subscriptionIds_);
      if (other.HasIsSnapshot) {
        IsSnapshot = other.IsSnapshot;
      }
      if (other.HasAccountId) {
        AccountId = other.AccountId;
      }
      if (other.HasContractId) {
        ContractId = other.ContractId;
      }
      if (other.HasIsShortOpenPosition) {
        IsShortOpenPosition = other.IsShortOpenPosition;
      }
      openPositions_.Add(other.openPositions_);
      purchaseAndSalesGroups_.Add(other.purchaseAndSalesGroups_);
      if (other.contractMetadata_ != null) {
        if (contractMetadata_ == null) {
          ContractMetadata = new global::Metadata2.ContractMetadata();
        }
        ContractMetadata.MergeFrom(other.ContractMetadata);
      }
      todayFillCommissions_.Add(other.todayFillCommissions_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10:
          case 8: {
            subscriptionIds_.AddEntriesFrom(input, _repeated_subscriptionIds_codec);
            break;
          }
          case 16: {
            IsSnapshot = input.ReadBool();
            break;
          }
          case 24: {
            AccountId = input.ReadSInt32();
            break;
          }
          case 32: {
            ContractId = input.ReadUInt32();
            break;
          }
          case 40: {
            IsShortOpenPosition = input.ReadBool();
            break;
          }
          case 50: {
            openPositions_.AddEntriesFrom(input, _repeated_openPositions_codec);
            break;
          }
          case 58: {
            purchaseAndSalesGroups_.AddEntriesFrom(input, _repeated_purchaseAndSalesGroups_codec);
            break;
          }
          case 66: {
            if (contractMetadata_ == null) {
              ContractMetadata = new global::Metadata2.ContractMetadata();
            }
            input.ReadMessage(ContractMetadata);
            break;
          }
          case 74: {
            todayFillCommissions_.AddEntriesFrom(input, _repeated_todayFillCommissions_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10:
          case 8: {
            subscriptionIds_.AddEntriesFrom(ref input, _repeated_subscriptionIds_codec);
            break;
          }
          case 16: {
            IsSnapshot = input.ReadBool();
            break;
          }
          case 24: {
            AccountId = input.ReadSInt32();
            break;
          }
          case 32: {
            ContractId = input.ReadUInt32();
            break;
          }
          case 40: {
            IsShortOpenPosition = input.ReadBool();
            break;
          }
          case 50: {
            openPositions_.AddEntriesFrom(ref input, _repeated_openPositions_codec);
            break;
          }
          case 58: {
            purchaseAndSalesGroups_.AddEntriesFrom(ref input, _repeated_purchaseAndSalesGroups_codec);
            break;
          }
          case 66: {
            if (contractMetadata_ == null) {
              ContractMetadata = new global::Metadata2.ContractMetadata();
            }
            input.ReadMessage(ContractMetadata);
            break;
          }
          case 74: {
            todayFillCommissions_.AddEntriesFrom(ref input, _repeated_todayFillCommissions_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Account and contract open position.
  /// There could be more than one position per account and contract.
  /// (id is used as a key for updates).
  /// </summary>
  public sealed partial class OpenPosition : pb::IMessage<OpenPosition>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<OpenPosition> _parser = new pb::MessageParser<OpenPosition>(() => new OpenPosition());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<OpenPosition> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::TradeRouting2.TradeRouting2Reflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public OpenPosition() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public OpenPosition(OpenPosition other) : this() {
      _hasBits0 = other._hasBits0;
      id_ = other.id_;
      uint32Qty_ = other.uint32Qty_;
      qty_ = other.qty_ != null ? other.qty_.Clone() : null;
      priceCorrect_ = other.priceCorrect_;
      tradeDate_ = other.tradeDate_;
      statementDate_ = other.statementDate_;
      tradeUtcTime_ = other.tradeUtcTime_;
      tradeUtcTimestamp_ = other.tradeUtcTimestamp_ != null ? other.tradeUtcTimestamp_.Clone() : null;
      isAggregated_ = other.isAggregated_;
      isShort_ = other.isShort_;
      isYesterday_ = other.isYesterday_;
      speculationType_ = other.speculationType_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public OpenPosition Clone() {
      return new OpenPosition(this);
    }

    /// <summary>Field number for the "id" field.</summary>
    public const int IdFieldNumber = 1;
    private readonly static int IdDefaultValue = 0;

    private int id_;
    /// <summary>
    /// Surrogate id as a key for updates.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int Id {
      get { if ((_hasBits0 & 1) != 0) { return id_; } else { return IdDefaultValue; } }
      set {
        _hasBits0 |= 1;
        id_ = value;
      }
    }
    /// <summary>Gets whether the "id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasId {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearId() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "uint32_qty" field.</summary>
    public const int Uint32QtyFieldNumber = 2;
    private readonly static uint Uint32QtyDefaultValue = 0;

    private uint uint32Qty_;
    /// <summary>
    /// Note: use qty field instead.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint Uint32Qty {
      get { if ((_hasBits0 & 2) != 0) { return uint32Qty_; } else { return Uint32QtyDefaultValue; } }
      set {
        _hasBits0 |= 2;
        uint32Qty_ = value;
      }
    }
    /// <summary>Gets whether the "uint32_qty" field is set</summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasUint32Qty {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "uint32_qty" field</summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearUint32Qty() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "qty" field.</summary>
    public const int QtyFieldNumber = 12;
    private global::Cqg.Decimal qty_;
    /// <summary>
    /// Position size, zero means that this position is deleted.
    /// Note: quantity can be safely compared to zero, because this is an integral number of
    /// ContractMetadata.volume_scale units.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Cqg.Decimal Qty {
      get { return qty_; }
      set {
        qty_ = value;
      }
    }

    /// <summary>Field number for the "price_correct" field.</summary>
    public const int PriceCorrectFieldNumber = 3;
    private readonly static double PriceCorrectDefaultValue = 0D;

    private double priceCorrect_;
    /// <summary>
    /// Position average price.
    /// NOTE: Since it could be an aggregated position price is sent in correct format directly.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double PriceCorrect {
      get { if ((_hasBits0 & 4) != 0) { return priceCorrect_; } else { return PriceCorrectDefaultValue; } }
      set {
        _hasBits0 |= 4;
        priceCorrect_ = value;
      }
    }
    /// <summary>Gets whether the "price_correct" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasPriceCorrect {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "price_correct" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearPriceCorrect() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "trade_date" field.</summary>
    public const int TradeDateFieldNumber = 4;
    private readonly static long TradeDateDefaultValue = 0L;

    private long tradeDate_;
    /// <summary>
    /// Exchange specific trade date when the position was open or last changed (date only value).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long TradeDate {
      get { if ((_hasBits0 & 8) != 0) { return tradeDate_; } else { return TradeDateDefaultValue; } }
      set {
        _hasBits0 |= 8;
        tradeDate_ = value;
      }
    }
    /// <summary>Gets whether the "trade_date" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasTradeDate {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "trade_date" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearTradeDate() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "statement_date" field.</summary>
    public const int StatementDateFieldNumber = 5;
    private readonly static long StatementDateDefaultValue = 0L;

    private long statementDate_;
    /// <summary>
    /// Statement date (date value only).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long StatementDate {
      get { if ((_hasBits0 & 16) != 0) { return statementDate_; } else { return StatementDateDefaultValue; } }
      set {
        _hasBits0 |= 16;
        statementDate_ = value;
      }
    }
    /// <summary>Gets whether the "statement_date" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasStatementDate {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "statement_date" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearStatementDate() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "trade_utc_time" field.</summary>
    public const int TradeUtcTimeFieldNumber = 6;
    private readonly static long TradeUtcTimeDefaultValue = 0L;

    private long tradeUtcTime_;
    /// <summary>
    /// UTC trade time (including date) if available, it might not be available e.g. for the previous day positions.
    /// Note: use trade_utc_timestamp field instead.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long TradeUtcTime {
      get { if ((_hasBits0 & 32) != 0) { return tradeUtcTime_; } else { return TradeUtcTimeDefaultValue; } }
      set {
        _hasBits0 |= 32;
        tradeUtcTime_ = value;
      }
    }
    /// <summary>Gets whether the "trade_utc_time" field is set</summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasTradeUtcTime {
      get { return (_hasBits0 & 32) != 0; }
    }
    /// <summary>Clears the value of the "trade_utc_time" field</summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearTradeUtcTime() {
      _hasBits0 &= ~32;
    }

    /// <summary>Field number for the "trade_utc_timestamp" field.</summary>
    public const int TradeUtcTimestampFieldNumber = 8;
    private global::Google.Protobuf.Timestamp tradeUtcTimestamp_;
    /// <summary>
    /// UTC trade time (including date) if available, it might not be available e.g. for the previous day positions.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.Timestamp TradeUtcTimestamp {
      get { return tradeUtcTimestamp_; }
      set {
        tradeUtcTimestamp_ = value;
      }
    }

    /// <summary>Field number for the "is_aggregated" field.</summary>
    public const int IsAggregatedFieldNumber = 7;
    private readonly static bool IsAggregatedDefaultValue = false;

    private bool isAggregated_;
    /// <summary>
    /// True if the price is an aggregated position price.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsAggregated {
      get { if ((_hasBits0 & 64) != 0) { return isAggregated_; } else { return IsAggregatedDefaultValue; } }
      set {
        _hasBits0 |= 64;
        isAggregated_ = value;
      }
    }
    /// <summary>Gets whether the "is_aggregated" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasIsAggregated {
      get { return (_hasBits0 & 64) != 0; }
    }
    /// <summary>Clears the value of the "is_aggregated" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearIsAggregated() {
      _hasBits0 &= ~64;
    }

    /// <summary>Field number for the "is_short" field.</summary>
    public const int IsShortFieldNumber = 9;
    private readonly static bool IsShortDefaultValue = false;

    private bool isShort_;
    /// <summary>
    /// True if the open position is short (result of a sell operation), long otherwise.
    /// Undefined for deleted position (qty is 0).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsShort {
      get { if ((_hasBits0 & 128) != 0) { return isShort_; } else { return IsShortDefaultValue; } }
      set {
        _hasBits0 |= 128;
        isShort_ = value;
      }
    }
    /// <summary>Gets whether the "is_short" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasIsShort {
      get { return (_hasBits0 & 128) != 0; }
    }
    /// <summary>Clears the value of the "is_short" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearIsShort() {
      _hasBits0 &= ~128;
    }

    /// <summary>Field number for the "is_yesterday" field.</summary>
    public const int IsYesterdayFieldNumber = 10;
    private readonly static bool IsYesterdayDefaultValue = false;

    private bool isYesterday_;
    /// <summary>
    /// Whether it is a yesterday or a today position.
    /// NOTE: where available, this attribute is from the exchange trade date perspective. It is used for
    /// position tracking and open/close instructions. It is not the same as previous day (associated
    /// with brokerage statement) vs. intraday. It is also not static. For example, an intraday fill
    /// with open_close_effect=OPEN will appear, when it is received during the trading session, in an open
    /// position or matched trade with is_yesterday=false. After the exchange trade date rolls over for
    /// that contract, and before the brokerage statement arrives reflecting it as a previous day position,
    /// the same open position or matched trade will contain is_yesterday=true.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsYesterday {
      get { if ((_hasBits0 & 256) != 0) { return isYesterday_; } else { return IsYesterdayDefaultValue; } }
      set {
        _hasBits0 |= 256;
        isYesterday_ = value;
      }
    }
    /// <summary>Gets whether the "is_yesterday" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasIsYesterday {
      get { return (_hasBits0 & 256) != 0; }
    }
    /// <summary>Clears the value of the "is_yesterday" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearIsYesterday() {
      _hasBits0 &= ~256;
    }

    /// <summary>Field number for the "speculation_type" field.</summary>
    public const int SpeculationTypeFieldNumber = 11;
    private readonly static uint SpeculationTypeDefaultValue = 0;

    private uint speculationType_;
    /// <summary>
    /// Speculation type of the position. One of SpeculationType enum.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint SpeculationType {
      get { if ((_hasBits0 & 512) != 0) { return speculationType_; } else { return SpeculationTypeDefaultValue; } }
      set {
        _hasBits0 |= 512;
        speculationType_ = value;
      }
    }
    /// <summary>Gets whether the "speculation_type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasSpeculationType {
      get { return (_hasBits0 & 512) != 0; }
    }
    /// <summary>Clears the value of the "speculation_type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearSpeculationType() {
      _hasBits0 &= ~512;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as OpenPosition);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(OpenPosition other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Id != other.Id) return false;
      if (Uint32Qty != other.Uint32Qty) return false;
      if (!object.Equals(Qty, other.Qty)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(PriceCorrect, other.PriceCorrect)) return false;
      if (TradeDate != other.TradeDate) return false;
      if (StatementDate != other.StatementDate) return false;
      if (TradeUtcTime != other.TradeUtcTime) return false;
      if (!object.Equals(TradeUtcTimestamp, other.TradeUtcTimestamp)) return false;
      if (IsAggregated != other.IsAggregated) return false;
      if (IsShort != other.IsShort) return false;
      if (IsYesterday != other.IsYesterday) return false;
      if (SpeculationType != other.SpeculationType) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasId) hash ^= Id.GetHashCode();
      if (HasUint32Qty) hash ^= Uint32Qty.GetHashCode();
      if (qty_ != null) hash ^= Qty.GetHashCode();
      if (HasPriceCorrect) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(PriceCorrect);
      if (HasTradeDate) hash ^= TradeDate.GetHashCode();
      if (HasStatementDate) hash ^= StatementDate.GetHashCode();
      if (HasTradeUtcTime) hash ^= TradeUtcTime.GetHashCode();
      if (tradeUtcTimestamp_ != null) hash ^= TradeUtcTimestamp.GetHashCode();
      if (HasIsAggregated) hash ^= IsAggregated.GetHashCode();
      if (HasIsShort) hash ^= IsShort.GetHashCode();
      if (HasIsYesterday) hash ^= IsYesterday.GetHashCode();
      if (HasSpeculationType) hash ^= SpeculationType.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasId) {
        output.WriteRawTag(8);
        output.WriteSInt32(Id);
      }
      if (HasUint32Qty) {
        output.WriteRawTag(16);
        output.WriteUInt32(Uint32Qty);
      }
      if (HasPriceCorrect) {
        output.WriteRawTag(25);
        output.WriteDouble(PriceCorrect);
      }
      if (HasTradeDate) {
        output.WriteRawTag(32);
        output.WriteSInt64(TradeDate);
      }
      if (HasStatementDate) {
        output.WriteRawTag(40);
        output.WriteSInt64(StatementDate);
      }
      if (HasTradeUtcTime) {
        output.WriteRawTag(48);
        output.WriteSInt64(TradeUtcTime);
      }
      if (HasIsAggregated) {
        output.WriteRawTag(56);
        output.WriteBool(IsAggregated);
      }
      if (tradeUtcTimestamp_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(TradeUtcTimestamp);
      }
      if (HasIsShort) {
        output.WriteRawTag(72);
        output.WriteBool(IsShort);
      }
      if (HasIsYesterday) {
        output.WriteRawTag(80);
        output.WriteBool(IsYesterday);
      }
      if (HasSpeculationType) {
        output.WriteRawTag(88);
        output.WriteUInt32(SpeculationType);
      }
      if (qty_ != null) {
        output.WriteRawTag(98);
        output.WriteMessage(Qty);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasId) {
        output.WriteRawTag(8);
        output.WriteSInt32(Id);
      }
      if (HasUint32Qty) {
        output.WriteRawTag(16);
        output.WriteUInt32(Uint32Qty);
      }
      if (HasPriceCorrect) {
        output.WriteRawTag(25);
        output.WriteDouble(PriceCorrect);
      }
      if (HasTradeDate) {
        output.WriteRawTag(32);
        output.WriteSInt64(TradeDate);
      }
      if (HasStatementDate) {
        output.WriteRawTag(40);
        output.WriteSInt64(StatementDate);
      }
      if (HasTradeUtcTime) {
        output.WriteRawTag(48);
        output.WriteSInt64(TradeUtcTime);
      }
      if (HasIsAggregated) {
        output.WriteRawTag(56);
        output.WriteBool(IsAggregated);
      }
      if (tradeUtcTimestamp_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(TradeUtcTimestamp);
      }
      if (HasIsShort) {
        output.WriteRawTag(72);
        output.WriteBool(IsShort);
      }
      if (HasIsYesterday) {
        output.WriteRawTag(80);
        output.WriteBool(IsYesterday);
      }
      if (HasSpeculationType) {
        output.WriteRawTag(88);
        output.WriteUInt32(SpeculationType);
      }
      if (qty_ != null) {
        output.WriteRawTag(98);
        output.WriteMessage(Qty);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (HasId) {
        size += 1 + pb::CodedOutputStream.ComputeSInt32Size(Id);
      }
      if (HasUint32Qty) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Uint32Qty);
      }
      if (qty_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Qty);
      }
      if (HasPriceCorrect) {
        size += 1 + 8;
      }
      if (HasTradeDate) {
        size += 1 + pb::CodedOutputStream.ComputeSInt64Size(TradeDate);
      }
      if (HasStatementDate) {
        size += 1 + pb::CodedOutputStream.ComputeSInt64Size(StatementDate);
      }
      if (HasTradeUtcTime) {
        size += 1 + pb::CodedOutputStream.ComputeSInt64Size(TradeUtcTime);
      }
      if (tradeUtcTimestamp_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TradeUtcTimestamp);
      }
      if (HasIsAggregated) {
        size += 1 + 1;
      }
      if (HasIsShort) {
        size += 1 + 1;
      }
      if (HasIsYesterday) {
        size += 1 + 1;
      }
      if (HasSpeculationType) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(SpeculationType);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(OpenPosition other) {
      if (other == null) {
        return;
      }
      if (other.HasId) {
        Id = other.Id;
      }
      if (other.HasUint32Qty) {
        Uint32Qty = other.Uint32Qty;
      }
      if (other.qty_ != null) {
        if (qty_ == null) {
          Qty = new global::Cqg.Decimal();
        }
        Qty.MergeFrom(other.Qty);
      }
      if (other.HasPriceCorrect) {
        PriceCorrect = other.PriceCorrect;
      }
      if (other.HasTradeDate) {
        TradeDate = other.TradeDate;
      }
      if (other.HasStatementDate) {
        StatementDate = other.StatementDate;
      }
      if (other.HasTradeUtcTime) {
        TradeUtcTime = other.TradeUtcTime;
      }
      if (other.tradeUtcTimestamp_ != null) {
        if (tradeUtcTimestamp_ == null) {
          TradeUtcTimestamp = new global::Google.Protobuf.Timestamp();
        }
        TradeUtcTimestamp.MergeFrom(other.TradeUtcTimestamp);
      }
      if (other.HasIsAggregated) {
        IsAggregated = other.IsAggregated;
      }
      if (other.HasIsShort) {
        IsShort = other.IsShort;
      }
      if (other.HasIsYesterday) {
        IsYesterday = other.IsYesterday;
      }
      if (other.HasSpeculationType) {
        SpeculationType = other.SpeculationType;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Id = input.ReadSInt32();
            break;
          }
          case 16: {
            Uint32Qty = input.ReadUInt32();
            break;
          }
          case 25: {
            PriceCorrect = input.ReadDouble();
            break;
          }
          case 32: {
            TradeDate = input.ReadSInt64();
            break;
          }
          case 40: {
            StatementDate = input.ReadSInt64();
            break;
          }
          case 48: {
            TradeUtcTime = input.ReadSInt64();
            break;
          }
          case 56: {
            IsAggregated = input.ReadBool();
            break;
          }
          case 66: {
            if (tradeUtcTimestamp_ == null) {
              TradeUtcTimestamp = new global::Google.Protobuf.Timestamp();
            }
            input.ReadMessage(TradeUtcTimestamp);
            break;
          }
          case 72: {
            IsShort = input.ReadBool();
            break;
          }
          case 80: {
            IsYesterday = input.ReadBool();
            break;
          }
          case 88: {
            SpeculationType = input.ReadUInt32();
            break;
          }
          case 98: {
            if (qty_ == null) {
              Qty = new global::Cqg.Decimal();
            }
            input.ReadMessage(Qty);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Id = input.ReadSInt32();
            break;
          }
          case 16: {
            Uint32Qty = input.ReadUInt32();
            break;
          }
          case 25: {
            PriceCorrect = input.ReadDouble();
            break;
          }
          case 32: {
            TradeDate = input.ReadSInt64();
            break;
          }
          case 40: {
            StatementDate = input.ReadSInt64();
            break;
          }
          case 48: {
            TradeUtcTime = input.ReadSInt64();
            break;
          }
          case 56: {
            IsAggregated = input.ReadBool();
            break;
          }
          case 66: {
            if (tradeUtcTimestamp_ == null) {
              TradeUtcTimestamp = new global::Google.Protobuf.Timestamp();
            }
            input.ReadMessage(TradeUtcTimestamp);
            break;
          }
          case 72: {
            IsShort = input.ReadBool();
            break;
          }
          case 80: {
            IsYesterday = input.ReadBool();
            break;
          }
          case 88: {
            SpeculationType = input.ReadUInt32();
            break;
          }
          case 98: {
            if (qty_ == null) {
              Qty = new global::Cqg.Decimal();
            }
            input.ReadMessage(Qty);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Purchase and sales group that represents offset trades (usually one sell and one buy trade).
  /// </summary>
  public sealed partial class PurchaseAndSalesGroup : pb::IMessage<PurchaseAndSalesGroup>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<PurchaseAndSalesGroup> _parser = new pb::MessageParser<PurchaseAndSalesGroup>(() => new PurchaseAndSalesGroup());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<PurchaseAndSalesGroup> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::TradeRouting2.TradeRouting2Reflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PurchaseAndSalesGroup() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PurchaseAndSalesGroup(PurchaseAndSalesGroup other) : this() {
      _hasBits0 = other._hasBits0;
      id_ = other.id_;
      realizedProfitLoss_ = other.realizedProfitLoss_;
      matchedTrades_ = other.matchedTrades_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PurchaseAndSalesGroup Clone() {
      return new PurchaseAndSalesGroup(this);
    }

    /// <summary>Field number for the "id" field.</summary>
    public const int IdFieldNumber = 1;
    private readonly static int IdDefaultValue = 0;

    private int id_;
    /// <summary>
    /// Surrogate id as a key for updates.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int Id {
      get { if ((_hasBits0 & 1) != 0) { return id_; } else { return IdDefaultValue; } }
      set {
        _hasBits0 |= 1;
        id_ = value;
      }
    }
    /// <summary>Gets whether the "id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasId {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearId() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "realized_profit_loss" field.</summary>
    public const int RealizedProfitLossFieldNumber = 2;
    private readonly static double RealizedProfitLossDefaultValue = 0D;

    private double realizedProfitLoss_;
    /// <summary>
    /// Profit/ loss (in contract currency) of the group.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double RealizedProfitLoss {
      get { if ((_hasBits0 & 2) != 0) { return realizedProfitLoss_; } else { return RealizedProfitLossDefaultValue; } }
      set {
        _hasBits0 |= 2;
        realizedProfitLoss_ = value;
      }
    }
    /// <summary>Gets whether the "realized_profit_loss" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasRealizedProfitLoss {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "realized_profit_loss" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearRealizedProfitLoss() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "matched_trades" field.</summary>
    public const int MatchedTradesFieldNumber = 3;
    private static readonly pb::FieldCodec<global::TradeRouting2.MatchedTrade> _repeated_matchedTrades_codec
        = pb::FieldCodec.ForMessage(26, global::TradeRouting2.MatchedTrade.Parser);
    private readonly pbc::RepeatedField<global::TradeRouting2.MatchedTrade> matchedTrades_ = new pbc::RepeatedField<global::TradeRouting2.MatchedTrade>();
    /// <summary>
    /// List of matched trades in a group.
    /// In case of group updates the whole list is sent.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::TradeRouting2.MatchedTrade> MatchedTrades {
      get { return matchedTrades_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as PurchaseAndSalesGroup);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(PurchaseAndSalesGroup other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Id != other.Id) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(RealizedProfitLoss, other.RealizedProfitLoss)) return false;
      if(!matchedTrades_.Equals(other.matchedTrades_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasId) hash ^= Id.GetHashCode();
      if (HasRealizedProfitLoss) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(RealizedProfitLoss);
      hash ^= matchedTrades_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasId) {
        output.WriteRawTag(8);
        output.WriteSInt32(Id);
      }
      if (HasRealizedProfitLoss) {
        output.WriteRawTag(17);
        output.WriteDouble(RealizedProfitLoss);
      }
      matchedTrades_.WriteTo(output, _repeated_matchedTrades_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasId) {
        output.WriteRawTag(8);
        output.WriteSInt32(Id);
      }
      if (HasRealizedProfitLoss) {
        output.WriteRawTag(17);
        output.WriteDouble(RealizedProfitLoss);
      }
      matchedTrades_.WriteTo(ref output, _repeated_matchedTrades_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (HasId) {
        size += 1 + pb::CodedOutputStream.ComputeSInt32Size(Id);
      }
      if (HasRealizedProfitLoss) {
        size += 1 + 8;
      }
      size += matchedTrades_.CalculateSize(_repeated_matchedTrades_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(PurchaseAndSalesGroup other) {
      if (other == null) {
        return;
      }
      if (other.HasId) {
        Id = other.Id;
      }
      if (other.HasRealizedProfitLoss) {
        RealizedProfitLoss = other.RealizedProfitLoss;
      }
      matchedTrades_.Add(other.matchedTrades_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Id = input.ReadSInt32();
            break;
          }
          case 17: {
            RealizedProfitLoss = input.ReadDouble();
            break;
          }
          case 26: {
            matchedTrades_.AddEntriesFrom(input, _repeated_matchedTrades_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Id = input.ReadSInt32();
            break;
          }
          case 17: {
            RealizedProfitLoss = input.ReadDouble();
            break;
          }
          case 26: {
            matchedTrades_.AddEntriesFrom(ref input, _repeated_matchedTrades_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Specific trade or position that is a part of a purchase and sales group.
  /// (id is used as a key for updates).
  /// </summary>
  public sealed partial class MatchedTrade : pb::IMessage<MatchedTrade>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<MatchedTrade> _parser = new pb::MessageParser<MatchedTrade>(() => new MatchedTrade());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<MatchedTrade> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::TradeRouting2.TradeRouting2Reflection.Descriptor.MessageTypes[6]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public MatchedTrade() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public MatchedTrade(MatchedTrade other) : this() {
      _hasBits0 = other._hasBits0;
      uint32Qty_ = other.uint32Qty_;
      qty_ = other.qty_ != null ? other.qty_.Clone() : null;
      isShort_ = other.isShort_;
      price_ = other.price_;
      tradeDate_ = other.tradeDate_;
      statementDate_ = other.statementDate_;
      tradeUtcTime_ = other.tradeUtcTime_;
      tradeUtcTimestamp_ = other.tradeUtcTimestamp_ != null ? other.tradeUtcTimestamp_.Clone() : null;
      isAggregated_ = other.isAggregated_;
      isYesterday_ = other.isYesterday_;
      isClose_ = other.isClose_;
      speculationType_ = other.speculationType_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public MatchedTrade Clone() {
      return new MatchedTrade(this);
    }

    /// <summary>Field number for the "uint32_qty" field.</summary>
    public const int Uint32QtyFieldNumber = 1;
    private readonly static uint Uint32QtyDefaultValue = 0;

    private uint uint32Qty_;
    /// <summary>
    /// Note: use qty field instead.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint Uint32Qty {
      get { if ((_hasBits0 & 1) != 0) { return uint32Qty_; } else { return Uint32QtyDefaultValue; } }
      set {
        _hasBits0 |= 1;
        uint32Qty_ = value;
      }
    }
    /// <summary>Gets whether the "uint32_qty" field is set</summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasUint32Qty {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "uint32_qty" field</summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearUint32Qty() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "qty" field.</summary>
    public const int QtyFieldNumber = 12;
    private global::Cqg.Decimal qty_;
    /// <summary>
    /// Matched size.
    /// Zero means matched trade is deleted.
    /// Note: quantity can be safely compared to zero, because this is an integral number of
    /// ContractMetadata.volume_scale units.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Cqg.Decimal Qty {
      get { return qty_; }
      set {
        qty_ = value;
      }
    }

    /// <summary>Field number for the "is_short" field.</summary>
    public const int IsShortFieldNumber = 2;
    private readonly static bool IsShortDefaultValue = false;

    private bool isShort_;
    /// <summary>
    /// True if this is a short trade (e.g. result of sell operation), long otherwise.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsShort {
      get { if ((_hasBits0 & 2) != 0) { return isShort_; } else { return IsShortDefaultValue; } }
      set {
        _hasBits0 |= 2;
        isShort_ = value;
      }
    }
    /// <summary>Gets whether the "is_short" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasIsShort {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "is_short" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearIsShort() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "price" field.</summary>
    public const int PriceFieldNumber = 3;
    private readonly static double PriceDefaultValue = 0D;

    private double price_;
    /// <summary>
    /// Trade or position average price.
    /// NOTE: Since it could be an aggregated position price is sent in correct format directly.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double Price {
      get { if ((_hasBits0 & 4) != 0) { return price_; } else { return PriceDefaultValue; } }
      set {
        _hasBits0 |= 4;
        price_ = value;
      }
    }
    /// <summary>Gets whether the "price" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasPrice {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "price" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearPrice() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "trade_date" field.</summary>
    public const int TradeDateFieldNumber = 4;
    private readonly static long TradeDateDefaultValue = 0L;

    private long tradeDate_;
    /// <summary>
    /// Trade date (date value only).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long TradeDate {
      get { if ((_hasBits0 & 8) != 0) { return tradeDate_; } else { return TradeDateDefaultValue; } }
      set {
        _hasBits0 |= 8;
        tradeDate_ = value;
      }
    }
    /// <summary>Gets whether the "trade_date" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasTradeDate {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "trade_date" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearTradeDate() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "statement_date" field.</summary>
    public const int StatementDateFieldNumber = 5;
    private readonly static long StatementDateDefaultValue = 0L;

    private long statementDate_;
    /// <summary>
    /// Statement date (date value only).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long StatementDate {
      get { if ((_hasBits0 & 16) != 0) { return statementDate_; } else { return StatementDateDefaultValue; } }
      set {
        _hasBits0 |= 16;
        statementDate_ = value;
      }
    }
    /// <summary>Gets whether the "statement_date" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasStatementDate {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "statement_date" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearStatementDate() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "trade_utc_time" field.</summary>
    public const int TradeUtcTimeFieldNumber = 6;
    private readonly static long TradeUtcTimeDefaultValue = 0L;

    private long tradeUtcTime_;
    /// <summary>
    /// UTC trade time (including date) if available, it might not be available e.g. for the previous day positions.
    /// Note: use trade_utc_timestamp field instead.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long TradeUtcTime {
      get { if ((_hasBits0 & 32) != 0) { return tradeUtcTime_; } else { return TradeUtcTimeDefaultValue; } }
      set {
        _hasBits0 |= 32;
        tradeUtcTime_ = value;
      }
    }
    /// <summary>Gets whether the "trade_utc_time" field is set</summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasTradeUtcTime {
      get { return (_hasBits0 & 32) != 0; }
    }
    /// <summary>Clears the value of the "trade_utc_time" field</summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearTradeUtcTime() {
      _hasBits0 &= ~32;
    }

    /// <summary>Field number for the "trade_utc_timestamp" field.</summary>
    public const int TradeUtcTimestampFieldNumber = 8;
    private global::Google.Protobuf.Timestamp tradeUtcTimestamp_;
    /// <summary>
    /// UTC trade time (including date) if available, it might not be available e.g. for the previous day positions.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.Timestamp TradeUtcTimestamp {
      get { return tradeUtcTimestamp_; }
      set {
        tradeUtcTimestamp_ = value;
      }
    }

    /// <summary>Field number for the "is_aggregated" field.</summary>
    public const int IsAggregatedFieldNumber = 7;
    private readonly static bool IsAggregatedDefaultValue = false;

    private bool isAggregated_;
    /// <summary>
    /// True if the price is an aggregated position price.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsAggregated {
      get { if ((_hasBits0 & 64) != 0) { return isAggregated_; } else { return IsAggregatedDefaultValue; } }
      set {
        _hasBits0 |= 64;
        isAggregated_ = value;
      }
    }
    /// <summary>Gets whether the "is_aggregated" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasIsAggregated {
      get { return (_hasBits0 & 64) != 0; }
    }
    /// <summary>Clears the value of the "is_aggregated" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearIsAggregated() {
      _hasBits0 &= ~64;
    }

    /// <summary>Field number for the "is_yesterday" field.</summary>
    public const int IsYesterdayFieldNumber = 9;
    private readonly static bool IsYesterdayDefaultValue = false;

    private bool isYesterday_;
    /// <summary>
    /// Whether the trade is of a yesterday or a today position.
    /// NOTE: where available, this attribute is from the exchange trade date perspective. It is used for
    /// position tracking and open/close instructions. It is not the same as previous day (associated
    /// with brokerage statement) vs. intraday. It is also not static. For example, an intraday fill
    /// with open_close_effect=OPEN will appear, when it is received during the trading session, in an open
    /// position or matched trade with is_yesterday=false. After the exchange trade date rolls over for
    /// that contract, and before the brokerage statement arrives reflecting it as a previous day position,
    /// the same open position or matched trade will contain is_yesterday=true.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsYesterday {
      get { if ((_hasBits0 & 128) != 0) { return isYesterday_; } else { return IsYesterdayDefaultValue; } }
      set {
        _hasBits0 |= 128;
        isYesterday_ = value;
      }
    }
    /// <summary>Gets whether the "is_yesterday" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasIsYesterday {
      get { return (_hasBits0 & 128) != 0; }
    }
    /// <summary>Clears the value of the "is_yesterday" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearIsYesterday() {
      _hasBits0 &= ~128;
    }

    /// <summary>Field number for the "is_close" field.</summary>
    public const int IsCloseFieldNumber = 10;
    private readonly static bool IsCloseDefaultValue = false;

    private bool isClose_;
    /// <summary>
    /// Whether the trade closed a new position or opened a new one.
    /// Applicable only if ContractMetadata.position_tracking is not POSITION_TRACKING_TYPE_NET_POSITION.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsClose {
      get { if ((_hasBits0 & 256) != 0) { return isClose_; } else { return IsCloseDefaultValue; } }
      set {
        _hasBits0 |= 256;
        isClose_ = value;
      }
    }
    /// <summary>Gets whether the "is_close" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasIsClose {
      get { return (_hasBits0 & 256) != 0; }
    }
    /// <summary>Clears the value of the "is_close" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearIsClose() {
      _hasBits0 &= ~256;
    }

    /// <summary>Field number for the "speculation_type" field.</summary>
    public const int SpeculationTypeFieldNumber = 11;
    private readonly static uint SpeculationTypeDefaultValue = 0;

    private uint speculationType_;
    /// <summary>
    /// Speculation type of the trade. One of SpeculationType enum.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint SpeculationType {
      get { if ((_hasBits0 & 512) != 0) { return speculationType_; } else { return SpeculationTypeDefaultValue; } }
      set {
        _hasBits0 |= 512;
        speculationType_ = value;
      }
    }
    /// <summary>Gets whether the "speculation_type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasSpeculationType {
      get { return (_hasBits0 & 512) != 0; }
    }
    /// <summary>Clears the value of the "speculation_type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearSpeculationType() {
      _hasBits0 &= ~512;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as MatchedTrade);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(MatchedTrade other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Uint32Qty != other.Uint32Qty) return false;
      if (!object.Equals(Qty, other.Qty)) return false;
      if (IsShort != other.IsShort) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(Price, other.Price)) return false;
      if (TradeDate != other.TradeDate) return false;
      if (StatementDate != other.StatementDate) return false;
      if (TradeUtcTime != other.TradeUtcTime) return false;
      if (!object.Equals(TradeUtcTimestamp, other.TradeUtcTimestamp)) return false;
      if (IsAggregated != other.IsAggregated) return false;
      if (IsYesterday != other.IsYesterday) return false;
      if (IsClose != other.IsClose) return false;
      if (SpeculationType != other.SpeculationType) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasUint32Qty) hash ^= Uint32Qty.GetHashCode();
      if (qty_ != null) hash ^= Qty.GetHashCode();
      if (HasIsShort) hash ^= IsShort.GetHashCode();
      if (HasPrice) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(Price);
      if (HasTradeDate) hash ^= TradeDate.GetHashCode();
      if (HasStatementDate) hash ^= StatementDate.GetHashCode();
      if (HasTradeUtcTime) hash ^= TradeUtcTime.GetHashCode();
      if (tradeUtcTimestamp_ != null) hash ^= TradeUtcTimestamp.GetHashCode();
      if (HasIsAggregated) hash ^= IsAggregated.GetHashCode();
      if (HasIsYesterday) hash ^= IsYesterday.GetHashCode();
      if (HasIsClose) hash ^= IsClose.GetHashCode();
      if (HasSpeculationType) hash ^= SpeculationType.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasUint32Qty) {
        output.WriteRawTag(8);
        output.WriteUInt32(Uint32Qty);
      }
      if (HasIsShort) {
        output.WriteRawTag(16);
        output.WriteBool(IsShort);
      }
      if (HasPrice) {
        output.WriteRawTag(25);
        output.WriteDouble(Price);
      }
      if (HasTradeDate) {
        output.WriteRawTag(32);
        output.WriteSInt64(TradeDate);
      }
      if (HasStatementDate) {
        output.WriteRawTag(40);
        output.WriteSInt64(StatementDate);
      }
      if (HasTradeUtcTime) {
        output.WriteRawTag(48);
        output.WriteSInt64(TradeUtcTime);
      }
      if (HasIsAggregated) {
        output.WriteRawTag(56);
        output.WriteBool(IsAggregated);
      }
      if (tradeUtcTimestamp_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(TradeUtcTimestamp);
      }
      if (HasIsYesterday) {
        output.WriteRawTag(72);
        output.WriteBool(IsYesterday);
      }
      if (HasIsClose) {
        output.WriteRawTag(80);
        output.WriteBool(IsClose);
      }
      if (HasSpeculationType) {
        output.WriteRawTag(88);
        output.WriteUInt32(SpeculationType);
      }
      if (qty_ != null) {
        output.WriteRawTag(98);
        output.WriteMessage(Qty);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasUint32Qty) {
        output.WriteRawTag(8);
        output.WriteUInt32(Uint32Qty);
      }
      if (HasIsShort) {
        output.WriteRawTag(16);
        output.WriteBool(IsShort);
      }
      if (HasPrice) {
        output.WriteRawTag(25);
        output.WriteDouble(Price);
      }
      if (HasTradeDate) {
        output.WriteRawTag(32);
        output.WriteSInt64(TradeDate);
      }
      if (HasStatementDate) {
        output.WriteRawTag(40);
        output.WriteSInt64(StatementDate);
      }
      if (HasTradeUtcTime) {
        output.WriteRawTag(48);
        output.WriteSInt64(TradeUtcTime);
      }
      if (HasIsAggregated) {
        output.WriteRawTag(56);
        output.WriteBool(IsAggregated);
      }
      if (tradeUtcTimestamp_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(TradeUtcTimestamp);
      }
      if (HasIsYesterday) {
        output.WriteRawTag(72);
        output.WriteBool(IsYesterday);
      }
      if (HasIsClose) {
        output.WriteRawTag(80);
        output.WriteBool(IsClose);
      }
      if (HasSpeculationType) {
        output.WriteRawTag(88);
        output.WriteUInt32(SpeculationType);
      }
      if (qty_ != null) {
        output.WriteRawTag(98);
        output.WriteMessage(Qty);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (HasUint32Qty) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Uint32Qty);
      }
      if (qty_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Qty);
      }
      if (HasIsShort) {
        size += 1 + 1;
      }
      if (HasPrice) {
        size += 1 + 8;
      }
      if (HasTradeDate) {
        size += 1 + pb::CodedOutputStream.ComputeSInt64Size(TradeDate);
      }
      if (HasStatementDate) {
        size += 1 + pb::CodedOutputStream.ComputeSInt64Size(StatementDate);
      }
      if (HasTradeUtcTime) {
        size += 1 + pb::CodedOutputStream.ComputeSInt64Size(TradeUtcTime);
      }
      if (tradeUtcTimestamp_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TradeUtcTimestamp);
      }
      if (HasIsAggregated) {
        size += 1 + 1;
      }
      if (HasIsYesterday) {
        size += 1 + 1;
      }
      if (HasIsClose) {
        size += 1 + 1;
      }
      if (HasSpeculationType) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(SpeculationType);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(MatchedTrade other) {
      if (other == null) {
        return;
      }
      if (other.HasUint32Qty) {
        Uint32Qty = other.Uint32Qty;
      }
      if (other.qty_ != null) {
        if (qty_ == null) {
          Qty = new global::Cqg.Decimal();
        }
        Qty.MergeFrom(other.Qty);
      }
      if (other.HasIsShort) {
        IsShort = other.IsShort;
      }
      if (other.HasPrice) {
        Price = other.Price;
      }
      if (other.HasTradeDate) {
        TradeDate = other.TradeDate;
      }
      if (other.HasStatementDate) {
        StatementDate = other.StatementDate;
      }
      if (other.HasTradeUtcTime) {
        TradeUtcTime = other.TradeUtcTime;
      }
      if (other.tradeUtcTimestamp_ != null) {
        if (tradeUtcTimestamp_ == null) {
          TradeUtcTimestamp = new global::Google.Protobuf.Timestamp();
        }
        TradeUtcTimestamp.MergeFrom(other.TradeUtcTimestamp);
      }
      if (other.HasIsAggregated) {
        IsAggregated = other.IsAggregated;
      }
      if (other.HasIsYesterday) {
        IsYesterday = other.IsYesterday;
      }
      if (other.HasIsClose) {
        IsClose = other.IsClose;
      }
      if (other.HasSpeculationType) {
        SpeculationType = other.SpeculationType;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Uint32Qty = input.ReadUInt32();
            break;
          }
          case 16: {
            IsShort = input.ReadBool();
            break;
          }
          case 25: {
            Price = input.ReadDouble();
            break;
          }
          case 32: {
            TradeDate = input.ReadSInt64();
            break;
          }
          case 40: {
            StatementDate = input.ReadSInt64();
            break;
          }
          case 48: {
            TradeUtcTime = input.ReadSInt64();
            break;
          }
          case 56: {
            IsAggregated = input.ReadBool();
            break;
          }
          case 66: {
            if (tradeUtcTimestamp_ == null) {
              TradeUtcTimestamp = new global::Google.Protobuf.Timestamp();
            }
            input.ReadMessage(TradeUtcTimestamp);
            break;
          }
          case 72: {
            IsYesterday = input.ReadBool();
            break;
          }
          case 80: {
            IsClose = input.ReadBool();
            break;
          }
          case 88: {
            SpeculationType = input.ReadUInt32();
            break;
          }
          case 98: {
            if (qty_ == null) {
              Qty = new global::Cqg.Decimal();
            }
            input.ReadMessage(Qty);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Uint32Qty = input.ReadUInt32();
            break;
          }
          case 16: {
            IsShort = input.ReadBool();
            break;
          }
          case 25: {
            Price = input.ReadDouble();
            break;
          }
          case 32: {
            TradeDate = input.ReadSInt64();
            break;
          }
          case 40: {
            StatementDate = input.ReadSInt64();
            break;
          }
          case 48: {
            TradeUtcTime = input.ReadSInt64();
            break;
          }
          case 56: {
            IsAggregated = input.ReadBool();
            break;
          }
          case 66: {
            if (tradeUtcTimestamp_ == null) {
              TradeUtcTimestamp = new global::Google.Protobuf.Timestamp();
            }
            input.ReadMessage(TradeUtcTimestamp);
            break;
          }
          case 72: {
            IsYesterday = input.ReadBool();
            break;
          }
          case 80: {
            IsClose = input.ReadBool();
            break;
          }
          case 88: {
            SpeculationType = input.ReadUInt32();
            break;
          }
          case 98: {
            if (qty_ == null) {
              Qty = new global::Cqg.Decimal();
            }
            input.ReadMessage(Qty);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Status of the collateral for a specific account.
  /// An update is sent once it is changed, updates might be consolidated in case of frequent changes.
  /// </summary>
  public sealed partial class CollateralStatus : pb::IMessage<CollateralStatus>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<CollateralStatus> _parser = new pb::MessageParser<CollateralStatus>(() => new CollateralStatus());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<CollateralStatus> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::TradeRouting2.TradeRouting2Reflection.Descriptor.MessageTypes[7]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CollateralStatus() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CollateralStatus(CollateralStatus other) : this() {
      _hasBits0 = other._hasBits0;
      subscriptionIds_ = other.subscriptionIds_.Clone();
      isSnapshot_ = other.isSnapshot_;
      accountId_ = other.accountId_;
      currency_ = other.currency_;
      totalMargin_ = other.totalMargin_;
      positionMargin_ = other.positionMargin_;
      purchasingPower_ = other.purchasingPower_;
      ote_ = other.ote_;
      mvo_ = other.mvo_;
      mvf_ = other.mvf_;
      marginCredit_ = other.marginCredit_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CollateralStatus Clone() {
      return new CollateralStatus(this);
    }

    /// <summary>Field number for the "subscription_ids" field.</summary>
    public const int SubscriptionIdsFieldNumber = 1;
    private static readonly pb::FieldCodec<uint> _repeated_subscriptionIds_codec
        = pb::FieldCodec.ForUInt32(8);
    private readonly pbc::RepeatedField<uint> subscriptionIds_ = new pbc::RepeatedField<uint>();
    /// <summary>
    /// List of trade subscription IDs this status is related to.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<uint> SubscriptionIds {
      get { return subscriptionIds_; }
    }

    /// <summary>Field number for the "is_snapshot" field.</summary>
    public const int IsSnapshotFieldNumber = 2;
    private readonly static bool IsSnapshotDefaultValue = false;

    private bool isSnapshot_;
    /// <summary>
    /// True if this is a snapshot related message.
    /// Since snapshot might be sent in several messages (including none), client should use TradeSnapshotCompletion message as
    /// an indicator of complete snapshot delivery for a particular subscription.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsSnapshot {
      get { if ((_hasBits0 & 1) != 0) { return isSnapshot_; } else { return IsSnapshotDefaultValue; } }
      set {
        _hasBits0 |= 1;
        isSnapshot_ = value;
      }
    }
    /// <summary>Gets whether the "is_snapshot" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasIsSnapshot {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "is_snapshot" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearIsSnapshot() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "account_id" field.</summary>
    public const int AccountIdFieldNumber = 3;
    private readonly static int AccountIdDefaultValue = 0;

    private int accountId_;
    /// <summary>
    /// Account id of this status.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int AccountId {
      get { if ((_hasBits0 & 2) != 0) { return accountId_; } else { return AccountIdDefaultValue; } }
      set {
        _hasBits0 |= 2;
        accountId_ = value;
      }
    }
    /// <summary>Gets whether the "account_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasAccountId {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "account_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearAccountId() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "currency" field.</summary>
    public const int CurrencyFieldNumber = 4;
    private readonly static string CurrencyDefaultValue = "";

    private string currency_;
    /// <summary>
    /// Currency code of margin and PP values (ISO 4217 based).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Currency {
      get { return currency_ ?? CurrencyDefaultValue; }
      set {
        currency_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "currency" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasCurrency {
      get { return currency_ != null; }
    }
    /// <summary>Clears the value of the "currency" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearCurrency() {
      currency_ = null;
    }

    /// <summary>Field number for the "total_margin" field.</summary>
    public const int TotalMarginFieldNumber = 5;
    private readonly static double TotalMarginDefaultValue = 0D;

    private double totalMargin_;
    /// <summary>
    /// Margin requirement calculated for worst-case based on open positions and working orders.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double TotalMargin {
      get { if ((_hasBits0 & 4) != 0) { return totalMargin_; } else { return TotalMarginDefaultValue; } }
      set {
        _hasBits0 |= 4;
        totalMargin_ = value;
      }
    }
    /// <summary>Gets whether the "total_margin" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasTotalMargin {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "total_margin" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearTotalMargin() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "position_margin" field.</summary>
    public const int PositionMarginFieldNumber = 11;
    private readonly static double PositionMarginDefaultValue = 0D;

    private double positionMargin_;
    /// <summary>
    /// Margin requirement based on current positions only.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double PositionMargin {
      get { if ((_hasBits0 & 256) != 0) { return positionMargin_; } else { return PositionMarginDefaultValue; } }
      set {
        _hasBits0 |= 256;
        positionMargin_ = value;
      }
    }
    /// <summary>Gets whether the "position_margin" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasPositionMargin {
      get { return (_hasBits0 & 256) != 0; }
    }
    /// <summary>Clears the value of the "position_margin" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearPositionMargin() {
      _hasBits0 &= ~256;
    }

    /// <summary>Field number for the "purchasing_power" field.</summary>
    public const int PurchasingPowerFieldNumber = 6;
    private readonly static double PurchasingPowerDefaultValue = 0D;

    private double purchasingPower_;
    /// <summary>
    /// Available account funds including balance, realized profit (or loss), collateral and credits.
    /// OTE and MVO are included regarding the account risk parameters.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double PurchasingPower {
      get { if ((_hasBits0 & 8) != 0) { return purchasingPower_; } else { return PurchasingPowerDefaultValue; } }
      set {
        _hasBits0 |= 8;
        purchasingPower_ = value;
      }
    }
    /// <summary>Gets whether the "purchasing_power" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasPurchasingPower {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "purchasing_power" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearPurchasingPower() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "ote" field.</summary>
    public const int OteFieldNumber = 7;
    private readonly static double OteDefaultValue = 0D;

    private double ote_;
    /// <summary>
    /// Open trade equity, or potential profit (or loss) from futures and future-style options positions
    /// based on opening price of the position and the current future trade/best bid/best ask
    /// (regarding to the risk account settings) or settlement price if trade is not available.
    /// Included if purchasing power depends on it.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double Ote {
      get { if ((_hasBits0 & 16) != 0) { return ote_; } else { return OteDefaultValue; } }
      set {
        _hasBits0 |= 16;
        ote_ = value;
      }
    }
    /// <summary>Gets whether the "ote" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasOte {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "ote" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearOte() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "mvo" field.</summary>
    public const int MvoFieldNumber = 8;
    private readonly static double MvoDefaultValue = 0D;

    private double mvo_;
    /// <summary>
    /// Market value of options calculated as the current market trade/best bid/best ask of the option
    /// (regarding to the risk account settings) times the number of options
    /// (positive for long options and negative for short options) in the portfolio.
    /// Included if purchasing power depends on it.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double Mvo {
      get { if ((_hasBits0 & 32) != 0) { return mvo_; } else { return MvoDefaultValue; } }
      set {
        _hasBits0 |= 32;
        mvo_ = value;
      }
    }
    /// <summary>Gets whether the "mvo" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasMvo {
      get { return (_hasBits0 & 32) != 0; }
    }
    /// <summary>Clears the value of the "mvo" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearMvo() {
      _hasBits0 &= ~32;
    }

    /// <summary>Field number for the "mvf" field.</summary>
    public const int MvfFieldNumber = 10;
    private readonly static double MvfDefaultValue = 0D;

    private double mvf_;
    /// <summary>
    /// Market value of futures calculated as the current market trade/best bid/best ask
    /// (regarding to the risk account settings) times the number of futures
    /// (positive for long and negative for short) in the portfolio.
    /// Included if applicable.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double Mvf {
      get { if ((_hasBits0 & 128) != 0) { return mvf_; } else { return MvfDefaultValue; } }
      set {
        _hasBits0 |= 128;
        mvf_ = value;
      }
    }
    /// <summary>Gets whether the "mvf" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasMvf {
      get { return (_hasBits0 & 128) != 0; }
    }
    /// <summary>Clears the value of the "mvf" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearMvf() {
      _hasBits0 &= ~128;
    }

    /// <summary>Field number for the "margin_credit" field.</summary>
    public const int MarginCreditFieldNumber = 9;
    private readonly static double MarginCreditDefaultValue = 0D;

    private double marginCredit_;
    /// <summary>
    /// Allowable margin credit of the account.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double MarginCredit {
      get { if ((_hasBits0 & 64) != 0) { return marginCredit_; } else { return MarginCreditDefaultValue; } }
      set {
        _hasBits0 |= 64;
        marginCredit_ = value;
      }
    }
    /// <summary>Gets whether the "margin_credit" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasMarginCredit {
      get { return (_hasBits0 & 64) != 0; }
    }
    /// <summary>Clears the value of the "margin_credit" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearMarginCredit() {
      _hasBits0 &= ~64;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as CollateralStatus);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(CollateralStatus other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!subscriptionIds_.Equals(other.subscriptionIds_)) return false;
      if (IsSnapshot != other.IsSnapshot) return false;
      if (AccountId != other.AccountId) return false;
      if (Currency != other.Currency) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(TotalMargin, other.TotalMargin)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(PositionMargin, other.PositionMargin)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(PurchasingPower, other.PurchasingPower)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(Ote, other.Ote)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(Mvo, other.Mvo)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(Mvf, other.Mvf)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(MarginCredit, other.MarginCredit)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= subscriptionIds_.GetHashCode();
      if (HasIsSnapshot) hash ^= IsSnapshot.GetHashCode();
      if (HasAccountId) hash ^= AccountId.GetHashCode();
      if (HasCurrency) hash ^= Currency.GetHashCode();
      if (HasTotalMargin) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(TotalMargin);
      if (HasPositionMargin) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(PositionMargin);
      if (HasPurchasingPower) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(PurchasingPower);
      if (HasOte) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(Ote);
      if (HasMvo) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(Mvo);
      if (HasMvf) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(Mvf);
      if (HasMarginCredit) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(MarginCredit);
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      subscriptionIds_.WriteTo(output, _repeated_subscriptionIds_codec);
      if (HasIsSnapshot) {
        output.WriteRawTag(16);
        output.WriteBool(IsSnapshot);
      }
      if (HasAccountId) {
        output.WriteRawTag(24);
        output.WriteSInt32(AccountId);
      }
      if (HasCurrency) {
        output.WriteRawTag(34);
        output.WriteString(Currency);
      }
      if (HasTotalMargin) {
        output.WriteRawTag(41);
        output.WriteDouble(TotalMargin);
      }
      if (HasPurchasingPower) {
        output.WriteRawTag(49);
        output.WriteDouble(PurchasingPower);
      }
      if (HasOte) {
        output.WriteRawTag(57);
        output.WriteDouble(Ote);
      }
      if (HasMvo) {
        output.WriteRawTag(65);
        output.WriteDouble(Mvo);
      }
      if (HasMarginCredit) {
        output.WriteRawTag(73);
        output.WriteDouble(MarginCredit);
      }
      if (HasMvf) {
        output.WriteRawTag(81);
        output.WriteDouble(Mvf);
      }
      if (HasPositionMargin) {
        output.WriteRawTag(89);
        output.WriteDouble(PositionMargin);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      subscriptionIds_.WriteTo(ref output, _repeated_subscriptionIds_codec);
      if (HasIsSnapshot) {
        output.WriteRawTag(16);
        output.WriteBool(IsSnapshot);
      }
      if (HasAccountId) {
        output.WriteRawTag(24);
        output.WriteSInt32(AccountId);
      }
      if (HasCurrency) {
        output.WriteRawTag(34);
        output.WriteString(Currency);
      }
      if (HasTotalMargin) {
        output.WriteRawTag(41);
        output.WriteDouble(TotalMargin);
      }
      if (HasPurchasingPower) {
        output.WriteRawTag(49);
        output.WriteDouble(PurchasingPower);
      }
      if (HasOte) {
        output.WriteRawTag(57);
        output.WriteDouble(Ote);
      }
      if (HasMvo) {
        output.WriteRawTag(65);
        output.WriteDouble(Mvo);
      }
      if (HasMarginCredit) {
        output.WriteRawTag(73);
        output.WriteDouble(MarginCredit);
      }
      if (HasMvf) {
        output.WriteRawTag(81);
        output.WriteDouble(Mvf);
      }
      if (HasPositionMargin) {
        output.WriteRawTag(89);
        output.WriteDouble(PositionMargin);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += subscriptionIds_.CalculateSize(_repeated_subscriptionIds_codec);
      if (HasIsSnapshot) {
        size += 1 + 1;
      }
      if (HasAccountId) {
        size += 1 + pb::CodedOutputStream.ComputeSInt32Size(AccountId);
      }
      if (HasCurrency) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Currency);
      }
      if (HasTotalMargin) {
        size += 1 + 8;
      }
      if (HasPositionMargin) {
        size += 1 + 8;
      }
      if (HasPurchasingPower) {
        size += 1 + 8;
      }
      if (HasOte) {
        size += 1 + 8;
      }
      if (HasMvo) {
        size += 1 + 8;
      }
      if (HasMvf) {
        size += 1 + 8;
      }
      if (HasMarginCredit) {
        size += 1 + 8;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(CollateralStatus other) {
      if (other == null) {
        return;
      }
      subscriptionIds_.Add(other.subscriptionIds_);
      if (other.HasIsSnapshot) {
        IsSnapshot = other.IsSnapshot;
      }
      if (other.HasAccountId) {
        AccountId = other.AccountId;
      }
      if (other.HasCurrency) {
        Currency = other.Currency;
      }
      if (other.HasTotalMargin) {
        TotalMargin = other.TotalMargin;
      }
      if (other.HasPositionMargin) {
        PositionMargin = other.PositionMargin;
      }
      if (other.HasPurchasingPower) {
        PurchasingPower = other.PurchasingPower;
      }
      if (other.HasOte) {
        Ote = other.Ote;
      }
      if (other.HasMvo) {
        Mvo = other.Mvo;
      }
      if (other.HasMvf) {
        Mvf = other.Mvf;
      }
      if (other.HasMarginCredit) {
        MarginCredit = other.MarginCredit;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10:
          case 8: {
            subscriptionIds_.AddEntriesFrom(input, _repeated_subscriptionIds_codec);
            break;
          }
          case 16: {
            IsSnapshot = input.ReadBool();
            break;
          }
          case 24: {
            AccountId = input.ReadSInt32();
            break;
          }
          case 34: {
            Currency = input.ReadString();
            break;
          }
          case 41: {
            TotalMargin = input.ReadDouble();
            break;
          }
          case 49: {
            PurchasingPower = input.ReadDouble();
            break;
          }
          case 57: {
            Ote = input.ReadDouble();
            break;
          }
          case 65: {
            Mvo = input.ReadDouble();
            break;
          }
          case 73: {
            MarginCredit = input.ReadDouble();
            break;
          }
          case 81: {
            Mvf = input.ReadDouble();
            break;
          }
          case 89: {
            PositionMargin = input.ReadDouble();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10:
          case 8: {
            subscriptionIds_.AddEntriesFrom(ref input, _repeated_subscriptionIds_codec);
            break;
          }
          case 16: {
            IsSnapshot = input.ReadBool();
            break;
          }
          case 24: {
            AccountId = input.ReadSInt32();
            break;
          }
          case 34: {
            Currency = input.ReadString();
            break;
          }
          case 41: {
            TotalMargin = input.ReadDouble();
            break;
          }
          case 49: {
            PurchasingPower = input.ReadDouble();
            break;
          }
          case 57: {
            Ote = input.ReadDouble();
            break;
          }
          case 65: {
            Mvo = input.ReadDouble();
            break;
          }
          case 73: {
            MarginCredit = input.ReadDouble();
            break;
          }
          case 81: {
            Mvf = input.ReadDouble();
            break;
          }
          case 89: {
            PositionMargin = input.ReadDouble();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Historical orders request.
  /// </summary>
  public sealed partial class HistoricalOrdersRequest : pb::IMessage<HistoricalOrdersRequest>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<HistoricalOrdersRequest> _parser = new pb::MessageParser<HistoricalOrdersRequest>(() => new HistoricalOrdersRequest());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<HistoricalOrdersRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::TradeRouting2.TradeRouting2Reflection.Descriptor.MessageTypes[8]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public HistoricalOrdersRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public HistoricalOrdersRequest(HistoricalOrdersRequest other) : this() {
      _hasBits0 = other._hasBits0;
      fromDate_ = other.fromDate_;
      toDate_ = other.toDate_;
      accountIds_ = other.accountIds_.Clone();
      includeCrossOrders_ = other.includeCrossOrders_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public HistoricalOrdersRequest Clone() {
      return new HistoricalOrdersRequest(this);
    }

    /// <summary>Field number for the "from_date" field.</summary>
    public const int FromDateFieldNumber = 1;
    private readonly static long FromDateDefaultValue = 0L;

    private long fromDate_;
    /// <summary>
    /// Only orders from specified business date (inclusively) is to be returned (date only value in time format).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long FromDate {
      get { if ((_hasBits0 & 1) != 0) { return fromDate_; } else { return FromDateDefaultValue; } }
      set {
        _hasBits0 |= 1;
        fromDate_ = value;
      }
    }
    /// <summary>Gets whether the "from_date" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasFromDate {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "from_date" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearFromDate() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "to_date" field.</summary>
    public const int ToDateFieldNumber = 2;
    private readonly static long ToDateDefaultValue = 0L;

    private long toDate_;
    /// <summary>
    /// Only orders till specified business date (inclusively) is to be returned (date only value in time format).
    /// Current business day if the field is omitted.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long ToDate {
      get { if ((_hasBits0 & 2) != 0) { return toDate_; } else { return ToDateDefaultValue; } }
      set {
        _hasBits0 |= 2;
        toDate_ = value;
      }
    }
    /// <summary>Gets whether the "to_date" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasToDate {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "to_date" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearToDate() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "account_ids" field.</summary>
    public const int AccountIdsFieldNumber = 3;
    private static readonly pb::FieldCodec<int> _repeated_accountIds_codec
        = pb::FieldCodec.ForSInt32(24);
    private readonly pbc::RepeatedField<int> accountIds_ = new pbc::RepeatedField<int>();
    /// <summary>
    /// Filter orders by account. Not specifying any account means all accounts of the user.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<int> AccountIds {
      get { return accountIds_; }
    }

    /// <summary>Field number for the "include_cross_orders" field.</summary>
    public const int IncludeCrossOrdersFieldNumber = 4;
    private readonly static bool IncludeCrossOrdersDefaultValue = false;

    private bool includeCrossOrders_;
    /// <summary>
    /// If this field set to true, statuses on orders with ORDER_TYPE_CROSS type will be
    /// included into responses. See CrossOrderParameters message.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IncludeCrossOrders {
      get { if ((_hasBits0 & 4) != 0) { return includeCrossOrders_; } else { return IncludeCrossOrdersDefaultValue; } }
      set {
        _hasBits0 |= 4;
        includeCrossOrders_ = value;
      }
    }
    /// <summary>Gets whether the "include_cross_orders" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasIncludeCrossOrders {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "include_cross_orders" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearIncludeCrossOrders() {
      _hasBits0 &= ~4;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as HistoricalOrdersRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(HistoricalOrdersRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (FromDate != other.FromDate) return false;
      if (ToDate != other.ToDate) return false;
      if(!accountIds_.Equals(other.accountIds_)) return false;
      if (IncludeCrossOrders != other.IncludeCrossOrders) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasFromDate) hash ^= FromDate.GetHashCode();
      if (HasToDate) hash ^= ToDate.GetHashCode();
      hash ^= accountIds_.GetHashCode();
      if (HasIncludeCrossOrders) hash ^= IncludeCrossOrders.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasFromDate) {
        output.WriteRawTag(8);
        output.WriteSInt64(FromDate);
      }
      if (HasToDate) {
        output.WriteRawTag(16);
        output.WriteSInt64(ToDate);
      }
      accountIds_.WriteTo(output, _repeated_accountIds_codec);
      if (HasIncludeCrossOrders) {
        output.WriteRawTag(32);
        output.WriteBool(IncludeCrossOrders);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasFromDate) {
        output.WriteRawTag(8);
        output.WriteSInt64(FromDate);
      }
      if (HasToDate) {
        output.WriteRawTag(16);
        output.WriteSInt64(ToDate);
      }
      accountIds_.WriteTo(ref output, _repeated_accountIds_codec);
      if (HasIncludeCrossOrders) {
        output.WriteRawTag(32);
        output.WriteBool(IncludeCrossOrders);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (HasFromDate) {
        size += 1 + pb::CodedOutputStream.ComputeSInt64Size(FromDate);
      }
      if (HasToDate) {
        size += 1 + pb::CodedOutputStream.ComputeSInt64Size(ToDate);
      }
      size += accountIds_.CalculateSize(_repeated_accountIds_codec);
      if (HasIncludeCrossOrders) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(HistoricalOrdersRequest other) {
      if (other == null) {
        return;
      }
      if (other.HasFromDate) {
        FromDate = other.FromDate;
      }
      if (other.HasToDate) {
        ToDate = other.ToDate;
      }
      accountIds_.Add(other.accountIds_);
      if (other.HasIncludeCrossOrders) {
        IncludeCrossOrders = other.IncludeCrossOrders;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            FromDate = input.ReadSInt64();
            break;
          }
          case 16: {
            ToDate = input.ReadSInt64();
            break;
          }
          case 26:
          case 24: {
            accountIds_.AddEntriesFrom(input, _repeated_accountIds_codec);
            break;
          }
          case 32: {
            IncludeCrossOrders = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            FromDate = input.ReadSInt64();
            break;
          }
          case 16: {
            ToDate = input.ReadSInt64();
            break;
          }
          case 26:
          case 24: {
            accountIds_.AddEntriesFrom(ref input, _repeated_accountIds_codec);
            break;
          }
          case 32: {
            IncludeCrossOrders = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Response for historical orders request.
  /// </summary>
  public sealed partial class HistoricalOrdersReport : pb::IMessage<HistoricalOrdersReport>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<HistoricalOrdersReport> _parser = new pb::MessageParser<HistoricalOrdersReport>(() => new HistoricalOrdersReport());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<HistoricalOrdersReport> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::TradeRouting2.TradeRouting2Reflection.Descriptor.MessageTypes[9]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public HistoricalOrdersReport() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public HistoricalOrdersReport(HistoricalOrdersReport other) : this() {
      orderStatuses_ = other.orderStatuses_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public HistoricalOrdersReport Clone() {
      return new HistoricalOrdersReport(this);
    }

    /// <summary>Field number for the "order_statuses" field.</summary>
    public const int OrderStatusesFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Order2.OrderStatus> _repeated_orderStatuses_codec
        = pb::FieldCodec.ForMessage(10, global::Order2.OrderStatus.Parser);
    private readonly pbc::RepeatedField<global::Order2.OrderStatus> orderStatuses_ = new pbc::RepeatedField<global::Order2.OrderStatus>();
    /// <summary>
    /// List of order statuses matching historical order filter.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Order2.OrderStatus> OrderStatuses {
      get { return orderStatuses_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as HistoricalOrdersReport);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(HistoricalOrdersReport other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!orderStatuses_.Equals(other.orderStatuses_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= orderStatuses_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      orderStatuses_.WriteTo(output, _repeated_orderStatuses_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      orderStatuses_.WriteTo(ref output, _repeated_orderStatuses_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += orderStatuses_.CalculateSize(_repeated_orderStatuses_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(HistoricalOrdersReport other) {
      if (other == null) {
        return;
      }
      orderStatuses_.Add(other.orderStatuses_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            orderStatuses_.AddEntriesFrom(input, _repeated_orderStatuses_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            orderStatuses_.AddEntriesFrom(ref input, _repeated_orderStatuses_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code
