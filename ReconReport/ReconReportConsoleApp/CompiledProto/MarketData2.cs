// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: WebAPI/market_data_2.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace MarketData2 {

  /// <summary>Holder for reflection information generated from WebAPI/market_data_2.proto</summary>
  public static partial class MarketData2Reflection {

    #region Descriptor
    /// <summary>File descriptor for WebAPI/market_data_2.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static MarketData2Reflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "ChpXZWJBUEkvbWFya2V0X2RhdGFfMi5wcm90bxINbWFya2V0X2RhdGFfMhoV",
            "Y29tbW9uL3NoYXJlZF8xLnByb3RvGhRjb21tb24vZGVjaW1hbC5wcm90bxoW",
            "Y29tbW9uL3RpbWVzdGFtcC5wcm90byKoBAoWTWFya2V0RGF0YVN1YnNjcmlw",
            "dGlvbhITCgtjb250cmFjdF9pZBgBIAIoDRINCgVsZXZlbBgCIAIoDRIiChpp",
            "bmNsdWRlX3Bhc3RfbWFya2V0X3ZhbHVlcxgDIAEoCBIRCglyZXNlcnZlZDEY",
            "BCABKBISGwoTaW5jbHVkZV9wYXN0X3F1b3RlcxgFIAEoCBIkChxpbmNsdWRl",
            "X2Rpc2NyZXRpb25hcnlfcXVvdGVzGAYgASgIEiUKHWluY2x1ZGVfc2Vzc2lv",
            "bl9tYXJrZXRfdmFsdWVzGAkgASgIEhYKDmluY2x1ZGVfeWllbGRzGAggASgI",
            "Eh0KFWluY2x1ZGVfc291cmNlX3ByaWNlcxgKIAEoCBImCh5pbmNsdWRlX3Jl",
            "cXVlc3RzX2Zvcl9xdW90YXRpb24YCyABKAgSFgoOY29udHJpYnV0b3JfaWQY",
            "ByABKAkiygEKBUxldmVsEg4KCkxFVkVMX05PTkUQABIVChFMRVZFTF9TRVRU",
            "TEVNRU5UUxAFEhcKE0xFVkVMX01BUktFVF9WQUxVRVMQBhIQCgxMRVZFTF9U",
            "UkFERVMQARIUChBMRVZFTF9UUkFERVNfQkJBEAISHAoYTEVWRUxfVFJBREVT",
            "X0JCQV9WT0xVTUVTEAMSGAoUTEVWRUxfVFJBREVTX0JCQV9ET00QBBIhCh1M",
            "RVZFTF9UUkFERVNfQkJBX0RFVEFJTEVEX0RPTRAHKgUIZBCWASLKBQocTWFy",
            "a2V0RGF0YVN1YnNjcmlwdGlvblN0YXR1cxITCgtjb250cmFjdF9pZBgBIAIo",
            "DRITCgtzdGF0dXNfY29kZRgCIAIoDRINCgVsZXZlbBgDIAIoDRIUCgx0ZXh0",
            "X21lc3NhZ2UYBCABKAkSEQoJcmVzZXJ2ZWQxGAUgASgSEhwKFHBhc3RfcXVv",
            "dGVzX2luY2x1ZGVkGAYgASgIEiUKHWRpc2NyZXRpb25hcnlfcXVvdGVzX2lu",
            "Y2x1ZGVkGAcgASgIEiYKHnNlc3Npb25fbWFya2V0X3ZhbHVlc19pbmNsdWRl",
            "ZBgKIAEoCBIXCg95aWVsZHNfaW5jbHVkZWQYCSABKAgSHQoVc291cmNlX3By",
            "aWNlX2luY2x1ZGVkGAsgASgIEicKH3JlcXVlc3RzX2Zvcl9xdW90YXRpb25f",
            "aW5jbHVkZWQYDCABKAgSFgoOY29udHJpYnV0b3JfaWQYCCABKAki2gIKClN0",
            "YXR1c0NvZGUSFwoTU1RBVFVTX0NPREVfU1VDQ0VTUxAAEhwKGFNUQVRVU19D",
            "T0RFX0RJU0NPTk5FQ1RFRBABEhcKE1NUQVRVU19DT0RFX0ZBSUxVUkUQZRIe",
            "ChpTVEFUVVNfQ09ERV9JTlZBTElEX1BBUkFNUxBmEh0KGVNUQVRVU19DT0RF",
            "X0FDQ0VTU19ERU5JRUQQZxIXChNTVEFUVVNfQ09ERV9ERUxFVEVEEGgSLAoo",
            "U1RBVFVTX0NPREVfU1VCU0NSSVBUSU9OX0xJTUlUX1ZJT0xBVElPThBpEiQK",
            "IFNUQVRVU19DT0RFX0NPTlRSSUJVVE9SX1JFUVVJUkVEEGoSMQotU1RBVFVT",
            "X0NPREVfU1VCU0NSSVBUSU9OX1JBVEVfTElNSVRfVklPTEFUSU9OEGsSHQoZ",
            "U1RBVFVTX0NPREVfTk9UX1NVUFBPUlRFRBBuKgUIZBCWASKfAgoSUmVhbFRp",
            "bWVNYXJrZXREYXRhEhMKC2NvbnRyYWN0X2lkGAEgAigNEiQKBnF1b3RlcxgC",
            "IAMoCzIULm1hcmtldF9kYXRhXzIuUXVvdGUSEwoLaXNfc25hcHNob3QYAyAB",
            "KAgSGAoQY29sbGFwc2luZ19sZXZlbBgEIAEoDRIyCg1tYXJrZXRfdmFsdWVz",
            "GAUgAygLMhsubWFya2V0X2RhdGFfMi5NYXJrZXRWYWx1ZXMSMAoMZGV0YWls",
            "ZWRfZG9tGBAgASgLMhoubWFya2V0X2RhdGFfMi5EZXRhaWxlZERPTRIyChZy",
            "ZXF1ZXN0c19mb3JfcXVvdGF0aW9uGAYgAygLMhIubWFya2V0X2RhdGFfMi5S",
            "RlEqBQhkEJYBItQFCgVRdW90ZRIMCgR0eXBlGAEgAigNEhYKDnF1b3RlX3V0",
            "Y190aW1lGAIgASgSEhQKDHNjYWxlZF9wcmljZRgDIAIoERIbChNzY2FsZWRf",
            "c291cmNlX3ByaWNlGAggASgREhMKC3ByaWNlX3lpZWxkGAYgASgBEhUKDXNj",
            "YWxlZF92b2x1bWUYBCABKAQSEgoKaW5kaWNhdG9ycxgFIAMoDRIXCg9zYWxl",
            "c19jb25kaXRpb24YByABKA0ivwEKBFR5cGUSDgoKVFlQRV9UUkFERRAAEhAK",
            "DFRZUEVfQkVTVEJJRBABEhAKDFRZUEVfQkVTVEFTSxACEgwKCFRZUEVfQklE",
            "EAMSDAoIVFlQRV9BU0sQBBITCg9UWVBFX1NFVFRMRU1FTlQQBRIVChFUWVBF",
            "X0JFU1RESVNDUkJJRBAGEhUKEVRZUEVfQkVTVERJU0NSQVNLEAcSEQoNVFlQ",
            "RV9ESVNDUkJJRBAIEhEKDVRZUEVfRElTQ1JBU0sQCSKfAQoJSW5kaWNhdG9y",
            "EhIKDklORElDQVRPUl9PUEVOEAESEgoOSU5ESUNBVE9SX0hJR0gQAhIRCg1J",
            "TkRJQ0FUT1JfTE9XEAMSEwoPSU5ESUNBVE9SX0NMT1NFEAQSEgoOSU5ESUNB",
            "VE9SX1BBU1QQBRIuCipJTkRJQ0FUT1JfRkFMTF9CQUNLX1RPX1RSQURFX09S",
            "X1NFVFRMRU1FTlQQBiK0AQoOU2FsZXNDb25kaXRpb24SFwoTU0FMRVNfQ09O",
            "RElUSU9OX0hJVBABEhgKFFNBTEVTX0NPTkRJVElPTl9UQUtFEAISHgoaU0FM",
            "RVNfQ09ORElUSU9OX1NQUkVBRF9MRUcQAxImCiJTQUxFU19DT05ESVRJT05f",
            "QlVZX1NJREVfQUdHUkVTU09SEAQSJwojU0FMRVNfQ09ORElUSU9OX1NFTExf",
            "U0lERV9BR0dSRVNTT1IQBSKYBAoMTWFya2V0VmFsdWVzEhkKEXNjYWxlZF9v",
            "cGVuX3ByaWNlGAEgASgREhkKEXNjYWxlZF9oaWdoX3ByaWNlGAIgASgREhgK",
            "EHNjYWxlZF9sb3dfcHJpY2UYAyABKBESGgoSc2NhbGVkX2Nsb3NlX3ByaWNl",
            "GAQgASgREiMKG3NjYWxlZF95ZXN0ZXJkYXlfc2V0dGxlbWVudBgFIAEoERIb",
            "ChNzY2FsZWRfdG90YWxfdm9sdW1lGAYgASgEEh4KFnNjYWxlZF95ZXN0ZXJk",
            "YXlfY2xvc2UYByABKBESHgoWc2NhbGVkX2luZGljYXRpdmVfb3BlbhgIIAEo",
            "ERIlCh1zY2FsZWRfaW5kaWNhdGl2ZV9vcGVuX3ZvbHVtZRgPIAEoBBIRCglk",
            "YXlfaW5kZXgYCSACKBESHAoUc2NhbGVkX29wZW5faW50ZXJlc3QYCiABKBIS",
            "EwoLdGlja192b2x1bWUYCyABKA0SGQoRc2NhbGVkX3NldHRsZW1lbnQYDCAB",
            "KBESGwoTc2NhbGVkX21hcmtlcl9wcmljZRgSIAEoERIWCg5jbGVhcmVkX2Zp",
            "ZWxkcxgNIAMoDRISCgp0cmFkZV9kYXRlGA4gAigSEhUKDXNlc3Npb25faW5k",
            "ZXgYESABKA0SMgoNbWFya2V0X3lpZWxkcxgQIAEoCzIbLm1hcmtldF9kYXRh",
            "XzIuTWFya2V0WWllbGRzIooCCgxNYXJrZXRZaWVsZHMSGwoTeWllbGRfb2Zf",
            "b3Blbl9wcmljZRgBIAEoARIbChN5aWVsZF9vZl9oaWdoX3ByaWNlGAIgASgB",
            "EhoKEnlpZWxkX29mX2xvd19wcmljZRgDIAEoARIcChR5aWVsZF9vZl9jbG9z",
            "ZV9wcmljZRgEIAEoARIlCh15aWVsZF9vZl95ZXN0ZXJkYXlfc2V0dGxlbWVu",
            "dBgFIAEoARIgChh5aWVsZF9vZl95ZXN0ZXJkYXlfY2xvc2UYBiABKAESIAoY",
            "eWllbGRfb2ZfaW5kaWNhdGl2ZV9vcGVuGAcgASgBEhsKE3lpZWxkX29mX3Nl",
            "dHRsZW1lbnQYCCABKAEiPAoXQXRUaGVNb25leVN0cmlrZVJlcXVlc3QSIQoZ",
            "b3B0aW9uX21hdHVyaXR5X3N5bWJvbF9pZBgBIAIoCSIoChZBdFRoZU1vbmV5",
            "U3RyaWtlUmVwb3J0Eg4KBnN0cmlrZRgBIAEoESKPAQoLRGV0YWlsZWRET00S",
            "IAoYaXNfZGV0YWlsZWRfZG9tX2NvbXBsZXRlGAEgASgIEhAKCGlzX3N0YWxl",
            "GAIgASgIEhMKC2lzX3NuYXBzaG90GAMgASgIEjcKDHByaWNlX2xldmVscxgE",
            "IAMoCzIhLm1hcmtldF9kYXRhXzIuRGV0YWlsZWRET01BdFByaWNlIn4KEkRl",
            "dGFpbGVkRE9NQXRQcmljZRIUCgxzY2FsZWRfcHJpY2UYASABKBESDAoEc2lk",
            "ZRgCIAIoDRITCgtpc19zbmFwc2hvdBgDIAEoCBIvCgZvcmRlcnMYBCADKAsy",
            "Hy5tYXJrZXRfZGF0YV8yLkRldGFpbGVkRE9NT3JkZXIimgIKEERldGFpbGVk",
            "RE9NT3JkZXISHQoVZGV0YWlsZWRfZG9tX29yZGVyX2lkGAEgAigJEhEKCW9w",
            "ZXJhdGlvbhgCIAEoDRITCgtvcmRlcl9pbmRleBgDIAEoDRIVCg1zY2FsZWRf",
            "dm9sdW1lGAUgASgEEhwKFGRpc2NyZXRpb25hcnlfb2Zmc2V0GAYgASgNIokB",
            "CglPcGVyYXRpb24SFAoQT1BFUkFUSU9OX0lOU0VSVBAAEhQKEE9QRVJBVElP",
            "Tl9SRU1PVkUQARIUChBPUEVSQVRJT05fTU9ESUZZEAISHQoZT1BFUkFUSU9O",
            "X01PVkVfRlJPTV9QUklDRRADEhsKF09QRVJBVElPTl9NT1ZFX1RPX1BSSUNF",
            "EAQi7QEKA1JGURIbChNleGNoYW5nZV9yZXF1ZXN0X2lkGAEgASgJEi0KCXRp",
            "bWVzdGFtcBgCIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASDAoE",
            "c2lkZRgDIAEoDRIcCgZ2b2x1bWUYBCABKAsyDC5jcWcuRGVjaW1hbBI8Chhl",
            "eHBpcmF0aW9uX3V0Y190aW1lc3RhbXAYBSABKAsyGi5nb29nbGUucHJvdG9i",
            "dWYuVGltZXN0YW1wIjAKBFNpZGUSDAoIU0lERV9BTlkQABIMCghTSURFX0JJ",
            "RBABEgwKCFNJREVfQVNLEAIisAIKClJGUVJlcXVlc3QSGQoRY2xpZW50X3Jl",
            "cXVlc3RfaWQYASABKA0SEgoKYWNjb3VudF9pZBgCIAEoERITCgtjb250cmFj",
            "dF9pZBgDIAEoDRIRCglpc19tYW51YWwYBCABKAgSDAoEc2lkZRgFIAEoDRIa",
            "CgRzaXplGAYgASgLMgwuY3FnLkRlY2ltYWwSOwoXZXhlY3V0aW9uX3V0Y190",
            "aW1lc3RhbXAYByABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEiYK",
            "HmNsaWVudF9yZWd1bGF0b3J5X2FsZ29yaXRobV9pZBgIIAEoDRI8ChhleHBp",
            "cmF0aW9uX3V0Y190aW1lc3RhbXAYCSABKAsyGi5nb29nbGUucHJvdG9idWYu",
            "VGltZXN0YW1wIrECCglSRlFSZXBvcnQSGQoRY2xpZW50X3JlcXVlc3RfaWQY",
            "ASABKA0SGwoTZXhjaGFuZ2VfcmVxdWVzdF9pZBgCIAEoCRITCgtzdGF0dXNf",
            "Y29kZRgDIAEoDRIfCgdkZXRhaWxzGAQgASgLMg4uc2hhcmVkXzEuVGV4dBIp",
            "CiFlZmZlY3RpdmVfcmVndWxhdG9yeV9hbGdvcml0aG1faWQYBSABKA0iigEK",
            "ClN0YXR1c0NvZGUSFwoTU1RBVFVTX0NPREVfU1VDQ0VTUxAAEhcKE1NUQVRV",
            "U19DT0RFX0ZBSUxVUkUQZRIeChpTVEFUVVNfQ09ERV9JTlZBTElEX1BBUkFN",
            "UxBmEioKJlNUQVRVU19DT0RFX05PVF9TVVBQT1JURURfRk9SX0NPTlRSQUNU",
            "EGciXQobT3B0aW9uQ2FsY3VsYXRpb25QYXJhbWV0ZXJzEiEKGW9wdGlvbl9t",
            "YXR1cml0eV9zeW1ib2xfaWQYASABKAkSGwoTc3RyaWtlX2NvbnRyYWN0X2lk",
            "cxgCIAMoDSLZAQoYT3B0aW9uQ2FsY3VsYXRpb25SZXF1ZXN0EhIKCnJlcXVl",
            "c3RfaWQYASABKA0SUQodb3B0aW9uX2NhbGN1bGF0aW9uX3BhcmFtZXRlcnMY",
            "AiABKAsyKi5tYXJrZXRfZGF0YV8yLk9wdGlvbkNhbGN1bGF0aW9uUGFyYW1l",
            "dGVycxIUCgxyZXF1ZXN0X3R5cGUYAyABKA0iQAoLUmVxdWVzdFR5cGUSGgoW",
            "UkVRVUVTVF9UWVBFX1NVQlNDUklCRRACEhUKEVJFUVVFU1RfVFlQRV9EUk9Q",
            "EAMi0gEKF09wdGlvbkNhbGN1bGF0aW9uVmFsdWVzEhoKEnN0cmlrZV9jb250",
            "cmFjdF9pZBgBIAEoDRIoCiBzY2FsZWRfY29oZXJlbnRfdW5kZXJseWluZ19w",
            "cmljZRgCIAEoERIaChJpbXBsaWVkX3ZvbGF0aWxpdHkYAyABKAESDQoFdGhl",
            "b3YYBCABKAESDQoFZGVsdGEYBSABKAESDQoFZ2FtbWEYBiABKAESDAoEdmVn",
            "YRgHIAEoARINCgV0aGV0YRgIIAEoARILCgNyaG8YCSABKAEi1AQKF09wdGlv",
            "bkNhbGN1bGF0aW9uUmVwb3J0EhIKCnJlcXVlc3RfaWQYASABKA0SEwoLc3Rh",
            "dHVzX2NvZGUYAiABKA0SFgoOdXBfdG9fdXRjX3RpbWUYAyABKAMSFQoNaW50",
            "ZXJlc3RfcmF0ZRgEIAEoARIfChdzY2FsZWRfdW5kZXJseWluZ19wcmljZRgF",
            "IAEoERI2CgZ2YWx1ZXMYBiADKAsyJi5tYXJrZXRfZGF0YV8yLk9wdGlvbkNh",
            "bGN1bGF0aW9uVmFsdWVzEh8KB2RldGFpbHMYByABKAsyDi5zaGFyZWRfMS5U",
            "ZXh0EiAKEmlzX3JlcG9ydF9jb21wbGV0ZRgIIAEoCDoEdHJ1ZSLEAgoKU3Rh",
            "dHVzQ29kZRIaChZTVEFUVVNfQ09ERV9TVUJTQ1JJQkVEEAESFwoTU1RBVFVT",
            "X0NPREVfRFJPUFBFRBACEhYKElNUQVRVU19DT0RFX1VQREFURRADEhwKGFNU",
            "QVRVU19DT0RFX0RJU0NPTk5FQ1RFRBAEEhcKE1NUQVRVU19DT0RFX0ZBSUxV",
            "UkUQZRIeChpTVEFUVVNfQ09ERV9JTlZBTElEX1BBUkFNUxBmEh0KGVNUQVRV",
            "U19DT0RFX0FDQ0VTU19ERU5JRUQQZxIsCihTVEFUVVNfQ09ERV9TVUJTQ1JJ",
            "UFRJT05fTElNSVRfVklPTEFUSU9OEGgSLAooU1RBVFVTX0NPREVfUkVRVUVT",
            "VF9SQVRFX0xJTUlUX1ZJT0xBVElPThBpEhcKE1NUQVRVU19DT0RFX0RFTEVU",
            "RUQQag=="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Shared1.Shared1Reflection.Descriptor, global::Cqg.DecimalReflection.Descriptor, global::Google.Protobuf.TimestampReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::MarketData2.MarketDataSubscription), global::MarketData2.MarketDataSubscription.Parser, new[]{ "ContractId", "Level", "IncludePastMarketValues", "Reserved1", "IncludePastQuotes", "IncludeDiscretionaryQuotes", "IncludeSessionMarketValues", "IncludeYields", "IncludeSourcePrices", "IncludeRequestsForQuotation", "ContributorId" }, null, new[]{ typeof(global::MarketData2.MarketDataSubscription.Types.Level) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::MarketData2.MarketDataSubscriptionStatus), global::MarketData2.MarketDataSubscriptionStatus.Parser, new[]{ "ContractId", "StatusCode", "Level", "TextMessage", "Reserved1", "PastQuotesIncluded", "DiscretionaryQuotesIncluded", "SessionMarketValuesIncluded", "YieldsIncluded", "SourcePriceIncluded", "RequestsForQuotationIncluded", "ContributorId" }, null, new[]{ typeof(global::MarketData2.MarketDataSubscriptionStatus.Types.StatusCode) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::MarketData2.RealTimeMarketData), global::MarketData2.RealTimeMarketData.Parser, new[]{ "ContractId", "Quotes", "IsSnapshot", "CollapsingLevel", "MarketValues", "DetailedDom", "RequestsForQuotation" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::MarketData2.Quote), global::MarketData2.Quote.Parser, new[]{ "Type", "QuoteUtcTime", "ScaledPrice", "ScaledSourcePrice", "PriceYield", "ScaledVolume", "Indicators", "SalesCondition" }, null, new[]{ typeof(global::MarketData2.Quote.Types.Type), typeof(global::MarketData2.Quote.Types.Indicator), typeof(global::MarketData2.Quote.Types.SalesCondition) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::MarketData2.MarketValues), global::MarketData2.MarketValues.Parser, new[]{ "ScaledOpenPrice", "ScaledHighPrice", "ScaledLowPrice", "ScaledClosePrice", "ScaledYesterdaySettlement", "ScaledTotalVolume", "ScaledYesterdayClose", "ScaledIndicativeOpen", "ScaledIndicativeOpenVolume", "DayIndex", "ScaledOpenInterest", "TickVolume", "ScaledSettlement", "ScaledMarkerPrice", "ClearedFields", "TradeDate", "SessionIndex", "MarketYields" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::MarketData2.MarketYields), global::MarketData2.MarketYields.Parser, new[]{ "YieldOfOpenPrice", "YieldOfHighPrice", "YieldOfLowPrice", "YieldOfClosePrice", "YieldOfYesterdaySettlement", "YieldOfYesterdayClose", "YieldOfIndicativeOpen", "YieldOfSettlement" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::MarketData2.AtTheMoneyStrikeRequest), global::MarketData2.AtTheMoneyStrikeRequest.Parser, new[]{ "OptionMaturitySymbolId" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::MarketData2.AtTheMoneyStrikeReport), global::MarketData2.AtTheMoneyStrikeReport.Parser, new[]{ "Strike" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::MarketData2.DetailedDOM), global::MarketData2.DetailedDOM.Parser, new[]{ "IsDetailedDomComplete", "IsStale", "IsSnapshot", "PriceLevels" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::MarketData2.DetailedDOMAtPrice), global::MarketData2.DetailedDOMAtPrice.Parser, new[]{ "ScaledPrice", "Side", "IsSnapshot", "Orders" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::MarketData2.DetailedDOMOrder), global::MarketData2.DetailedDOMOrder.Parser, new[]{ "DetailedDomOrderId", "Operation", "OrderIndex", "ScaledVolume", "DiscretionaryOffset" }, null, new[]{ typeof(global::MarketData2.DetailedDOMOrder.Types.Operation) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::MarketData2.RFQ), global::MarketData2.RFQ.Parser, new[]{ "ExchangeRequestId", "Timestamp", "Side", "Volume", "ExpirationUtcTimestamp" }, null, new[]{ typeof(global::MarketData2.RFQ.Types.Side) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::MarketData2.RFQRequest), global::MarketData2.RFQRequest.Parser, new[]{ "ClientRequestId", "AccountId", "ContractId", "IsManual", "Side", "Size", "ExecutionUtcTimestamp", "ClientRegulatoryAlgorithmId", "ExpirationUtcTimestamp" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::MarketData2.RFQReport), global::MarketData2.RFQReport.Parser, new[]{ "ClientRequestId", "ExchangeRequestId", "StatusCode", "Details", "EffectiveRegulatoryAlgorithmId" }, null, new[]{ typeof(global::MarketData2.RFQReport.Types.StatusCode) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::MarketData2.OptionCalculationParameters), global::MarketData2.OptionCalculationParameters.Parser, new[]{ "OptionMaturitySymbolId", "StrikeContractIds" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::MarketData2.OptionCalculationRequest), global::MarketData2.OptionCalculationRequest.Parser, new[]{ "RequestId", "OptionCalculationParameters", "RequestType" }, null, new[]{ typeof(global::MarketData2.OptionCalculationRequest.Types.RequestType) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::MarketData2.OptionCalculationValues), global::MarketData2.OptionCalculationValues.Parser, new[]{ "StrikeContractId", "ScaledCoherentUnderlyingPrice", "ImpliedVolatility", "Theov", "Delta", "Gamma", "Vega", "Theta", "Rho" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::MarketData2.OptionCalculationReport), global::MarketData2.OptionCalculationReport.Parser, new[]{ "RequestId", "StatusCode", "UpToUtcTime", "InterestRate", "ScaledUnderlyingPrice", "Values", "Details", "IsReportComplete" }, null, new[]{ typeof(global::MarketData2.OptionCalculationReport.Types.StatusCode) }, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// Subscription to market data.
  /// If it is necessary to change subscription level client should send a new subscription request with the same ID
  /// but a new subscription level.
  /// </summary>
  public sealed partial class MarketDataSubscription : pb::IExtendableMessage<MarketDataSubscription>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<MarketDataSubscription> _parser = new pb::MessageParser<MarketDataSubscription>(() => new MarketDataSubscription());
    private pb::UnknownFieldSet _unknownFields;
    private pb::ExtensionSet<MarketDataSubscription> _extensions;
    private pb::ExtensionSet<MarketDataSubscription> _Extensions { get { return _extensions; } }
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<MarketDataSubscription> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::MarketData2.MarketData2Reflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public MarketDataSubscription() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public MarketDataSubscription(MarketDataSubscription other) : this() {
      _hasBits0 = other._hasBits0;
      contractId_ = other.contractId_;
      level_ = other.level_;
      includePastMarketValues_ = other.includePastMarketValues_;
      reserved1_ = other.reserved1_;
      includePastQuotes_ = other.includePastQuotes_;
      includeDiscretionaryQuotes_ = other.includeDiscretionaryQuotes_;
      includeSessionMarketValues_ = other.includeSessionMarketValues_;
      includeYields_ = other.includeYields_;
      includeSourcePrices_ = other.includeSourcePrices_;
      includeRequestsForQuotation_ = other.includeRequestsForQuotation_;
      contributorId_ = other.contributorId_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
      _extensions = pb::ExtensionSet.Clone(other._extensions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public MarketDataSubscription Clone() {
      return new MarketDataSubscription(this);
    }

    /// <summary>Field number for the "contract_id" field.</summary>
    public const int ContractIdFieldNumber = 1;
    private readonly static uint ContractIdDefaultValue = 0;

    private uint contractId_;
    /// <summary>
    /// Contract ID to subscribe (see symbol resolution report).
    /// This is client's responsibility to re-subscribe in case of symbol resolution update.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint ContractId {
      get { if ((_hasBits0 & 1) != 0) { return contractId_; } else { return ContractIdDefaultValue; } }
      set {
        _hasBits0 |= 1;
        contractId_ = value;
      }
    }
    /// <summary>Gets whether the "contract_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasContractId {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "contract_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearContractId() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "level" field.</summary>
    public const int LevelFieldNumber = 2;
    private readonly static uint LevelDefaultValue = 0;

    private uint level_;
    /// <summary>
    /// Subscription level.
    /// This field is associated with Level enum type.
    /// Note: level can be decreased if the client is prohibited to get requested data.
    /// Result level will be available in MarketDataSubscriptionStatus.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint Level {
      get { if ((_hasBits0 & 2) != 0) { return level_; } else { return LevelDefaultValue; } }
      set {
        _hasBits0 |= 2;
        level_ = value;
      }
    }
    /// <summary>Gets whether the "level" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasLevel {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "level" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearLevel() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "include_past_market_values" field.</summary>
    public const int IncludePastMarketValuesFieldNumber = 3;
    private readonly static bool IncludePastMarketValuesDefaultValue = false;

    private bool includePastMarketValues_;
    /// <summary>
    /// Defines market values array in real-time market data snapshot.
    /// False or omitted means that snapshots will contain market values for current trading day only (if available).
    /// True means that snapshots may contain market values for several (up to 3) past trading days.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IncludePastMarketValues {
      get { if ((_hasBits0 & 4) != 0) { return includePastMarketValues_; } else { return IncludePastMarketValuesDefaultValue; } }
      set {
        _hasBits0 |= 4;
        includePastMarketValues_ = value;
      }
    }
    /// <summary>Gets whether the "include_past_market_values" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasIncludePastMarketValues {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "include_past_market_values" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearIncludePastMarketValues() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "reserved1" field.</summary>
    public const int Reserved1FieldNumber = 4;
    private readonly static long Reserved1DefaultValue = 0L;

    private long reserved1_;
    /// <summary>
    /// Reserved field number (do not reuse).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long Reserved1 {
      get { if ((_hasBits0 & 8) != 0) { return reserved1_; } else { return Reserved1DefaultValue; } }
      set {
        _hasBits0 |= 8;
        reserved1_ = value;
      }
    }
    /// <summary>Gets whether the "reserved1" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasReserved1 {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "reserved1" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearReserved1() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "include_past_quotes" field.</summary>
    public const int IncludePastQuotesFieldNumber = 5;
    private readonly static bool IncludePastQuotesDefaultValue = false;

    private bool includePastQuotes_;
    /// <summary>
    /// Defines quotes array in real-time market data snapshot.
    /// False or omitted means that snapshots will contain last known ask, bid, trade and settlement for current trading day.
    /// True means that snapshots will contain last known ask, bid, trade and settlement for last N trading days.
    /// Note: N by default equals to 7 and can't be changed by client. Contact customer support if you want to increase this value.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IncludePastQuotes {
      get { if ((_hasBits0 & 16) != 0) { return includePastQuotes_; } else { return IncludePastQuotesDefaultValue; } }
      set {
        _hasBits0 |= 16;
        includePastQuotes_ = value;
      }
    }
    /// <summary>Gets whether the "include_past_quotes" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasIncludePastQuotes {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "include_past_quotes" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearIncludePastQuotes() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "include_discretionary_quotes" field.</summary>
    public const int IncludeDiscretionaryQuotesFieldNumber = 6;
    private readonly static bool IncludeDiscretionaryQuotesDefaultValue = false;

    private bool includeDiscretionaryQuotes_;
    /// <summary>
    /// Whether need to include discretionary quotes in real-time market data.
    /// Note: Flag is ignored (considered as False) if the client is prohibited to get discretionary quotes.
    /// Result value will be available in MarketDataSubscriptionStatus.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IncludeDiscretionaryQuotes {
      get { if ((_hasBits0 & 32) != 0) { return includeDiscretionaryQuotes_; } else { return IncludeDiscretionaryQuotesDefaultValue; } }
      set {
        _hasBits0 |= 32;
        includeDiscretionaryQuotes_ = value;
      }
    }
    /// <summary>Gets whether the "include_discretionary_quotes" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasIncludeDiscretionaryQuotes {
      get { return (_hasBits0 & 32) != 0; }
    }
    /// <summary>Clears the value of the "include_discretionary_quotes" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearIncludeDiscretionaryQuotes() {
      _hasBits0 &= ~32;
    }

    /// <summary>Field number for the "include_session_market_values" field.</summary>
    public const int IncludeSessionMarketValuesFieldNumber = 9;
    private readonly static bool IncludeSessionMarketValuesDefaultValue = false;

    private bool includeSessionMarketValues_;
    /// <summary>
    /// Defines session market values array in real-time market data snapshot.
    /// False or omitted means that snapshots will not contain session market values.
    /// True means that snapshots may contain session market values for several sessions.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IncludeSessionMarketValues {
      get { if ((_hasBits0 & 128) != 0) { return includeSessionMarketValues_; } else { return IncludeSessionMarketValuesDefaultValue; } }
      set {
        _hasBits0 |= 128;
        includeSessionMarketValues_ = value;
      }
    }
    /// <summary>Gets whether the "include_session_market_values" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasIncludeSessionMarketValues {
      get { return (_hasBits0 & 128) != 0; }
    }
    /// <summary>Clears the value of the "include_session_market_values" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearIncludeSessionMarketValues() {
      _hasBits0 &= ~128;
    }

    /// <summary>Field number for the "include_yields" field.</summary>
    public const int IncludeYieldsFieldNumber = 8;
    private readonly static bool IncludeYieldsDefaultValue = false;

    private bool includeYields_;
    /// <summary>
    /// Specifies that quotes and market values need to include yields.
    /// Result value will be available in MarketDataSubscriptionStatus.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IncludeYields {
      get { if ((_hasBits0 & 64) != 0) { return includeYields_; } else { return IncludeYieldsDefaultValue; } }
      set {
        _hasBits0 |= 64;
        includeYields_ = value;
      }
    }
    /// <summary>Gets whether the "include_yields" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasIncludeYields {
      get { return (_hasBits0 & 64) != 0; }
    }
    /// <summary>Clears the value of the "include_yields" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearIncludeYields() {
      _hasBits0 &= ~64;
    }

    /// <summary>Field number for the "include_source_prices" field.</summary>
    public const int IncludeSourcePricesFieldNumber = 10;
    private readonly static bool IncludeSourcePricesDefaultValue = false;

    private bool includeSourcePrices_;
    /// <summary>
    /// Defines source contract quote price in real-time market data.
    /// scaled_source_price is provided only for best ask and best bid.
    /// Other quote types either have the same values as scaled_price for the contract or not supported.
    /// Note: Flag is ignored (considered as False) if the contract does not have a source contract.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IncludeSourcePrices {
      get { if ((_hasBits0 & 256) != 0) { return includeSourcePrices_; } else { return IncludeSourcePricesDefaultValue; } }
      set {
        _hasBits0 |= 256;
        includeSourcePrices_ = value;
      }
    }
    /// <summary>Gets whether the "include_source_prices" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasIncludeSourcePrices {
      get { return (_hasBits0 & 256) != 0; }
    }
    /// <summary>Clears the value of the "include_source_prices" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearIncludeSourcePrices() {
      _hasBits0 &= ~256;
    }

    /// <summary>Field number for the "include_requests_for_quotation" field.</summary>
    public const int IncludeRequestsForQuotationFieldNumber = 11;
    private readonly static bool IncludeRequestsForQuotationDefaultValue = false;

    private bool includeRequestsForQuotation_;
    /// <summary>
    /// Whether need to include RFQ in real-time market data. By default server don't provide them.
    /// Result value will be available in MarketDataSubscriptionStatus.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IncludeRequestsForQuotation {
      get { if ((_hasBits0 & 512) != 0) { return includeRequestsForQuotation_; } else { return IncludeRequestsForQuotationDefaultValue; } }
      set {
        _hasBits0 |= 512;
        includeRequestsForQuotation_ = value;
      }
    }
    /// <summary>Gets whether the "include_requests_for_quotation" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasIncludeRequestsForQuotation {
      get { return (_hasBits0 & 512) != 0; }
    }
    /// <summary>Clears the value of the "include_requests_for_quotation" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearIncludeRequestsForQuotation() {
      _hasBits0 &= ~512;
    }

    /// <summary>Field number for the "contributor_id" field.</summary>
    public const int ContributorIdFieldNumber = 7;
    private readonly static string ContributorIdDefaultValue = "";

    private string contributorId_;
    /// <summary>
    /// Optional contributor ID for contributor specific data subscriptions.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ContributorId {
      get { return contributorId_ ?? ContributorIdDefaultValue; }
      set {
        contributorId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "contributor_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasContributorId {
      get { return contributorId_ != null; }
    }
    /// <summary>Clears the value of the "contributor_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearContributorId() {
      contributorId_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as MarketDataSubscription);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(MarketDataSubscription other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (ContractId != other.ContractId) return false;
      if (Level != other.Level) return false;
      if (IncludePastMarketValues != other.IncludePastMarketValues) return false;
      if (Reserved1 != other.Reserved1) return false;
      if (IncludePastQuotes != other.IncludePastQuotes) return false;
      if (IncludeDiscretionaryQuotes != other.IncludeDiscretionaryQuotes) return false;
      if (IncludeSessionMarketValues != other.IncludeSessionMarketValues) return false;
      if (IncludeYields != other.IncludeYields) return false;
      if (IncludeSourcePrices != other.IncludeSourcePrices) return false;
      if (IncludeRequestsForQuotation != other.IncludeRequestsForQuotation) return false;
      if (ContributorId != other.ContributorId) return false;
      if (!Equals(_extensions, other._extensions)) {
        return false;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasContractId) hash ^= ContractId.GetHashCode();
      if (HasLevel) hash ^= Level.GetHashCode();
      if (HasIncludePastMarketValues) hash ^= IncludePastMarketValues.GetHashCode();
      if (HasReserved1) hash ^= Reserved1.GetHashCode();
      if (HasIncludePastQuotes) hash ^= IncludePastQuotes.GetHashCode();
      if (HasIncludeDiscretionaryQuotes) hash ^= IncludeDiscretionaryQuotes.GetHashCode();
      if (HasIncludeSessionMarketValues) hash ^= IncludeSessionMarketValues.GetHashCode();
      if (HasIncludeYields) hash ^= IncludeYields.GetHashCode();
      if (HasIncludeSourcePrices) hash ^= IncludeSourcePrices.GetHashCode();
      if (HasIncludeRequestsForQuotation) hash ^= IncludeRequestsForQuotation.GetHashCode();
      if (HasContributorId) hash ^= ContributorId.GetHashCode();
      if (_extensions != null) {
        hash ^= _extensions.GetHashCode();
      }
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasContractId) {
        output.WriteRawTag(8);
        output.WriteUInt32(ContractId);
      }
      if (HasLevel) {
        output.WriteRawTag(16);
        output.WriteUInt32(Level);
      }
      if (HasIncludePastMarketValues) {
        output.WriteRawTag(24);
        output.WriteBool(IncludePastMarketValues);
      }
      if (HasReserved1) {
        output.WriteRawTag(32);
        output.WriteSInt64(Reserved1);
      }
      if (HasIncludePastQuotes) {
        output.WriteRawTag(40);
        output.WriteBool(IncludePastQuotes);
      }
      if (HasIncludeDiscretionaryQuotes) {
        output.WriteRawTag(48);
        output.WriteBool(IncludeDiscretionaryQuotes);
      }
      if (HasContributorId) {
        output.WriteRawTag(58);
        output.WriteString(ContributorId);
      }
      if (HasIncludeYields) {
        output.WriteRawTag(64);
        output.WriteBool(IncludeYields);
      }
      if (HasIncludeSessionMarketValues) {
        output.WriteRawTag(72);
        output.WriteBool(IncludeSessionMarketValues);
      }
      if (HasIncludeSourcePrices) {
        output.WriteRawTag(80);
        output.WriteBool(IncludeSourcePrices);
      }
      if (HasIncludeRequestsForQuotation) {
        output.WriteRawTag(88);
        output.WriteBool(IncludeRequestsForQuotation);
      }
      if (_extensions != null) {
        _extensions.WriteTo(output);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasContractId) {
        output.WriteRawTag(8);
        output.WriteUInt32(ContractId);
      }
      if (HasLevel) {
        output.WriteRawTag(16);
        output.WriteUInt32(Level);
      }
      if (HasIncludePastMarketValues) {
        output.WriteRawTag(24);
        output.WriteBool(IncludePastMarketValues);
      }
      if (HasReserved1) {
        output.WriteRawTag(32);
        output.WriteSInt64(Reserved1);
      }
      if (HasIncludePastQuotes) {
        output.WriteRawTag(40);
        output.WriteBool(IncludePastQuotes);
      }
      if (HasIncludeDiscretionaryQuotes) {
        output.WriteRawTag(48);
        output.WriteBool(IncludeDiscretionaryQuotes);
      }
      if (HasContributorId) {
        output.WriteRawTag(58);
        output.WriteString(ContributorId);
      }
      if (HasIncludeYields) {
        output.WriteRawTag(64);
        output.WriteBool(IncludeYields);
      }
      if (HasIncludeSessionMarketValues) {
        output.WriteRawTag(72);
        output.WriteBool(IncludeSessionMarketValues);
      }
      if (HasIncludeSourcePrices) {
        output.WriteRawTag(80);
        output.WriteBool(IncludeSourcePrices);
      }
      if (HasIncludeRequestsForQuotation) {
        output.WriteRawTag(88);
        output.WriteBool(IncludeRequestsForQuotation);
      }
      if (_extensions != null) {
        _extensions.WriteTo(ref output);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (HasContractId) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(ContractId);
      }
      if (HasLevel) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Level);
      }
      if (HasIncludePastMarketValues) {
        size += 1 + 1;
      }
      if (HasReserved1) {
        size += 1 + pb::CodedOutputStream.ComputeSInt64Size(Reserved1);
      }
      if (HasIncludePastQuotes) {
        size += 1 + 1;
      }
      if (HasIncludeDiscretionaryQuotes) {
        size += 1 + 1;
      }
      if (HasIncludeSessionMarketValues) {
        size += 1 + 1;
      }
      if (HasIncludeYields) {
        size += 1 + 1;
      }
      if (HasIncludeSourcePrices) {
        size += 1 + 1;
      }
      if (HasIncludeRequestsForQuotation) {
        size += 1 + 1;
      }
      if (HasContributorId) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ContributorId);
      }
      if (_extensions != null) {
        size += _extensions.CalculateSize();
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(MarketDataSubscription other) {
      if (other == null) {
        return;
      }
      if (other.HasContractId) {
        ContractId = other.ContractId;
      }
      if (other.HasLevel) {
        Level = other.Level;
      }
      if (other.HasIncludePastMarketValues) {
        IncludePastMarketValues = other.IncludePastMarketValues;
      }
      if (other.HasReserved1) {
        Reserved1 = other.Reserved1;
      }
      if (other.HasIncludePastQuotes) {
        IncludePastQuotes = other.IncludePastQuotes;
      }
      if (other.HasIncludeDiscretionaryQuotes) {
        IncludeDiscretionaryQuotes = other.IncludeDiscretionaryQuotes;
      }
      if (other.HasIncludeSessionMarketValues) {
        IncludeSessionMarketValues = other.IncludeSessionMarketValues;
      }
      if (other.HasIncludeYields) {
        IncludeYields = other.IncludeYields;
      }
      if (other.HasIncludeSourcePrices) {
        IncludeSourcePrices = other.IncludeSourcePrices;
      }
      if (other.HasIncludeRequestsForQuotation) {
        IncludeRequestsForQuotation = other.IncludeRequestsForQuotation;
      }
      if (other.HasContributorId) {
        ContributorId = other.ContributorId;
      }
      pb::ExtensionSet.MergeFrom(ref _extensions, other._extensions);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, input)) {
              _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            }
            break;
          case 8: {
            ContractId = input.ReadUInt32();
            break;
          }
          case 16: {
            Level = input.ReadUInt32();
            break;
          }
          case 24: {
            IncludePastMarketValues = input.ReadBool();
            break;
          }
          case 32: {
            Reserved1 = input.ReadSInt64();
            break;
          }
          case 40: {
            IncludePastQuotes = input.ReadBool();
            break;
          }
          case 48: {
            IncludeDiscretionaryQuotes = input.ReadBool();
            break;
          }
          case 58: {
            ContributorId = input.ReadString();
            break;
          }
          case 64: {
            IncludeYields = input.ReadBool();
            break;
          }
          case 72: {
            IncludeSessionMarketValues = input.ReadBool();
            break;
          }
          case 80: {
            IncludeSourcePrices = input.ReadBool();
            break;
          }
          case 88: {
            IncludeRequestsForQuotation = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, ref input)) {
              _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            }
            break;
          case 8: {
            ContractId = input.ReadUInt32();
            break;
          }
          case 16: {
            Level = input.ReadUInt32();
            break;
          }
          case 24: {
            IncludePastMarketValues = input.ReadBool();
            break;
          }
          case 32: {
            Reserved1 = input.ReadSInt64();
            break;
          }
          case 40: {
            IncludePastQuotes = input.ReadBool();
            break;
          }
          case 48: {
            IncludeDiscretionaryQuotes = input.ReadBool();
            break;
          }
          case 58: {
            ContributorId = input.ReadString();
            break;
          }
          case 64: {
            IncludeYields = input.ReadBool();
            break;
          }
          case 72: {
            IncludeSessionMarketValues = input.ReadBool();
            break;
          }
          case 80: {
            IncludeSourcePrices = input.ReadBool();
            break;
          }
          case 88: {
            IncludeRequestsForQuotation = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

    public TValue GetExtension<TValue>(pb::Extension<MarketDataSubscription, TValue> extension) {
      return pb::ExtensionSet.Get(ref _extensions, extension);
    }
    public pbc::RepeatedField<TValue> GetExtension<TValue>(pb::RepeatedExtension<MarketDataSubscription, TValue> extension) {
      return pb::ExtensionSet.Get(ref _extensions, extension);
    }
    public pbc::RepeatedField<TValue> GetOrInitializeExtension<TValue>(pb::RepeatedExtension<MarketDataSubscription, TValue> extension) {
      return pb::ExtensionSet.GetOrInitialize(ref _extensions, extension);
    }
    public void SetExtension<TValue>(pb::Extension<MarketDataSubscription, TValue> extension, TValue value) {
      pb::ExtensionSet.Set(ref _extensions, extension, value);
    }
    public bool HasExtension<TValue>(pb::Extension<MarketDataSubscription, TValue> extension) {
      return pb::ExtensionSet.Has(ref _extensions, extension);
    }
    public void ClearExtension<TValue>(pb::Extension<MarketDataSubscription, TValue> extension) {
      pb::ExtensionSet.Clear(ref _extensions, extension);
    }
    public void ClearExtension<TValue>(pb::RepeatedExtension<MarketDataSubscription, TValue> extension) {
      pb::ExtensionSet.Clear(ref _extensions, extension);
    }

    #region Nested types
    /// <summary>Container for nested types declared in the MarketDataSubscription message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// Level or subscription.
      /// </summary>
      public enum Level {
        /// <summary>
        /// Unsubscribe.
        /// </summary>
        [pbr::OriginalName("LEVEL_NONE")] None = 0,
        /// <summary>
        /// Get only settlement quotes.
        /// NOTE: MarketValues will contain only settlements.
        /// </summary>
        [pbr::OriginalName("LEVEL_SETTLEMENTS")] Settlements = 5,
        /// <summary>
        /// Get only market values.
        /// NOTE: Array of quotes in RealTimeMarketData message will be always empty.
        /// </summary>
        [pbr::OriginalName("LEVEL_MARKET_VALUES")] MarketValues = 6,
        /// <summary>
        /// Get trade and settlement quotes.
        /// </summary>
        [pbr::OriginalName("LEVEL_TRADES")] Trades = 1,
        /// <summary>
        /// Get trades, settlement and best ask &amp; bid without volumes.
        /// </summary>
        [pbr::OriginalName("LEVEL_TRADES_BBA")] TradesBba = 2,
        /// <summary>
        /// Get trades, settlement and best ask &amp; bid with volumes.
        /// </summary>
        [pbr::OriginalName("LEVEL_TRADES_BBA_VOLUMES")] TradesBbaVolumes = 3,
        /// <summary>
        /// All price data including DOM.
        /// </summary>
        [pbr::OriginalName("LEVEL_TRADES_BBA_DOM")] TradesBbaDom = 4,
        /// <summary>
        /// LEVEL_TRADES_BBA_DOM + Order Details.
        /// Note: This level forces MarketDataSubscription.include_discretionary_quotes flag.
        /// </summary>
        [pbr::OriginalName("LEVEL_TRADES_BBA_DETAILED_DOM")] TradesBbaDetailedDom = 7,
      }

    }
    #endregion

  }

  /// <summary>
  /// Subscription status
  /// </summary>
  public sealed partial class MarketDataSubscriptionStatus : pb::IExtendableMessage<MarketDataSubscriptionStatus>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<MarketDataSubscriptionStatus> _parser = new pb::MessageParser<MarketDataSubscriptionStatus>(() => new MarketDataSubscriptionStatus());
    private pb::UnknownFieldSet _unknownFields;
    private pb::ExtensionSet<MarketDataSubscriptionStatus> _extensions;
    private pb::ExtensionSet<MarketDataSubscriptionStatus> _Extensions { get { return _extensions; } }
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<MarketDataSubscriptionStatus> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::MarketData2.MarketData2Reflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public MarketDataSubscriptionStatus() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public MarketDataSubscriptionStatus(MarketDataSubscriptionStatus other) : this() {
      _hasBits0 = other._hasBits0;
      contractId_ = other.contractId_;
      statusCode_ = other.statusCode_;
      level_ = other.level_;
      textMessage_ = other.textMessage_;
      reserved1_ = other.reserved1_;
      pastQuotesIncluded_ = other.pastQuotesIncluded_;
      discretionaryQuotesIncluded_ = other.discretionaryQuotesIncluded_;
      sessionMarketValuesIncluded_ = other.sessionMarketValuesIncluded_;
      yieldsIncluded_ = other.yieldsIncluded_;
      sourcePriceIncluded_ = other.sourcePriceIncluded_;
      requestsForQuotationIncluded_ = other.requestsForQuotationIncluded_;
      contributorId_ = other.contributorId_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
      _extensions = pb::ExtensionSet.Clone(other._extensions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public MarketDataSubscriptionStatus Clone() {
      return new MarketDataSubscriptionStatus(this);
    }

    /// <summary>Field number for the "contract_id" field.</summary>
    public const int ContractIdFieldNumber = 1;
    private readonly static uint ContractIdDefaultValue = 0;

    private uint contractId_;
    /// <summary>
    /// Subscription contract ID.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint ContractId {
      get { if ((_hasBits0 & 1) != 0) { return contractId_; } else { return ContractIdDefaultValue; } }
      set {
        _hasBits0 |= 1;
        contractId_ = value;
      }
    }
    /// <summary>Gets whether the "contract_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasContractId {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "contract_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearContractId() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "status_code" field.</summary>
    public const int StatusCodeFieldNumber = 2;
    private readonly static uint StatusCodeDefaultValue = 0;

    private uint statusCode_;
    /// <summary>
    /// Subscription result.
    /// This field is associated with StatusCode enum type.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint StatusCode {
      get { if ((_hasBits0 & 2) != 0) { return statusCode_; } else { return StatusCodeDefaultValue; } }
      set {
        _hasBits0 |= 2;
        statusCode_ = value;
      }
    }
    /// <summary>Gets whether the "status_code" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasStatusCode {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "status_code" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearStatusCode() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "level" field.</summary>
    public const int LevelFieldNumber = 3;
    private readonly static uint LevelDefaultValue = 0;

    private uint level_;
    /// <summary>
    /// Effective subscription level.
    /// This field is associated with MarketDataSubscription.Level enum type.
    /// Note: when successfully subscribed to delayed DOM data, the reported level is LEVEL_TRADE_BBA_DOM,
    /// but actual DOM data may not yet be available and will be available later.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint Level {
      get { if ((_hasBits0 & 4) != 0) { return level_; } else { return LevelDefaultValue; } }
      set {
        _hasBits0 |= 4;
        level_ = value;
      }
    }
    /// <summary>Gets whether the "level" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasLevel {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "level" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearLevel() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "text_message" field.</summary>
    public const int TextMessageFieldNumber = 4;
    private readonly static string TextMessageDefaultValue = "";

    private string textMessage_;
    /// <summary>
    /// Possible details of subscription failure.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string TextMessage {
      get { return textMessage_ ?? TextMessageDefaultValue; }
      set {
        textMessage_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "text_message" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasTextMessage {
      get { return textMessage_ != null; }
    }
    /// <summary>Clears the value of the "text_message" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearTextMessage() {
      textMessage_ = null;
    }

    /// <summary>Field number for the "reserved1" field.</summary>
    public const int Reserved1FieldNumber = 5;
    private readonly static long Reserved1DefaultValue = 0L;

    private long reserved1_;
    /// <summary>
    /// Reserved field number (do not reuse).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long Reserved1 {
      get { if ((_hasBits0 & 8) != 0) { return reserved1_; } else { return Reserved1DefaultValue; } }
      set {
        _hasBits0 |= 8;
        reserved1_ = value;
      }
    }
    /// <summary>Gets whether the "reserved1" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasReserved1 {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "reserved1" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearReserved1() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "past_quotes_included" field.</summary>
    public const int PastQuotesIncludedFieldNumber = 6;
    private readonly static bool PastQuotesIncludedDefaultValue = false;

    private bool pastQuotesIncluded_;
    /// <summary>
    /// Specifies whether past quotes are included into real-time market data snapshot or not.
    /// Always False if user didn't request past quotes.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool PastQuotesIncluded {
      get { if ((_hasBits0 & 16) != 0) { return pastQuotesIncluded_; } else { return PastQuotesIncludedDefaultValue; } }
      set {
        _hasBits0 |= 16;
        pastQuotesIncluded_ = value;
      }
    }
    /// <summary>Gets whether the "past_quotes_included" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasPastQuotesIncluded {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "past_quotes_included" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearPastQuotesIncluded() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "discretionary_quotes_included" field.</summary>
    public const int DiscretionaryQuotesIncludedFieldNumber = 7;
    private readonly static bool DiscretionaryQuotesIncludedDefaultValue = false;

    private bool discretionaryQuotesIncluded_;
    /// <summary>
    /// Specifies whether discretionary quotes are included into real-time market data or not.
    /// Always False if user didn't request discretionary quotes.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool DiscretionaryQuotesIncluded {
      get { if ((_hasBits0 & 32) != 0) { return discretionaryQuotesIncluded_; } else { return DiscretionaryQuotesIncludedDefaultValue; } }
      set {
        _hasBits0 |= 32;
        discretionaryQuotesIncluded_ = value;
      }
    }
    /// <summary>Gets whether the "discretionary_quotes_included" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasDiscretionaryQuotesIncluded {
      get { return (_hasBits0 & 32) != 0; }
    }
    /// <summary>Clears the value of the "discretionary_quotes_included" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearDiscretionaryQuotesIncluded() {
      _hasBits0 &= ~32;
    }

    /// <summary>Field number for the "session_market_values_included" field.</summary>
    public const int SessionMarketValuesIncludedFieldNumber = 10;
    private readonly static bool SessionMarketValuesIncludedDefaultValue = false;

    private bool sessionMarketValuesIncluded_;
    /// <summary>
    /// Specifies whether intraday session market values are included into real-time market data or not.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool SessionMarketValuesIncluded {
      get { if ((_hasBits0 & 128) != 0) { return sessionMarketValuesIncluded_; } else { return SessionMarketValuesIncludedDefaultValue; } }
      set {
        _hasBits0 |= 128;
        sessionMarketValuesIncluded_ = value;
      }
    }
    /// <summary>Gets whether the "session_market_values_included" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasSessionMarketValuesIncluded {
      get { return (_hasBits0 & 128) != 0; }
    }
    /// <summary>Clears the value of the "session_market_values_included" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearSessionMarketValuesIncluded() {
      _hasBits0 &= ~128;
    }

    /// <summary>Field number for the "yields_included" field.</summary>
    public const int YieldsIncludedFieldNumber = 9;
    private readonly static bool YieldsIncludedDefaultValue = false;

    private bool yieldsIncluded_;
    /// <summary>
    /// Specifies whether yields are included into real-time market data or not.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool YieldsIncluded {
      get { if ((_hasBits0 & 64) != 0) { return yieldsIncluded_; } else { return YieldsIncludedDefaultValue; } }
      set {
        _hasBits0 |= 64;
        yieldsIncluded_ = value;
      }
    }
    /// <summary>Gets whether the "yields_included" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasYieldsIncluded {
      get { return (_hasBits0 & 64) != 0; }
    }
    /// <summary>Clears the value of the "yields_included" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearYieldsIncluded() {
      _hasBits0 &= ~64;
    }

    /// <summary>Field number for the "source_price_included" field.</summary>
    public const int SourcePriceIncludedFieldNumber = 11;
    private readonly static bool SourcePriceIncludedDefaultValue = false;

    private bool sourcePriceIncluded_;
    /// <summary>
    /// Specifies whether source contract prices are include into real-time market data or not.
    /// Always False if user didn't request source contract quotes.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool SourcePriceIncluded {
      get { if ((_hasBits0 & 256) != 0) { return sourcePriceIncluded_; } else { return SourcePriceIncludedDefaultValue; } }
      set {
        _hasBits0 |= 256;
        sourcePriceIncluded_ = value;
      }
    }
    /// <summary>Gets whether the "source_price_included" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasSourcePriceIncluded {
      get { return (_hasBits0 & 256) != 0; }
    }
    /// <summary>Clears the value of the "source_price_included" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearSourcePriceIncluded() {
      _hasBits0 &= ~256;
    }

    /// <summary>Field number for the "requests_for_quotation_included" field.</summary>
    public const int RequestsForQuotationIncludedFieldNumber = 12;
    private readonly static bool RequestsForQuotationIncludedDefaultValue = false;

    private bool requestsForQuotationIncluded_;
    /// <summary>
    /// Specifies whether RFQs are included into real-time market data or not.
    /// Always False if user didn't request RFQs.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool RequestsForQuotationIncluded {
      get { if ((_hasBits0 & 512) != 0) { return requestsForQuotationIncluded_; } else { return RequestsForQuotationIncludedDefaultValue; } }
      set {
        _hasBits0 |= 512;
        requestsForQuotationIncluded_ = value;
      }
    }
    /// <summary>Gets whether the "requests_for_quotation_included" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasRequestsForQuotationIncluded {
      get { return (_hasBits0 & 512) != 0; }
    }
    /// <summary>Clears the value of the "requests_for_quotation_included" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearRequestsForQuotationIncluded() {
      _hasBits0 &= ~512;
    }

    /// <summary>Field number for the "contributor_id" field.</summary>
    public const int ContributorIdFieldNumber = 8;
    private readonly static string ContributorIdDefaultValue = "";

    private string contributorId_;
    /// <summary>
    /// Contributor ID for contributor specific data subscriptions.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ContributorId {
      get { return contributorId_ ?? ContributorIdDefaultValue; }
      set {
        contributorId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "contributor_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasContributorId {
      get { return contributorId_ != null; }
    }
    /// <summary>Clears the value of the "contributor_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearContributorId() {
      contributorId_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as MarketDataSubscriptionStatus);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(MarketDataSubscriptionStatus other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (ContractId != other.ContractId) return false;
      if (StatusCode != other.StatusCode) return false;
      if (Level != other.Level) return false;
      if (TextMessage != other.TextMessage) return false;
      if (Reserved1 != other.Reserved1) return false;
      if (PastQuotesIncluded != other.PastQuotesIncluded) return false;
      if (DiscretionaryQuotesIncluded != other.DiscretionaryQuotesIncluded) return false;
      if (SessionMarketValuesIncluded != other.SessionMarketValuesIncluded) return false;
      if (YieldsIncluded != other.YieldsIncluded) return false;
      if (SourcePriceIncluded != other.SourcePriceIncluded) return false;
      if (RequestsForQuotationIncluded != other.RequestsForQuotationIncluded) return false;
      if (ContributorId != other.ContributorId) return false;
      if (!Equals(_extensions, other._extensions)) {
        return false;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasContractId) hash ^= ContractId.GetHashCode();
      if (HasStatusCode) hash ^= StatusCode.GetHashCode();
      if (HasLevel) hash ^= Level.GetHashCode();
      if (HasTextMessage) hash ^= TextMessage.GetHashCode();
      if (HasReserved1) hash ^= Reserved1.GetHashCode();
      if (HasPastQuotesIncluded) hash ^= PastQuotesIncluded.GetHashCode();
      if (HasDiscretionaryQuotesIncluded) hash ^= DiscretionaryQuotesIncluded.GetHashCode();
      if (HasSessionMarketValuesIncluded) hash ^= SessionMarketValuesIncluded.GetHashCode();
      if (HasYieldsIncluded) hash ^= YieldsIncluded.GetHashCode();
      if (HasSourcePriceIncluded) hash ^= SourcePriceIncluded.GetHashCode();
      if (HasRequestsForQuotationIncluded) hash ^= RequestsForQuotationIncluded.GetHashCode();
      if (HasContributorId) hash ^= ContributorId.GetHashCode();
      if (_extensions != null) {
        hash ^= _extensions.GetHashCode();
      }
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasContractId) {
        output.WriteRawTag(8);
        output.WriteUInt32(ContractId);
      }
      if (HasStatusCode) {
        output.WriteRawTag(16);
        output.WriteUInt32(StatusCode);
      }
      if (HasLevel) {
        output.WriteRawTag(24);
        output.WriteUInt32(Level);
      }
      if (HasTextMessage) {
        output.WriteRawTag(34);
        output.WriteString(TextMessage);
      }
      if (HasReserved1) {
        output.WriteRawTag(40);
        output.WriteSInt64(Reserved1);
      }
      if (HasPastQuotesIncluded) {
        output.WriteRawTag(48);
        output.WriteBool(PastQuotesIncluded);
      }
      if (HasDiscretionaryQuotesIncluded) {
        output.WriteRawTag(56);
        output.WriteBool(DiscretionaryQuotesIncluded);
      }
      if (HasContributorId) {
        output.WriteRawTag(66);
        output.WriteString(ContributorId);
      }
      if (HasYieldsIncluded) {
        output.WriteRawTag(72);
        output.WriteBool(YieldsIncluded);
      }
      if (HasSessionMarketValuesIncluded) {
        output.WriteRawTag(80);
        output.WriteBool(SessionMarketValuesIncluded);
      }
      if (HasSourcePriceIncluded) {
        output.WriteRawTag(88);
        output.WriteBool(SourcePriceIncluded);
      }
      if (HasRequestsForQuotationIncluded) {
        output.WriteRawTag(96);
        output.WriteBool(RequestsForQuotationIncluded);
      }
      if (_extensions != null) {
        _extensions.WriteTo(output);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasContractId) {
        output.WriteRawTag(8);
        output.WriteUInt32(ContractId);
      }
      if (HasStatusCode) {
        output.WriteRawTag(16);
        output.WriteUInt32(StatusCode);
      }
      if (HasLevel) {
        output.WriteRawTag(24);
        output.WriteUInt32(Level);
      }
      if (HasTextMessage) {
        output.WriteRawTag(34);
        output.WriteString(TextMessage);
      }
      if (HasReserved1) {
        output.WriteRawTag(40);
        output.WriteSInt64(Reserved1);
      }
      if (HasPastQuotesIncluded) {
        output.WriteRawTag(48);
        output.WriteBool(PastQuotesIncluded);
      }
      if (HasDiscretionaryQuotesIncluded) {
        output.WriteRawTag(56);
        output.WriteBool(DiscretionaryQuotesIncluded);
      }
      if (HasContributorId) {
        output.WriteRawTag(66);
        output.WriteString(ContributorId);
      }
      if (HasYieldsIncluded) {
        output.WriteRawTag(72);
        output.WriteBool(YieldsIncluded);
      }
      if (HasSessionMarketValuesIncluded) {
        output.WriteRawTag(80);
        output.WriteBool(SessionMarketValuesIncluded);
      }
      if (HasSourcePriceIncluded) {
        output.WriteRawTag(88);
        output.WriteBool(SourcePriceIncluded);
      }
      if (HasRequestsForQuotationIncluded) {
        output.WriteRawTag(96);
        output.WriteBool(RequestsForQuotationIncluded);
      }
      if (_extensions != null) {
        _extensions.WriteTo(ref output);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (HasContractId) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(ContractId);
      }
      if (HasStatusCode) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(StatusCode);
      }
      if (HasLevel) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Level);
      }
      if (HasTextMessage) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(TextMessage);
      }
      if (HasReserved1) {
        size += 1 + pb::CodedOutputStream.ComputeSInt64Size(Reserved1);
      }
      if (HasPastQuotesIncluded) {
        size += 1 + 1;
      }
      if (HasDiscretionaryQuotesIncluded) {
        size += 1 + 1;
      }
      if (HasSessionMarketValuesIncluded) {
        size += 1 + 1;
      }
      if (HasYieldsIncluded) {
        size += 1 + 1;
      }
      if (HasSourcePriceIncluded) {
        size += 1 + 1;
      }
      if (HasRequestsForQuotationIncluded) {
        size += 1 + 1;
      }
      if (HasContributorId) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ContributorId);
      }
      if (_extensions != null) {
        size += _extensions.CalculateSize();
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(MarketDataSubscriptionStatus other) {
      if (other == null) {
        return;
      }
      if (other.HasContractId) {
        ContractId = other.ContractId;
      }
      if (other.HasStatusCode) {
        StatusCode = other.StatusCode;
      }
      if (other.HasLevel) {
        Level = other.Level;
      }
      if (other.HasTextMessage) {
        TextMessage = other.TextMessage;
      }
      if (other.HasReserved1) {
        Reserved1 = other.Reserved1;
      }
      if (other.HasPastQuotesIncluded) {
        PastQuotesIncluded = other.PastQuotesIncluded;
      }
      if (other.HasDiscretionaryQuotesIncluded) {
        DiscretionaryQuotesIncluded = other.DiscretionaryQuotesIncluded;
      }
      if (other.HasSessionMarketValuesIncluded) {
        SessionMarketValuesIncluded = other.SessionMarketValuesIncluded;
      }
      if (other.HasYieldsIncluded) {
        YieldsIncluded = other.YieldsIncluded;
      }
      if (other.HasSourcePriceIncluded) {
        SourcePriceIncluded = other.SourcePriceIncluded;
      }
      if (other.HasRequestsForQuotationIncluded) {
        RequestsForQuotationIncluded = other.RequestsForQuotationIncluded;
      }
      if (other.HasContributorId) {
        ContributorId = other.ContributorId;
      }
      pb::ExtensionSet.MergeFrom(ref _extensions, other._extensions);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, input)) {
              _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            }
            break;
          case 8: {
            ContractId = input.ReadUInt32();
            break;
          }
          case 16: {
            StatusCode = input.ReadUInt32();
            break;
          }
          case 24: {
            Level = input.ReadUInt32();
            break;
          }
          case 34: {
            TextMessage = input.ReadString();
            break;
          }
          case 40: {
            Reserved1 = input.ReadSInt64();
            break;
          }
          case 48: {
            PastQuotesIncluded = input.ReadBool();
            break;
          }
          case 56: {
            DiscretionaryQuotesIncluded = input.ReadBool();
            break;
          }
          case 66: {
            ContributorId = input.ReadString();
            break;
          }
          case 72: {
            YieldsIncluded = input.ReadBool();
            break;
          }
          case 80: {
            SessionMarketValuesIncluded = input.ReadBool();
            break;
          }
          case 88: {
            SourcePriceIncluded = input.ReadBool();
            break;
          }
          case 96: {
            RequestsForQuotationIncluded = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, ref input)) {
              _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            }
            break;
          case 8: {
            ContractId = input.ReadUInt32();
            break;
          }
          case 16: {
            StatusCode = input.ReadUInt32();
            break;
          }
          case 24: {
            Level = input.ReadUInt32();
            break;
          }
          case 34: {
            TextMessage = input.ReadString();
            break;
          }
          case 40: {
            Reserved1 = input.ReadSInt64();
            break;
          }
          case 48: {
            PastQuotesIncluded = input.ReadBool();
            break;
          }
          case 56: {
            DiscretionaryQuotesIncluded = input.ReadBool();
            break;
          }
          case 66: {
            ContributorId = input.ReadString();
            break;
          }
          case 72: {
            YieldsIncluded = input.ReadBool();
            break;
          }
          case 80: {
            SessionMarketValuesIncluded = input.ReadBool();
            break;
          }
          case 88: {
            SourcePriceIncluded = input.ReadBool();
            break;
          }
          case 96: {
            RequestsForQuotationIncluded = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

    public TValue GetExtension<TValue>(pb::Extension<MarketDataSubscriptionStatus, TValue> extension) {
      return pb::ExtensionSet.Get(ref _extensions, extension);
    }
    public pbc::RepeatedField<TValue> GetExtension<TValue>(pb::RepeatedExtension<MarketDataSubscriptionStatus, TValue> extension) {
      return pb::ExtensionSet.Get(ref _extensions, extension);
    }
    public pbc::RepeatedField<TValue> GetOrInitializeExtension<TValue>(pb::RepeatedExtension<MarketDataSubscriptionStatus, TValue> extension) {
      return pb::ExtensionSet.GetOrInitialize(ref _extensions, extension);
    }
    public void SetExtension<TValue>(pb::Extension<MarketDataSubscriptionStatus, TValue> extension, TValue value) {
      pb::ExtensionSet.Set(ref _extensions, extension, value);
    }
    public bool HasExtension<TValue>(pb::Extension<MarketDataSubscriptionStatus, TValue> extension) {
      return pb::ExtensionSet.Has(ref _extensions, extension);
    }
    public void ClearExtension<TValue>(pb::Extension<MarketDataSubscriptionStatus, TValue> extension) {
      pb::ExtensionSet.Clear(ref _extensions, extension);
    }
    public void ClearExtension<TValue>(pb::RepeatedExtension<MarketDataSubscriptionStatus, TValue> extension) {
      pb::ExtensionSet.Clear(ref _extensions, extension);
    }

    #region Nested types
    /// <summary>Container for nested types declared in the MarketDataSubscriptionStatus message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public enum StatusCode {
        /// <summary>
        //// success codes (0 - 99)
        /// </summary>
        [pbr::OriginalName("STATUS_CODE_SUCCESS")] Success = 0,
        /// <summary>
        /// Currently subscription is disconnected. Possible reasons: communication issues, metadata update.
        /// NOTE: Clients should not resubscribe in this case, the server will restore subscription with
        /// sending STATUS_CODE_SUCCESS status.
        /// </summary>
        [pbr::OriginalName("STATUS_CODE_DISCONNECTED")] Disconnected = 1,
        /// <summary>
        //// failure codes (100+)
        /// General failure.
        /// </summary>
        [pbr::OriginalName("STATUS_CODE_FAILURE")] Failure = 101,
        /// <summary>
        /// Subscription parameters are invalid.
        /// </summary>
        [pbr::OriginalName("STATUS_CODE_INVALID_PARAMS")] InvalidParams = 102,
        /// <summary>
        /// The user is not allowed to be subscribed to this Instrument.
        /// </summary>
        [pbr::OriginalName("STATUS_CODE_ACCESS_DENIED")] AccessDenied = 103,
        /// <summary>
        /// Market data source was deleted because of expiration or by another reason.
        /// </summary>
        [pbr::OriginalName("STATUS_CODE_DELETED")] Deleted = 104,
        /// <summary>
        /// The subscription count limit has been violated.
        /// </summary>
        [pbr::OriginalName("STATUS_CODE_SUBSCRIPTION_LIMIT_VIOLATION")] SubscriptionLimitViolation = 105,
        /// <summary>
        /// Contributor ID is required for this subscription but was not provided or not authorized.
        /// </summary>
        [pbr::OriginalName("STATUS_CODE_CONTRIBUTOR_REQUIRED")] ContributorRequired = 106,
        /// <summary>
        /// The subscription rate limit has been violated.
        /// </summary>
        [pbr::OriginalName("STATUS_CODE_SUBSCRIPTION_RATE_LIMIT_VIOLATION")] SubscriptionRateLimitViolation = 107,
        /// <summary>
        /// Market data subscription is not supported for specified contract.
        /// </summary>
        [pbr::OriginalName("STATUS_CODE_NOT_SUPPORTED")] NotSupported = 110,
      }

    }
    #endregion

  }

  /// <summary>
  /// Real time data delivery.
  /// Snapshot is sent as the first message after subscription and may appear periodically when subscribed.
  /// </summary>
  public sealed partial class RealTimeMarketData : pb::IExtendableMessage<RealTimeMarketData>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<RealTimeMarketData> _parser = new pb::MessageParser<RealTimeMarketData>(() => new RealTimeMarketData());
    private pb::UnknownFieldSet _unknownFields;
    private pb::ExtensionSet<RealTimeMarketData> _extensions;
    private pb::ExtensionSet<RealTimeMarketData> _Extensions { get { return _extensions; } }
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<RealTimeMarketData> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::MarketData2.MarketData2Reflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RealTimeMarketData() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RealTimeMarketData(RealTimeMarketData other) : this() {
      _hasBits0 = other._hasBits0;
      contractId_ = other.contractId_;
      quotes_ = other.quotes_.Clone();
      isSnapshot_ = other.isSnapshot_;
      collapsingLevel_ = other.collapsingLevel_;
      marketValues_ = other.marketValues_.Clone();
      detailedDom_ = other.detailedDom_ != null ? other.detailedDom_.Clone() : null;
      requestsForQuotation_ = other.requestsForQuotation_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
      _extensions = pb::ExtensionSet.Clone(other._extensions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RealTimeMarketData Clone() {
      return new RealTimeMarketData(this);
    }

    /// <summary>Field number for the "contract_id" field.</summary>
    public const int ContractIdFieldNumber = 1;
    private readonly static uint ContractIdDefaultValue = 0;

    private uint contractId_;
    /// <summary>
    /// Contract ID assigned by server.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint ContractId {
      get { if ((_hasBits0 & 1) != 0) { return contractId_; } else { return ContractIdDefaultValue; } }
      set {
        _hasBits0 |= 1;
        contractId_ = value;
      }
    }
    /// <summary>Gets whether the "contract_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasContractId {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "contract_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearContractId() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "quotes" field.</summary>
    public const int QuotesFieldNumber = 2;
    private static readonly pb::FieldCodec<global::MarketData2.Quote> _repeated_quotes_codec
        = pb::FieldCodec.ForMessage(18, global::MarketData2.Quote.Parser);
    private readonly pbc::RepeatedField<global::MarketData2.Quote> quotes_ = new pbc::RepeatedField<global::MarketData2.Quote>();
    /// <summary>
    /// Contract quotes. DOM is updated by new volumes per price. Zero volume is used to clean this price record from DOM.
    /// Snapshot quotes have no indicators.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::MarketData2.Quote> Quotes {
      get { return quotes_; }
    }

    /// <summary>Field number for the "is_snapshot" field.</summary>
    public const int IsSnapshotFieldNumber = 3;
    private readonly static bool IsSnapshotDefaultValue = false;

    private bool isSnapshot_;
    /// <summary>
    /// True if this is a snapshot (all previously known quotes and Order Details for this contract should be cleaned).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsSnapshot {
      get { if ((_hasBits0 & 2) != 0) { return isSnapshot_; } else { return IsSnapshotDefaultValue; } }
      set {
        _hasBits0 |= 2;
        isSnapshot_ = value;
      }
    }
    /// <summary>Gets whether the "is_snapshot" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasIsSnapshot {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "is_snapshot" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearIsSnapshot() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "collapsing_level" field.</summary>
    public const int CollapsingLevelFieldNumber = 4;
    private readonly static uint CollapsingLevelDefaultValue = 0;

    private uint collapsingLevel_;
    /// <summary>
    /// Collapsing level that was applied by server.
    /// NONE if the field is omitted.
    /// This field is associated with RealTimeCollapsingLevel enum type.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint CollapsingLevel {
      get { if ((_hasBits0 & 4) != 0) { return collapsingLevel_; } else { return CollapsingLevelDefaultValue; } }
      set {
        _hasBits0 |= 4;
        collapsingLevel_ = value;
      }
    }
    /// <summary>Gets whether the "collapsing_level" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasCollapsingLevel {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "collapsing_level" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearCollapsingLevel() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "market_values" field.</summary>
    public const int MarketValuesFieldNumber = 5;
    private static readonly pb::FieldCodec<global::MarketData2.MarketValues> _repeated_marketValues_codec
        = pb::FieldCodec.ForMessage(42, global::MarketData2.MarketValues.Parser);
    private readonly pbc::RepeatedField<global::MarketData2.MarketValues> marketValues_ = new pbc::RepeatedField<global::MarketData2.MarketValues>();
    /// <summary>
    /// Market values of a contract (e.g. Open/High/Low/Close) for several past trading days.
    /// Present in snapshots and in updates if some values are changed (only changed values are included in updates).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::MarketData2.MarketValues> MarketValues {
      get { return marketValues_; }
    }

    /// <summary>Field number for the "detailed_dom" field.</summary>
    public const int DetailedDomFieldNumber = 16;
    private global::MarketData2.DetailedDOM detailedDom_;
    /// <summary>
    /// Detailed DOM for LEVEL_TRADES_BBA_DETAILED_DOM subscription level.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::MarketData2.DetailedDOM DetailedDom {
      get { return detailedDom_; }
      set {
        detailedDom_ = value;
      }
    }

    /// <summary>Field number for the "requests_for_quotation" field.</summary>
    public const int RequestsForQuotationFieldNumber = 6;
    private static readonly pb::FieldCodec<global::MarketData2.RFQ> _repeated_requestsForQuotation_codec
        = pb::FieldCodec.ForMessage(50, global::MarketData2.RFQ.Parser);
    private readonly pbc::RepeatedField<global::MarketData2.RFQ> requestsForQuotation_ = new pbc::RepeatedField<global::MarketData2.RFQ>();
    /// <summary>
    /// List of RFQs.
    /// Never presents in snapshots, can be provided in updates only.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::MarketData2.RFQ> RequestsForQuotation {
      get { return requestsForQuotation_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as RealTimeMarketData);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(RealTimeMarketData other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (ContractId != other.ContractId) return false;
      if(!quotes_.Equals(other.quotes_)) return false;
      if (IsSnapshot != other.IsSnapshot) return false;
      if (CollapsingLevel != other.CollapsingLevel) return false;
      if(!marketValues_.Equals(other.marketValues_)) return false;
      if (!object.Equals(DetailedDom, other.DetailedDom)) return false;
      if(!requestsForQuotation_.Equals(other.requestsForQuotation_)) return false;
      if (!Equals(_extensions, other._extensions)) {
        return false;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasContractId) hash ^= ContractId.GetHashCode();
      hash ^= quotes_.GetHashCode();
      if (HasIsSnapshot) hash ^= IsSnapshot.GetHashCode();
      if (HasCollapsingLevel) hash ^= CollapsingLevel.GetHashCode();
      hash ^= marketValues_.GetHashCode();
      if (detailedDom_ != null) hash ^= DetailedDom.GetHashCode();
      hash ^= requestsForQuotation_.GetHashCode();
      if (_extensions != null) {
        hash ^= _extensions.GetHashCode();
      }
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasContractId) {
        output.WriteRawTag(8);
        output.WriteUInt32(ContractId);
      }
      quotes_.WriteTo(output, _repeated_quotes_codec);
      if (HasIsSnapshot) {
        output.WriteRawTag(24);
        output.WriteBool(IsSnapshot);
      }
      if (HasCollapsingLevel) {
        output.WriteRawTag(32);
        output.WriteUInt32(CollapsingLevel);
      }
      marketValues_.WriteTo(output, _repeated_marketValues_codec);
      requestsForQuotation_.WriteTo(output, _repeated_requestsForQuotation_codec);
      if (detailedDom_ != null) {
        output.WriteRawTag(130, 1);
        output.WriteMessage(DetailedDom);
      }
      if (_extensions != null) {
        _extensions.WriteTo(output);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasContractId) {
        output.WriteRawTag(8);
        output.WriteUInt32(ContractId);
      }
      quotes_.WriteTo(ref output, _repeated_quotes_codec);
      if (HasIsSnapshot) {
        output.WriteRawTag(24);
        output.WriteBool(IsSnapshot);
      }
      if (HasCollapsingLevel) {
        output.WriteRawTag(32);
        output.WriteUInt32(CollapsingLevel);
      }
      marketValues_.WriteTo(ref output, _repeated_marketValues_codec);
      requestsForQuotation_.WriteTo(ref output, _repeated_requestsForQuotation_codec);
      if (detailedDom_ != null) {
        output.WriteRawTag(130, 1);
        output.WriteMessage(DetailedDom);
      }
      if (_extensions != null) {
        _extensions.WriteTo(ref output);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (HasContractId) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(ContractId);
      }
      size += quotes_.CalculateSize(_repeated_quotes_codec);
      if (HasIsSnapshot) {
        size += 1 + 1;
      }
      if (HasCollapsingLevel) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(CollapsingLevel);
      }
      size += marketValues_.CalculateSize(_repeated_marketValues_codec);
      if (detailedDom_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(DetailedDom);
      }
      size += requestsForQuotation_.CalculateSize(_repeated_requestsForQuotation_codec);
      if (_extensions != null) {
        size += _extensions.CalculateSize();
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(RealTimeMarketData other) {
      if (other == null) {
        return;
      }
      if (other.HasContractId) {
        ContractId = other.ContractId;
      }
      quotes_.Add(other.quotes_);
      if (other.HasIsSnapshot) {
        IsSnapshot = other.IsSnapshot;
      }
      if (other.HasCollapsingLevel) {
        CollapsingLevel = other.CollapsingLevel;
      }
      marketValues_.Add(other.marketValues_);
      if (other.detailedDom_ != null) {
        if (detailedDom_ == null) {
          DetailedDom = new global::MarketData2.DetailedDOM();
        }
        DetailedDom.MergeFrom(other.DetailedDom);
      }
      requestsForQuotation_.Add(other.requestsForQuotation_);
      pb::ExtensionSet.MergeFrom(ref _extensions, other._extensions);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, input)) {
              _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            }
            break;
          case 8: {
            ContractId = input.ReadUInt32();
            break;
          }
          case 18: {
            quotes_.AddEntriesFrom(input, _repeated_quotes_codec);
            break;
          }
          case 24: {
            IsSnapshot = input.ReadBool();
            break;
          }
          case 32: {
            CollapsingLevel = input.ReadUInt32();
            break;
          }
          case 42: {
            marketValues_.AddEntriesFrom(input, _repeated_marketValues_codec);
            break;
          }
          case 50: {
            requestsForQuotation_.AddEntriesFrom(input, _repeated_requestsForQuotation_codec);
            break;
          }
          case 130: {
            if (detailedDom_ == null) {
              DetailedDom = new global::MarketData2.DetailedDOM();
            }
            input.ReadMessage(DetailedDom);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, ref input)) {
              _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            }
            break;
          case 8: {
            ContractId = input.ReadUInt32();
            break;
          }
          case 18: {
            quotes_.AddEntriesFrom(ref input, _repeated_quotes_codec);
            break;
          }
          case 24: {
            IsSnapshot = input.ReadBool();
            break;
          }
          case 32: {
            CollapsingLevel = input.ReadUInt32();
            break;
          }
          case 42: {
            marketValues_.AddEntriesFrom(ref input, _repeated_marketValues_codec);
            break;
          }
          case 50: {
            requestsForQuotation_.AddEntriesFrom(ref input, _repeated_requestsForQuotation_codec);
            break;
          }
          case 130: {
            if (detailedDom_ == null) {
              DetailedDom = new global::MarketData2.DetailedDOM();
            }
            input.ReadMessage(DetailedDom);
            break;
          }
        }
      }
    }
    #endif

    public TValue GetExtension<TValue>(pb::Extension<RealTimeMarketData, TValue> extension) {
      return pb::ExtensionSet.Get(ref _extensions, extension);
    }
    public pbc::RepeatedField<TValue> GetExtension<TValue>(pb::RepeatedExtension<RealTimeMarketData, TValue> extension) {
      return pb::ExtensionSet.Get(ref _extensions, extension);
    }
    public pbc::RepeatedField<TValue> GetOrInitializeExtension<TValue>(pb::RepeatedExtension<RealTimeMarketData, TValue> extension) {
      return pb::ExtensionSet.GetOrInitialize(ref _extensions, extension);
    }
    public void SetExtension<TValue>(pb::Extension<RealTimeMarketData, TValue> extension, TValue value) {
      pb::ExtensionSet.Set(ref _extensions, extension, value);
    }
    public bool HasExtension<TValue>(pb::Extension<RealTimeMarketData, TValue> extension) {
      return pb::ExtensionSet.Has(ref _extensions, extension);
    }
    public void ClearExtension<TValue>(pb::Extension<RealTimeMarketData, TValue> extension) {
      pb::ExtensionSet.Clear(ref _extensions, extension);
    }
    public void ClearExtension<TValue>(pb::RepeatedExtension<RealTimeMarketData, TValue> extension) {
      pb::ExtensionSet.Clear(ref _extensions, extension);
    }

  }

  /// <summary>
  /// Specific quote information
  /// </summary>
  public sealed partial class Quote : pb::IMessage<Quote>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Quote> _parser = new pb::MessageParser<Quote>(() => new Quote());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Quote> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::MarketData2.MarketData2Reflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Quote() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Quote(Quote other) : this() {
      _hasBits0 = other._hasBits0;
      type_ = other.type_;
      quoteUtcTime_ = other.quoteUtcTime_;
      scaledPrice_ = other.scaledPrice_;
      scaledSourcePrice_ = other.scaledSourcePrice_;
      priceYield_ = other.priceYield_;
      scaledVolume_ = other.scaledVolume_;
      indicators_ = other.indicators_.Clone();
      salesCondition_ = other.salesCondition_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Quote Clone() {
      return new Quote(this);
    }

    /// <summary>Field number for the "type" field.</summary>
    public const int TypeFieldNumber = 1;
    private readonly static uint TypeDefaultValue = 0;

    private uint type_;
    /// <summary>
    /// This field is associated with Type enum type.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint Type {
      get { if ((_hasBits0 & 1) != 0) { return type_; } else { return TypeDefaultValue; } }
      set {
        _hasBits0 |= 1;
        type_ = value;
      }
    }
    /// <summary>Gets whether the "type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasType {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearType() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "quote_utc_time" field.</summary>
    public const int QuoteUtcTimeFieldNumber = 2;
    private readonly static long QuoteUtcTimeDefaultValue = 0L;

    private long quoteUtcTime_;
    /// <summary>
    /// Time of the quote (UTC).
    /// If time of first quote is not specified quote_utc_times are unknown.
    /// Settlement quotes may not have quote_utc_time(even if past_quotes_included=True).
    /// If time of snapshot quotes is required, subscribe with include_past_quotes(subscription may be slower).
    /// If MarketDataSubscriptionStatus returned with flag past_quotes_included, quotes shall contain valid quote_utc_time.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long QuoteUtcTime {
      get { if ((_hasBits0 & 2) != 0) { return quoteUtcTime_; } else { return QuoteUtcTimeDefaultValue; } }
      set {
        _hasBits0 |= 2;
        quoteUtcTime_ = value;
      }
    }
    /// <summary>Gets whether the "quote_utc_time" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasQuoteUtcTime {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "quote_utc_time" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearQuoteUtcTime() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "scaled_price" field.</summary>
    public const int ScaledPriceFieldNumber = 3;
    private readonly static int ScaledPriceDefaultValue = 0;

    private int scaledPrice_;
    /// <summary>
    /// Quote price.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int ScaledPrice {
      get { if ((_hasBits0 & 4) != 0) { return scaledPrice_; } else { return ScaledPriceDefaultValue; } }
      set {
        _hasBits0 |= 4;
        scaledPrice_ = value;
      }
    }
    /// <summary>Gets whether the "scaled_price" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasScaledPrice {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "scaled_price" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearScaledPrice() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "scaled_source_price" field.</summary>
    public const int ScaledSourcePriceFieldNumber = 8;
    private readonly static int ScaledSourcePriceDefaultValue = 0;

    private int scaledSourcePrice_;
    /// <summary>
    /// Source contract quote price. See MarketDataSubscription.include_source_prices.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int ScaledSourcePrice {
      get { if ((_hasBits0 & 64) != 0) { return scaledSourcePrice_; } else { return ScaledSourcePriceDefaultValue; } }
      set {
        _hasBits0 |= 64;
        scaledSourcePrice_ = value;
      }
    }
    /// <summary>Gets whether the "scaled_source_price" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasScaledSourcePrice {
      get { return (_hasBits0 & 64) != 0; }
    }
    /// <summary>Clears the value of the "scaled_source_price" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearScaledSourcePrice() {
      _hasBits0 &= ~64;
    }

    /// <summary>Field number for the "price_yield" field.</summary>
    public const int PriceYieldFieldNumber = 6;
    private readonly static double PriceYieldDefaultValue = 0D;

    private double priceYield_;
    /// <summary>
    /// Yield
    /// Included if subscribed and the contract support yields.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double PriceYield {
      get { if ((_hasBits0 & 16) != 0) { return priceYield_; } else { return PriceYieldDefaultValue; } }
      set {
        _hasBits0 |= 16;
        priceYield_ = value;
      }
    }
    /// <summary>Gets whether the "price_yield" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasPriceYield {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "price_yield" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearPriceYield() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "scaled_volume" field.</summary>
    public const int ScaledVolumeFieldNumber = 4;
    private readonly static ulong ScaledVolumeDefaultValue = 0UL;

    private ulong scaledVolume_;
    /// <summary>
    /// Quote volume (included for BBA only if volume is subscribed).
    /// Zero volume for a bid or ask indicates it has been cleared.  It can be a best price and a part of DOM update.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ulong ScaledVolume {
      get { if ((_hasBits0 & 8) != 0) { return scaledVolume_; } else { return ScaledVolumeDefaultValue; } }
      set {
        _hasBits0 |= 8;
        scaledVolume_ = value;
      }
    }
    /// <summary>Gets whether the "scaled_volume" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasScaledVolume {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "scaled_volume" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearScaledVolume() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "indicators" field.</summary>
    public const int IndicatorsFieldNumber = 5;
    private static readonly pb::FieldCodec<uint> _repeated_indicators_codec
        = pb::FieldCodec.ForUInt32(40);
    private readonly pbc::RepeatedField<uint> indicators_ = new pbc::RepeatedField<uint>();
    /// <summary>
    /// This field is associated with Indicator enum type.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<uint> Indicators {
      get { return indicators_; }
    }

    /// <summary>Field number for the "sales_condition" field.</summary>
    public const int SalesConditionFieldNumber = 7;
    private readonly static uint SalesConditionDefaultValue = 0;

    private uint salesCondition_;
    /// <summary>
    /// This field is associated with SalesCondition enum type.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint SalesCondition {
      get { if ((_hasBits0 & 32) != 0) { return salesCondition_; } else { return SalesConditionDefaultValue; } }
      set {
        _hasBits0 |= 32;
        salesCondition_ = value;
      }
    }
    /// <summary>Gets whether the "sales_condition" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasSalesCondition {
      get { return (_hasBits0 & 32) != 0; }
    }
    /// <summary>Clears the value of the "sales_condition" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearSalesCondition() {
      _hasBits0 &= ~32;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Quote);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Quote other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Type != other.Type) return false;
      if (QuoteUtcTime != other.QuoteUtcTime) return false;
      if (ScaledPrice != other.ScaledPrice) return false;
      if (ScaledSourcePrice != other.ScaledSourcePrice) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(PriceYield, other.PriceYield)) return false;
      if (ScaledVolume != other.ScaledVolume) return false;
      if(!indicators_.Equals(other.indicators_)) return false;
      if (SalesCondition != other.SalesCondition) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasType) hash ^= Type.GetHashCode();
      if (HasQuoteUtcTime) hash ^= QuoteUtcTime.GetHashCode();
      if (HasScaledPrice) hash ^= ScaledPrice.GetHashCode();
      if (HasScaledSourcePrice) hash ^= ScaledSourcePrice.GetHashCode();
      if (HasPriceYield) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(PriceYield);
      if (HasScaledVolume) hash ^= ScaledVolume.GetHashCode();
      hash ^= indicators_.GetHashCode();
      if (HasSalesCondition) hash ^= SalesCondition.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasType) {
        output.WriteRawTag(8);
        output.WriteUInt32(Type);
      }
      if (HasQuoteUtcTime) {
        output.WriteRawTag(16);
        output.WriteSInt64(QuoteUtcTime);
      }
      if (HasScaledPrice) {
        output.WriteRawTag(24);
        output.WriteSInt32(ScaledPrice);
      }
      if (HasScaledVolume) {
        output.WriteRawTag(32);
        output.WriteUInt64(ScaledVolume);
      }
      indicators_.WriteTo(output, _repeated_indicators_codec);
      if (HasPriceYield) {
        output.WriteRawTag(49);
        output.WriteDouble(PriceYield);
      }
      if (HasSalesCondition) {
        output.WriteRawTag(56);
        output.WriteUInt32(SalesCondition);
      }
      if (HasScaledSourcePrice) {
        output.WriteRawTag(64);
        output.WriteSInt32(ScaledSourcePrice);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasType) {
        output.WriteRawTag(8);
        output.WriteUInt32(Type);
      }
      if (HasQuoteUtcTime) {
        output.WriteRawTag(16);
        output.WriteSInt64(QuoteUtcTime);
      }
      if (HasScaledPrice) {
        output.WriteRawTag(24);
        output.WriteSInt32(ScaledPrice);
      }
      if (HasScaledVolume) {
        output.WriteRawTag(32);
        output.WriteUInt64(ScaledVolume);
      }
      indicators_.WriteTo(ref output, _repeated_indicators_codec);
      if (HasPriceYield) {
        output.WriteRawTag(49);
        output.WriteDouble(PriceYield);
      }
      if (HasSalesCondition) {
        output.WriteRawTag(56);
        output.WriteUInt32(SalesCondition);
      }
      if (HasScaledSourcePrice) {
        output.WriteRawTag(64);
        output.WriteSInt32(ScaledSourcePrice);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (HasType) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Type);
      }
      if (HasQuoteUtcTime) {
        size += 1 + pb::CodedOutputStream.ComputeSInt64Size(QuoteUtcTime);
      }
      if (HasScaledPrice) {
        size += 1 + pb::CodedOutputStream.ComputeSInt32Size(ScaledPrice);
      }
      if (HasScaledSourcePrice) {
        size += 1 + pb::CodedOutputStream.ComputeSInt32Size(ScaledSourcePrice);
      }
      if (HasPriceYield) {
        size += 1 + 8;
      }
      if (HasScaledVolume) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(ScaledVolume);
      }
      size += indicators_.CalculateSize(_repeated_indicators_codec);
      if (HasSalesCondition) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(SalesCondition);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Quote other) {
      if (other == null) {
        return;
      }
      if (other.HasType) {
        Type = other.Type;
      }
      if (other.HasQuoteUtcTime) {
        QuoteUtcTime = other.QuoteUtcTime;
      }
      if (other.HasScaledPrice) {
        ScaledPrice = other.ScaledPrice;
      }
      if (other.HasScaledSourcePrice) {
        ScaledSourcePrice = other.ScaledSourcePrice;
      }
      if (other.HasPriceYield) {
        PriceYield = other.PriceYield;
      }
      if (other.HasScaledVolume) {
        ScaledVolume = other.ScaledVolume;
      }
      indicators_.Add(other.indicators_);
      if (other.HasSalesCondition) {
        SalesCondition = other.SalesCondition;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Type = input.ReadUInt32();
            break;
          }
          case 16: {
            QuoteUtcTime = input.ReadSInt64();
            break;
          }
          case 24: {
            ScaledPrice = input.ReadSInt32();
            break;
          }
          case 32: {
            ScaledVolume = input.ReadUInt64();
            break;
          }
          case 42:
          case 40: {
            indicators_.AddEntriesFrom(input, _repeated_indicators_codec);
            break;
          }
          case 49: {
            PriceYield = input.ReadDouble();
            break;
          }
          case 56: {
            SalesCondition = input.ReadUInt32();
            break;
          }
          case 64: {
            ScaledSourcePrice = input.ReadSInt32();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Type = input.ReadUInt32();
            break;
          }
          case 16: {
            QuoteUtcTime = input.ReadSInt64();
            break;
          }
          case 24: {
            ScaledPrice = input.ReadSInt32();
            break;
          }
          case 32: {
            ScaledVolume = input.ReadUInt64();
            break;
          }
          case 42:
          case 40: {
            indicators_.AddEntriesFrom(ref input, _repeated_indicators_codec);
            break;
          }
          case 49: {
            PriceYield = input.ReadDouble();
            break;
          }
          case 56: {
            SalesCondition = input.ReadUInt32();
            break;
          }
          case 64: {
            ScaledSourcePrice = input.ReadSInt32();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the Quote message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// Type of the quote.
      /// </summary>
      public enum Type {
        /// <summary>
        /// Trade quote.
        /// </summary>
        [pbr::OriginalName("TYPE_TRADE")] Trade = 0,
        /// <summary>
        /// Best bid quote.
        /// Note that best bid/ask quotes are not guaranteed to be consistent with bid/ask quotes in the short
        /// term. Thus, best bid/ask quotes must not be used to update DOM.
        /// </summary>
        [pbr::OriginalName("TYPE_BESTBID")] Bestbid = 1,
        /// <summary>
        /// Best ask quote.
        /// See the note for TYPE_BESTBID.
        /// </summary>
        [pbr::OriginalName("TYPE_BESTASK")] Bestask = 2,
        /// <summary>
        /// Bid quote (DOM level).
        /// </summary>
        [pbr::OriginalName("TYPE_BID")] Bid = 3,
        /// <summary>
        /// Ask quote (DOM level).
        /// </summary>
        [pbr::OriginalName("TYPE_ASK")] Ask = 4,
        /// <summary>
        /// Settlement quote.
        /// </summary>
        [pbr::OriginalName("TYPE_SETTLEMENT")] Settlement = 5,
        /// <summary>
        /// Best discretionary bid quote.
        /// See the note for TYPE_BESTBID.
        /// Note: volume from discretionary quote is also included in a corresponding regular quote,
        /// but there is no guarantee they are consistent in the short term.
        /// </summary>
        [pbr::OriginalName("TYPE_BESTDISCRBID")] Bestdiscrbid = 6,
        /// <summary>
        /// Best discretionary ask quote.
        /// See the note for TYPE_BESTDISCRBID.
        /// </summary>
        [pbr::OriginalName("TYPE_BESTDISCRASK")] Bestdiscrask = 7,
        /// <summary>
        /// Discretionary bid quote (DOM level).
        /// See the note for TYPE_BESTDISCRBID.
        /// </summary>
        [pbr::OriginalName("TYPE_DISCRBID")] Discrbid = 8,
        /// <summary>
        /// Discretionary ask quote (DOM level).
        /// See the note for TYPE_BESTDISCRBID.
        /// </summary>
        [pbr::OriginalName("TYPE_DISCRASK")] Discrask = 9,
      }

      /// <summary>
      /// Optional indicator(s) (e.g. this quote also updates some of Open/High/Low/Close session prices).
      /// </summary>
      public enum Indicator {
        /// <summary>
        /// Price of this quote is a new open price of the contract session.
        /// </summary>
        [pbr::OriginalName("INDICATOR_OPEN")] Open = 1,
        /// <summary>
        /// Price of this quote is a new high price of the contract session.
        /// </summary>
        [pbr::OriginalName("INDICATOR_HIGH")] High = 2,
        /// <summary>
        /// Price of this quote is a new low price of the contract session.
        /// </summary>
        [pbr::OriginalName("INDICATOR_LOW")] Low = 3,
        /// <summary>
        /// Price of this quote is a new close price of the contract session.
        /// </summary>
        [pbr::OriginalName("INDICATOR_CLOSE")] Close = 4,
        /// <summary>
        /// This quote doesn't belong to current trading day.
        /// </summary>
        [pbr::OriginalName("INDICATOR_PAST")] Past = 5,
        /// <summary>
        /// Quote is generated from another one.
        /// E.g. for contracts with PricingFallBack contributor parameter set to 1 if there is no best ask,
        /// but there is a trade, trade price is sent as a best ask with this indicator along with the trade.
        /// </summary>
        [pbr::OriginalName("INDICATOR_FALL_BACK_TO_TRADE_OR_SETTLEMENT")] FallBackToTradeOrSettlement = 6,
      }

      /// <summary>
      /// Optional sales condition of the quote.
      /// </summary>
      public enum SalesCondition {
        /// <summary>
        /// Hit trade.
        /// </summary>
        [pbr::OriginalName("SALES_CONDITION_HIT")] Hit = 1,
        /// <summary>
        /// Take trade.
        /// </summary>
        [pbr::OriginalName("SALES_CONDITION_TAKE")] Take = 2,
        /// <summary>
        /// One leg of a spread.
        /// </summary>
        [pbr::OriginalName("SALES_CONDITION_SPREAD_LEG")] SpreadLeg = 3,
        /// <summary>
        /// The market participant was the originator of the transaction.
        /// He completes trade on buy with price matched by latest Best Ask price.
        /// </summary>
        [pbr::OriginalName("SALES_CONDITION_BUY_SIDE_AGGRESSOR")] BuySideAggressor = 4,
        /// <summary>
        /// The market participant was the originator of the transaction.
        /// He completes trade on sell with price matched by latest Best Bid price.
        /// </summary>
        [pbr::OriginalName("SALES_CONDITION_SELL_SIDE_AGGRESSOR")] SellSideAggressor = 5,
      }

    }
    #endregion

  }

  /// <summary>
  /// Market data values of a contract.
  /// </summary>
  public sealed partial class MarketValues : pb::IMessage<MarketValues>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<MarketValues> _parser = new pb::MessageParser<MarketValues>(() => new MarketValues());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<MarketValues> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::MarketData2.MarketData2Reflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public MarketValues() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public MarketValues(MarketValues other) : this() {
      _hasBits0 = other._hasBits0;
      scaledOpenPrice_ = other.scaledOpenPrice_;
      scaledHighPrice_ = other.scaledHighPrice_;
      scaledLowPrice_ = other.scaledLowPrice_;
      scaledClosePrice_ = other.scaledClosePrice_;
      scaledYesterdaySettlement_ = other.scaledYesterdaySettlement_;
      scaledTotalVolume_ = other.scaledTotalVolume_;
      scaledYesterdayClose_ = other.scaledYesterdayClose_;
      scaledIndicativeOpen_ = other.scaledIndicativeOpen_;
      scaledIndicativeOpenVolume_ = other.scaledIndicativeOpenVolume_;
      dayIndex_ = other.dayIndex_;
      scaledOpenInterest_ = other.scaledOpenInterest_;
      tickVolume_ = other.tickVolume_;
      scaledSettlement_ = other.scaledSettlement_;
      scaledMarkerPrice_ = other.scaledMarkerPrice_;
      clearedFields_ = other.clearedFields_.Clone();
      tradeDate_ = other.tradeDate_;
      sessionIndex_ = other.sessionIndex_;
      marketYields_ = other.marketYields_ != null ? other.marketYields_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public MarketValues Clone() {
      return new MarketValues(this);
    }

    /// <summary>Field number for the "scaled_open_price" field.</summary>
    public const int ScaledOpenPriceFieldNumber = 1;
    private readonly static int ScaledOpenPriceDefaultValue = 0;

    private int scaledOpenPrice_;
    /// <summary>
    /// Open price.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int ScaledOpenPrice {
      get { if ((_hasBits0 & 1) != 0) { return scaledOpenPrice_; } else { return ScaledOpenPriceDefaultValue; } }
      set {
        _hasBits0 |= 1;
        scaledOpenPrice_ = value;
      }
    }
    /// <summary>Gets whether the "scaled_open_price" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasScaledOpenPrice {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "scaled_open_price" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearScaledOpenPrice() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "scaled_high_price" field.</summary>
    public const int ScaledHighPriceFieldNumber = 2;
    private readonly static int ScaledHighPriceDefaultValue = 0;

    private int scaledHighPrice_;
    /// <summary>
    /// High price.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int ScaledHighPrice {
      get { if ((_hasBits0 & 2) != 0) { return scaledHighPrice_; } else { return ScaledHighPriceDefaultValue; } }
      set {
        _hasBits0 |= 2;
        scaledHighPrice_ = value;
      }
    }
    /// <summary>Gets whether the "scaled_high_price" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasScaledHighPrice {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "scaled_high_price" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearScaledHighPrice() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "scaled_low_price" field.</summary>
    public const int ScaledLowPriceFieldNumber = 3;
    private readonly static int ScaledLowPriceDefaultValue = 0;

    private int scaledLowPrice_;
    /// <summary>
    /// Low price.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int ScaledLowPrice {
      get { if ((_hasBits0 & 4) != 0) { return scaledLowPrice_; } else { return ScaledLowPriceDefaultValue; } }
      set {
        _hasBits0 |= 4;
        scaledLowPrice_ = value;
      }
    }
    /// <summary>Gets whether the "scaled_low_price" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasScaledLowPrice {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "scaled_low_price" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearScaledLowPrice() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "scaled_close_price" field.</summary>
    public const int ScaledClosePriceFieldNumber = 4;
    private readonly static int ScaledClosePriceDefaultValue = 0;

    private int scaledClosePrice_;
    /// <summary>
    /// Close price.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int ScaledClosePrice {
      get { if ((_hasBits0 & 8) != 0) { return scaledClosePrice_; } else { return ScaledClosePriceDefaultValue; } }
      set {
        _hasBits0 |= 8;
        scaledClosePrice_ = value;
      }
    }
    /// <summary>Gets whether the "scaled_close_price" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasScaledClosePrice {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "scaled_close_price" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearScaledClosePrice() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "scaled_yesterday_settlement" field.</summary>
    public const int ScaledYesterdaySettlementFieldNumber = 5;
    private readonly static int ScaledYesterdaySettlementDefaultValue = 0;

    private int scaledYesterdaySettlement_;
    /// <summary>
    /// Yesterday settlement price.
    /// NOTE: Available for current trading day only.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int ScaledYesterdaySettlement {
      get { if ((_hasBits0 & 16) != 0) { return scaledYesterdaySettlement_; } else { return ScaledYesterdaySettlementDefaultValue; } }
      set {
        _hasBits0 |= 16;
        scaledYesterdaySettlement_ = value;
      }
    }
    /// <summary>Gets whether the "scaled_yesterday_settlement" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasScaledYesterdaySettlement {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "scaled_yesterday_settlement" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearScaledYesterdaySettlement() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "scaled_total_volume" field.</summary>
    public const int ScaledTotalVolumeFieldNumber = 6;
    private readonly static ulong ScaledTotalVolumeDefaultValue = 0UL;

    private ulong scaledTotalVolume_;
    /// <summary>
    /// Contract total volume.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ulong ScaledTotalVolume {
      get { if ((_hasBits0 & 32) != 0) { return scaledTotalVolume_; } else { return ScaledTotalVolumeDefaultValue; } }
      set {
        _hasBits0 |= 32;
        scaledTotalVolume_ = value;
      }
    }
    /// <summary>Gets whether the "scaled_total_volume" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasScaledTotalVolume {
      get { return (_hasBits0 & 32) != 0; }
    }
    /// <summary>Clears the value of the "scaled_total_volume" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearScaledTotalVolume() {
      _hasBits0 &= ~32;
    }

    /// <summary>Field number for the "scaled_yesterday_close" field.</summary>
    public const int ScaledYesterdayCloseFieldNumber = 7;
    private readonly static int ScaledYesterdayCloseDefaultValue = 0;

    private int scaledYesterdayClose_;
    /// <summary>
    /// Yesterday close price.
    /// NOTE: Available for current trading day only.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int ScaledYesterdayClose {
      get { if ((_hasBits0 & 64) != 0) { return scaledYesterdayClose_; } else { return ScaledYesterdayCloseDefaultValue; } }
      set {
        _hasBits0 |= 64;
        scaledYesterdayClose_ = value;
      }
    }
    /// <summary>Gets whether the "scaled_yesterday_close" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasScaledYesterdayClose {
      get { return (_hasBits0 & 64) != 0; }
    }
    /// <summary>Clears the value of the "scaled_yesterday_close" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearScaledYesterdayClose() {
      _hasBits0 &= ~64;
    }

    /// <summary>Field number for the "scaled_indicative_open" field.</summary>
    public const int ScaledIndicativeOpenFieldNumber = 8;
    private readonly static int ScaledIndicativeOpenDefaultValue = 0;

    private int scaledIndicativeOpen_;
    /// <summary>
    /// Indicative open price.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int ScaledIndicativeOpen {
      get { if ((_hasBits0 & 128) != 0) { return scaledIndicativeOpen_; } else { return ScaledIndicativeOpenDefaultValue; } }
      set {
        _hasBits0 |= 128;
        scaledIndicativeOpen_ = value;
      }
    }
    /// <summary>Gets whether the "scaled_indicative_open" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasScaledIndicativeOpen {
      get { return (_hasBits0 & 128) != 0; }
    }
    /// <summary>Clears the value of the "scaled_indicative_open" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearScaledIndicativeOpen() {
      _hasBits0 &= ~128;
    }

    /// <summary>Field number for the "scaled_indicative_open_volume" field.</summary>
    public const int ScaledIndicativeOpenVolumeFieldNumber = 15;
    private readonly static ulong ScaledIndicativeOpenVolumeDefaultValue = 0UL;

    private ulong scaledIndicativeOpenVolume_;
    /// <summary>
    /// Indicative open volume.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ulong ScaledIndicativeOpenVolume {
      get { if ((_hasBits0 & 8192) != 0) { return scaledIndicativeOpenVolume_; } else { return ScaledIndicativeOpenVolumeDefaultValue; } }
      set {
        _hasBits0 |= 8192;
        scaledIndicativeOpenVolume_ = value;
      }
    }
    /// <summary>Gets whether the "scaled_indicative_open_volume" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasScaledIndicativeOpenVolume {
      get { return (_hasBits0 & 8192) != 0; }
    }
    /// <summary>Clears the value of the "scaled_indicative_open_volume" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearScaledIndicativeOpenVolume() {
      _hasBits0 &= ~8192;
    }

    /// <summary>Field number for the "day_index" field.</summary>
    public const int DayIndexFieldNumber = 9;
    private readonly static int DayIndexDefaultValue = 0;

    private int dayIndex_;
    /// <summary>
    /// Day index the market values are related to.
    /// 0 - current trading day, -1 - yesterday's trading day, etc.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int DayIndex {
      get { if ((_hasBits0 & 256) != 0) { return dayIndex_; } else { return DayIndexDefaultValue; } }
      set {
        _hasBits0 |= 256;
        dayIndex_ = value;
      }
    }
    /// <summary>Gets whether the "day_index" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasDayIndex {
      get { return (_hasBits0 & 256) != 0; }
    }
    /// <summary>Clears the value of the "day_index" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearDayIndex() {
      _hasBits0 &= ~256;
    }

    /// <summary>Field number for the "scaled_open_interest" field.</summary>
    public const int ScaledOpenInterestFieldNumber = 10;
    private readonly static long ScaledOpenInterestDefaultValue = 0L;

    private long scaledOpenInterest_;
    /// <summary>
    /// Open interest.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long ScaledOpenInterest {
      get { if ((_hasBits0 & 512) != 0) { return scaledOpenInterest_; } else { return ScaledOpenInterestDefaultValue; } }
      set {
        _hasBits0 |= 512;
        scaledOpenInterest_ = value;
      }
    }
    /// <summary>Gets whether the "scaled_open_interest" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasScaledOpenInterest {
      get { return (_hasBits0 & 512) != 0; }
    }
    /// <summary>Clears the value of the "scaled_open_interest" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearScaledOpenInterest() {
      _hasBits0 &= ~512;
    }

    /// <summary>Field number for the "tick_volume" field.</summary>
    public const int TickVolumeFieldNumber = 11;
    private readonly static uint TickVolumeDefaultValue = 0;

    private uint tickVolume_;
    /// <summary>
    /// Contract tick volume.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint TickVolume {
      get { if ((_hasBits0 & 1024) != 0) { return tickVolume_; } else { return TickVolumeDefaultValue; } }
      set {
        _hasBits0 |= 1024;
        tickVolume_ = value;
      }
    }
    /// <summary>Gets whether the "tick_volume" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasTickVolume {
      get { return (_hasBits0 & 1024) != 0; }
    }
    /// <summary>Clears the value of the "tick_volume" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearTickVolume() {
      _hasBits0 &= ~1024;
    }

    /// <summary>Field number for the "scaled_settlement" field.</summary>
    public const int ScaledSettlementFieldNumber = 12;
    private readonly static int ScaledSettlementDefaultValue = 0;

    private int scaledSettlement_;
    /// <summary>
    /// Settlement price.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int ScaledSettlement {
      get { if ((_hasBits0 & 2048) != 0) { return scaledSettlement_; } else { return ScaledSettlementDefaultValue; } }
      set {
        _hasBits0 |= 2048;
        scaledSettlement_ = value;
      }
    }
    /// <summary>Gets whether the "scaled_settlement" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasScaledSettlement {
      get { return (_hasBits0 & 2048) != 0; }
    }
    /// <summary>Clears the value of the "scaled_settlement" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearScaledSettlement() {
      _hasBits0 &= ~2048;
    }

    /// <summary>Field number for the "scaled_marker_price" field.</summary>
    public const int ScaledMarkerPriceFieldNumber = 18;
    private readonly static int ScaledMarkerPriceDefaultValue = 0;

    private int scaledMarkerPrice_;
    /// <summary>
    /// Marker price.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int ScaledMarkerPrice {
      get { if ((_hasBits0 & 32768) != 0) { return scaledMarkerPrice_; } else { return ScaledMarkerPriceDefaultValue; } }
      set {
        _hasBits0 |= 32768;
        scaledMarkerPrice_ = value;
      }
    }
    /// <summary>Gets whether the "scaled_marker_price" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasScaledMarkerPrice {
      get { return (_hasBits0 & 32768) != 0; }
    }
    /// <summary>Clears the value of the "scaled_marker_price" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearScaledMarkerPrice() {
      _hasBits0 &= ~32768;
    }

    /// <summary>Field number for the "cleared_fields" field.</summary>
    public const int ClearedFieldsFieldNumber = 13;
    private static readonly pb::FieldCodec<uint> _repeated_clearedFields_codec
        = pb::FieldCodec.ForUInt32(104);
    private readonly pbc::RepeatedField<uint> clearedFields_ = new pbc::RepeatedField<uint>();
    /// <summary>
    /// Identifiers of fields being cleared.
    /// It also specifies to clear corresponding yield values in market_yields.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<uint> ClearedFields {
      get { return clearedFields_; }
    }

    /// <summary>Field number for the "trade_date" field.</summary>
    public const int TradeDateFieldNumber = 14;
    private readonly static long TradeDateDefaultValue = 0L;

    private long tradeDate_;
    /// <summary>
    /// Trading date the market values belong to.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long TradeDate {
      get { if ((_hasBits0 & 4096) != 0) { return tradeDate_; } else { return TradeDateDefaultValue; } }
      set {
        _hasBits0 |= 4096;
        tradeDate_ = value;
      }
    }
    /// <summary>Gets whether the "trade_date" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasTradeDate {
      get { return (_hasBits0 & 4096) != 0; }
    }
    /// <summary>Clears the value of the "trade_date" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearTradeDate() {
      _hasBits0 &= ~4096;
    }

    /// <summary>Field number for the "session_index" field.</summary>
    public const int SessionIndexFieldNumber = 17;
    private readonly static uint SessionIndexDefaultValue = 0;

    private uint sessionIndex_;
    /// <summary>
    /// Session index the market values are related to.
    /// 0 - first session of the day, 1 - second session of the day, etc.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint SessionIndex {
      get { if ((_hasBits0 & 16384) != 0) { return sessionIndex_; } else { return SessionIndexDefaultValue; } }
      set {
        _hasBits0 |= 16384;
        sessionIndex_ = value;
      }
    }
    /// <summary>Gets whether the "session_index" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasSessionIndex {
      get { return (_hasBits0 & 16384) != 0; }
    }
    /// <summary>Clears the value of the "session_index" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearSessionIndex() {
      _hasBits0 &= ~16384;
    }

    /// <summary>Field number for the "market_yields" field.</summary>
    public const int MarketYieldsFieldNumber = 16;
    private global::MarketData2.MarketYields marketYields_;
    /// <summary>
    /// Market yields.
    /// Included if subscribed and the contract support yields.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::MarketData2.MarketYields MarketYields {
      get { return marketYields_; }
      set {
        marketYields_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as MarketValues);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(MarketValues other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (ScaledOpenPrice != other.ScaledOpenPrice) return false;
      if (ScaledHighPrice != other.ScaledHighPrice) return false;
      if (ScaledLowPrice != other.ScaledLowPrice) return false;
      if (ScaledClosePrice != other.ScaledClosePrice) return false;
      if (ScaledYesterdaySettlement != other.ScaledYesterdaySettlement) return false;
      if (ScaledTotalVolume != other.ScaledTotalVolume) return false;
      if (ScaledYesterdayClose != other.ScaledYesterdayClose) return false;
      if (ScaledIndicativeOpen != other.ScaledIndicativeOpen) return false;
      if (ScaledIndicativeOpenVolume != other.ScaledIndicativeOpenVolume) return false;
      if (DayIndex != other.DayIndex) return false;
      if (ScaledOpenInterest != other.ScaledOpenInterest) return false;
      if (TickVolume != other.TickVolume) return false;
      if (ScaledSettlement != other.ScaledSettlement) return false;
      if (ScaledMarkerPrice != other.ScaledMarkerPrice) return false;
      if(!clearedFields_.Equals(other.clearedFields_)) return false;
      if (TradeDate != other.TradeDate) return false;
      if (SessionIndex != other.SessionIndex) return false;
      if (!object.Equals(MarketYields, other.MarketYields)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasScaledOpenPrice) hash ^= ScaledOpenPrice.GetHashCode();
      if (HasScaledHighPrice) hash ^= ScaledHighPrice.GetHashCode();
      if (HasScaledLowPrice) hash ^= ScaledLowPrice.GetHashCode();
      if (HasScaledClosePrice) hash ^= ScaledClosePrice.GetHashCode();
      if (HasScaledYesterdaySettlement) hash ^= ScaledYesterdaySettlement.GetHashCode();
      if (HasScaledTotalVolume) hash ^= ScaledTotalVolume.GetHashCode();
      if (HasScaledYesterdayClose) hash ^= ScaledYesterdayClose.GetHashCode();
      if (HasScaledIndicativeOpen) hash ^= ScaledIndicativeOpen.GetHashCode();
      if (HasScaledIndicativeOpenVolume) hash ^= ScaledIndicativeOpenVolume.GetHashCode();
      if (HasDayIndex) hash ^= DayIndex.GetHashCode();
      if (HasScaledOpenInterest) hash ^= ScaledOpenInterest.GetHashCode();
      if (HasTickVolume) hash ^= TickVolume.GetHashCode();
      if (HasScaledSettlement) hash ^= ScaledSettlement.GetHashCode();
      if (HasScaledMarkerPrice) hash ^= ScaledMarkerPrice.GetHashCode();
      hash ^= clearedFields_.GetHashCode();
      if (HasTradeDate) hash ^= TradeDate.GetHashCode();
      if (HasSessionIndex) hash ^= SessionIndex.GetHashCode();
      if (marketYields_ != null) hash ^= MarketYields.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasScaledOpenPrice) {
        output.WriteRawTag(8);
        output.WriteSInt32(ScaledOpenPrice);
      }
      if (HasScaledHighPrice) {
        output.WriteRawTag(16);
        output.WriteSInt32(ScaledHighPrice);
      }
      if (HasScaledLowPrice) {
        output.WriteRawTag(24);
        output.WriteSInt32(ScaledLowPrice);
      }
      if (HasScaledClosePrice) {
        output.WriteRawTag(32);
        output.WriteSInt32(ScaledClosePrice);
      }
      if (HasScaledYesterdaySettlement) {
        output.WriteRawTag(40);
        output.WriteSInt32(ScaledYesterdaySettlement);
      }
      if (HasScaledTotalVolume) {
        output.WriteRawTag(48);
        output.WriteUInt64(ScaledTotalVolume);
      }
      if (HasScaledYesterdayClose) {
        output.WriteRawTag(56);
        output.WriteSInt32(ScaledYesterdayClose);
      }
      if (HasScaledIndicativeOpen) {
        output.WriteRawTag(64);
        output.WriteSInt32(ScaledIndicativeOpen);
      }
      if (HasDayIndex) {
        output.WriteRawTag(72);
        output.WriteSInt32(DayIndex);
      }
      if (HasScaledOpenInterest) {
        output.WriteRawTag(80);
        output.WriteSInt64(ScaledOpenInterest);
      }
      if (HasTickVolume) {
        output.WriteRawTag(88);
        output.WriteUInt32(TickVolume);
      }
      if (HasScaledSettlement) {
        output.WriteRawTag(96);
        output.WriteSInt32(ScaledSettlement);
      }
      clearedFields_.WriteTo(output, _repeated_clearedFields_codec);
      if (HasTradeDate) {
        output.WriteRawTag(112);
        output.WriteSInt64(TradeDate);
      }
      if (HasScaledIndicativeOpenVolume) {
        output.WriteRawTag(120);
        output.WriteUInt64(ScaledIndicativeOpenVolume);
      }
      if (marketYields_ != null) {
        output.WriteRawTag(130, 1);
        output.WriteMessage(MarketYields);
      }
      if (HasSessionIndex) {
        output.WriteRawTag(136, 1);
        output.WriteUInt32(SessionIndex);
      }
      if (HasScaledMarkerPrice) {
        output.WriteRawTag(144, 1);
        output.WriteSInt32(ScaledMarkerPrice);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasScaledOpenPrice) {
        output.WriteRawTag(8);
        output.WriteSInt32(ScaledOpenPrice);
      }
      if (HasScaledHighPrice) {
        output.WriteRawTag(16);
        output.WriteSInt32(ScaledHighPrice);
      }
      if (HasScaledLowPrice) {
        output.WriteRawTag(24);
        output.WriteSInt32(ScaledLowPrice);
      }
      if (HasScaledClosePrice) {
        output.WriteRawTag(32);
        output.WriteSInt32(ScaledClosePrice);
      }
      if (HasScaledYesterdaySettlement) {
        output.WriteRawTag(40);
        output.WriteSInt32(ScaledYesterdaySettlement);
      }
      if (HasScaledTotalVolume) {
        output.WriteRawTag(48);
        output.WriteUInt64(ScaledTotalVolume);
      }
      if (HasScaledYesterdayClose) {
        output.WriteRawTag(56);
        output.WriteSInt32(ScaledYesterdayClose);
      }
      if (HasScaledIndicativeOpen) {
        output.WriteRawTag(64);
        output.WriteSInt32(ScaledIndicativeOpen);
      }
      if (HasDayIndex) {
        output.WriteRawTag(72);
        output.WriteSInt32(DayIndex);
      }
      if (HasScaledOpenInterest) {
        output.WriteRawTag(80);
        output.WriteSInt64(ScaledOpenInterest);
      }
      if (HasTickVolume) {
        output.WriteRawTag(88);
        output.WriteUInt32(TickVolume);
      }
      if (HasScaledSettlement) {
        output.WriteRawTag(96);
        output.WriteSInt32(ScaledSettlement);
      }
      clearedFields_.WriteTo(ref output, _repeated_clearedFields_codec);
      if (HasTradeDate) {
        output.WriteRawTag(112);
        output.WriteSInt64(TradeDate);
      }
      if (HasScaledIndicativeOpenVolume) {
        output.WriteRawTag(120);
        output.WriteUInt64(ScaledIndicativeOpenVolume);
      }
      if (marketYields_ != null) {
        output.WriteRawTag(130, 1);
        output.WriteMessage(MarketYields);
      }
      if (HasSessionIndex) {
        output.WriteRawTag(136, 1);
        output.WriteUInt32(SessionIndex);
      }
      if (HasScaledMarkerPrice) {
        output.WriteRawTag(144, 1);
        output.WriteSInt32(ScaledMarkerPrice);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (HasScaledOpenPrice) {
        size += 1 + pb::CodedOutputStream.ComputeSInt32Size(ScaledOpenPrice);
      }
      if (HasScaledHighPrice) {
        size += 1 + pb::CodedOutputStream.ComputeSInt32Size(ScaledHighPrice);
      }
      if (HasScaledLowPrice) {
        size += 1 + pb::CodedOutputStream.ComputeSInt32Size(ScaledLowPrice);
      }
      if (HasScaledClosePrice) {
        size += 1 + pb::CodedOutputStream.ComputeSInt32Size(ScaledClosePrice);
      }
      if (HasScaledYesterdaySettlement) {
        size += 1 + pb::CodedOutputStream.ComputeSInt32Size(ScaledYesterdaySettlement);
      }
      if (HasScaledTotalVolume) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(ScaledTotalVolume);
      }
      if (HasScaledYesterdayClose) {
        size += 1 + pb::CodedOutputStream.ComputeSInt32Size(ScaledYesterdayClose);
      }
      if (HasScaledIndicativeOpen) {
        size += 1 + pb::CodedOutputStream.ComputeSInt32Size(ScaledIndicativeOpen);
      }
      if (HasScaledIndicativeOpenVolume) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(ScaledIndicativeOpenVolume);
      }
      if (HasDayIndex) {
        size += 1 + pb::CodedOutputStream.ComputeSInt32Size(DayIndex);
      }
      if (HasScaledOpenInterest) {
        size += 1 + pb::CodedOutputStream.ComputeSInt64Size(ScaledOpenInterest);
      }
      if (HasTickVolume) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(TickVolume);
      }
      if (HasScaledSettlement) {
        size += 1 + pb::CodedOutputStream.ComputeSInt32Size(ScaledSettlement);
      }
      if (HasScaledMarkerPrice) {
        size += 2 + pb::CodedOutputStream.ComputeSInt32Size(ScaledMarkerPrice);
      }
      size += clearedFields_.CalculateSize(_repeated_clearedFields_codec);
      if (HasTradeDate) {
        size += 1 + pb::CodedOutputStream.ComputeSInt64Size(TradeDate);
      }
      if (HasSessionIndex) {
        size += 2 + pb::CodedOutputStream.ComputeUInt32Size(SessionIndex);
      }
      if (marketYields_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(MarketYields);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(MarketValues other) {
      if (other == null) {
        return;
      }
      if (other.HasScaledOpenPrice) {
        ScaledOpenPrice = other.ScaledOpenPrice;
      }
      if (other.HasScaledHighPrice) {
        ScaledHighPrice = other.ScaledHighPrice;
      }
      if (other.HasScaledLowPrice) {
        ScaledLowPrice = other.ScaledLowPrice;
      }
      if (other.HasScaledClosePrice) {
        ScaledClosePrice = other.ScaledClosePrice;
      }
      if (other.HasScaledYesterdaySettlement) {
        ScaledYesterdaySettlement = other.ScaledYesterdaySettlement;
      }
      if (other.HasScaledTotalVolume) {
        ScaledTotalVolume = other.ScaledTotalVolume;
      }
      if (other.HasScaledYesterdayClose) {
        ScaledYesterdayClose = other.ScaledYesterdayClose;
      }
      if (other.HasScaledIndicativeOpen) {
        ScaledIndicativeOpen = other.ScaledIndicativeOpen;
      }
      if (other.HasScaledIndicativeOpenVolume) {
        ScaledIndicativeOpenVolume = other.ScaledIndicativeOpenVolume;
      }
      if (other.HasDayIndex) {
        DayIndex = other.DayIndex;
      }
      if (other.HasScaledOpenInterest) {
        ScaledOpenInterest = other.ScaledOpenInterest;
      }
      if (other.HasTickVolume) {
        TickVolume = other.TickVolume;
      }
      if (other.HasScaledSettlement) {
        ScaledSettlement = other.ScaledSettlement;
      }
      if (other.HasScaledMarkerPrice) {
        ScaledMarkerPrice = other.ScaledMarkerPrice;
      }
      clearedFields_.Add(other.clearedFields_);
      if (other.HasTradeDate) {
        TradeDate = other.TradeDate;
      }
      if (other.HasSessionIndex) {
        SessionIndex = other.SessionIndex;
      }
      if (other.marketYields_ != null) {
        if (marketYields_ == null) {
          MarketYields = new global::MarketData2.MarketYields();
        }
        MarketYields.MergeFrom(other.MarketYields);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            ScaledOpenPrice = input.ReadSInt32();
            break;
          }
          case 16: {
            ScaledHighPrice = input.ReadSInt32();
            break;
          }
          case 24: {
            ScaledLowPrice = input.ReadSInt32();
            break;
          }
          case 32: {
            ScaledClosePrice = input.ReadSInt32();
            break;
          }
          case 40: {
            ScaledYesterdaySettlement = input.ReadSInt32();
            break;
          }
          case 48: {
            ScaledTotalVolume = input.ReadUInt64();
            break;
          }
          case 56: {
            ScaledYesterdayClose = input.ReadSInt32();
            break;
          }
          case 64: {
            ScaledIndicativeOpen = input.ReadSInt32();
            break;
          }
          case 72: {
            DayIndex = input.ReadSInt32();
            break;
          }
          case 80: {
            ScaledOpenInterest = input.ReadSInt64();
            break;
          }
          case 88: {
            TickVolume = input.ReadUInt32();
            break;
          }
          case 96: {
            ScaledSettlement = input.ReadSInt32();
            break;
          }
          case 106:
          case 104: {
            clearedFields_.AddEntriesFrom(input, _repeated_clearedFields_codec);
            break;
          }
          case 112: {
            TradeDate = input.ReadSInt64();
            break;
          }
          case 120: {
            ScaledIndicativeOpenVolume = input.ReadUInt64();
            break;
          }
          case 130: {
            if (marketYields_ == null) {
              MarketYields = new global::MarketData2.MarketYields();
            }
            input.ReadMessage(MarketYields);
            break;
          }
          case 136: {
            SessionIndex = input.ReadUInt32();
            break;
          }
          case 144: {
            ScaledMarkerPrice = input.ReadSInt32();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            ScaledOpenPrice = input.ReadSInt32();
            break;
          }
          case 16: {
            ScaledHighPrice = input.ReadSInt32();
            break;
          }
          case 24: {
            ScaledLowPrice = input.ReadSInt32();
            break;
          }
          case 32: {
            ScaledClosePrice = input.ReadSInt32();
            break;
          }
          case 40: {
            ScaledYesterdaySettlement = input.ReadSInt32();
            break;
          }
          case 48: {
            ScaledTotalVolume = input.ReadUInt64();
            break;
          }
          case 56: {
            ScaledYesterdayClose = input.ReadSInt32();
            break;
          }
          case 64: {
            ScaledIndicativeOpen = input.ReadSInt32();
            break;
          }
          case 72: {
            DayIndex = input.ReadSInt32();
            break;
          }
          case 80: {
            ScaledOpenInterest = input.ReadSInt64();
            break;
          }
          case 88: {
            TickVolume = input.ReadUInt32();
            break;
          }
          case 96: {
            ScaledSettlement = input.ReadSInt32();
            break;
          }
          case 106:
          case 104: {
            clearedFields_.AddEntriesFrom(ref input, _repeated_clearedFields_codec);
            break;
          }
          case 112: {
            TradeDate = input.ReadSInt64();
            break;
          }
          case 120: {
            ScaledIndicativeOpenVolume = input.ReadUInt64();
            break;
          }
          case 130: {
            if (marketYields_ == null) {
              MarketYields = new global::MarketData2.MarketYields();
            }
            input.ReadMessage(MarketYields);
            break;
          }
          case 136: {
            SessionIndex = input.ReadUInt32();
            break;
          }
          case 144: {
            ScaledMarkerPrice = input.ReadSInt32();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Market yields of a contract.
  /// </summary>
  public sealed partial class MarketYields : pb::IMessage<MarketYields>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<MarketYields> _parser = new pb::MessageParser<MarketYields>(() => new MarketYields());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<MarketYields> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::MarketData2.MarketData2Reflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public MarketYields() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public MarketYields(MarketYields other) : this() {
      _hasBits0 = other._hasBits0;
      yieldOfOpenPrice_ = other.yieldOfOpenPrice_;
      yieldOfHighPrice_ = other.yieldOfHighPrice_;
      yieldOfLowPrice_ = other.yieldOfLowPrice_;
      yieldOfClosePrice_ = other.yieldOfClosePrice_;
      yieldOfYesterdaySettlement_ = other.yieldOfYesterdaySettlement_;
      yieldOfYesterdayClose_ = other.yieldOfYesterdayClose_;
      yieldOfIndicativeOpen_ = other.yieldOfIndicativeOpen_;
      yieldOfSettlement_ = other.yieldOfSettlement_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public MarketYields Clone() {
      return new MarketYields(this);
    }

    /// <summary>Field number for the "yield_of_open_price" field.</summary>
    public const int YieldOfOpenPriceFieldNumber = 1;
    private readonly static double YieldOfOpenPriceDefaultValue = 0D;

    private double yieldOfOpenPrice_;
    /// <summary>
    /// Yield corresponding to open price.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double YieldOfOpenPrice {
      get { if ((_hasBits0 & 1) != 0) { return yieldOfOpenPrice_; } else { return YieldOfOpenPriceDefaultValue; } }
      set {
        _hasBits0 |= 1;
        yieldOfOpenPrice_ = value;
      }
    }
    /// <summary>Gets whether the "yield_of_open_price" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasYieldOfOpenPrice {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "yield_of_open_price" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearYieldOfOpenPrice() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "yield_of_high_price" field.</summary>
    public const int YieldOfHighPriceFieldNumber = 2;
    private readonly static double YieldOfHighPriceDefaultValue = 0D;

    private double yieldOfHighPrice_;
    /// <summary>
    /// Yield corresponding to high price.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double YieldOfHighPrice {
      get { if ((_hasBits0 & 2) != 0) { return yieldOfHighPrice_; } else { return YieldOfHighPriceDefaultValue; } }
      set {
        _hasBits0 |= 2;
        yieldOfHighPrice_ = value;
      }
    }
    /// <summary>Gets whether the "yield_of_high_price" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasYieldOfHighPrice {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "yield_of_high_price" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearYieldOfHighPrice() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "yield_of_low_price" field.</summary>
    public const int YieldOfLowPriceFieldNumber = 3;
    private readonly static double YieldOfLowPriceDefaultValue = 0D;

    private double yieldOfLowPrice_;
    /// <summary>
    /// Yield corresponding to low price.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double YieldOfLowPrice {
      get { if ((_hasBits0 & 4) != 0) { return yieldOfLowPrice_; } else { return YieldOfLowPriceDefaultValue; } }
      set {
        _hasBits0 |= 4;
        yieldOfLowPrice_ = value;
      }
    }
    /// <summary>Gets whether the "yield_of_low_price" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasYieldOfLowPrice {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "yield_of_low_price" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearYieldOfLowPrice() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "yield_of_close_price" field.</summary>
    public const int YieldOfClosePriceFieldNumber = 4;
    private readonly static double YieldOfClosePriceDefaultValue = 0D;

    private double yieldOfClosePrice_;
    /// <summary>
    /// Yield corresponding to close price.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double YieldOfClosePrice {
      get { if ((_hasBits0 & 8) != 0) { return yieldOfClosePrice_; } else { return YieldOfClosePriceDefaultValue; } }
      set {
        _hasBits0 |= 8;
        yieldOfClosePrice_ = value;
      }
    }
    /// <summary>Gets whether the "yield_of_close_price" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasYieldOfClosePrice {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "yield_of_close_price" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearYieldOfClosePrice() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "yield_of_yesterday_settlement" field.</summary>
    public const int YieldOfYesterdaySettlementFieldNumber = 5;
    private readonly static double YieldOfYesterdaySettlementDefaultValue = 0D;

    private double yieldOfYesterdaySettlement_;
    /// <summary>
    /// Yesterday settlement yield.
    /// NOTE: Available for current trading day only.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double YieldOfYesterdaySettlement {
      get { if ((_hasBits0 & 16) != 0) { return yieldOfYesterdaySettlement_; } else { return YieldOfYesterdaySettlementDefaultValue; } }
      set {
        _hasBits0 |= 16;
        yieldOfYesterdaySettlement_ = value;
      }
    }
    /// <summary>Gets whether the "yield_of_yesterday_settlement" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasYieldOfYesterdaySettlement {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "yield_of_yesterday_settlement" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearYieldOfYesterdaySettlement() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "yield_of_yesterday_close" field.</summary>
    public const int YieldOfYesterdayCloseFieldNumber = 6;
    private readonly static double YieldOfYesterdayCloseDefaultValue = 0D;

    private double yieldOfYesterdayClose_;
    /// <summary>
    /// Yesterday close yield.
    /// NOTE: Available for current trading day only.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double YieldOfYesterdayClose {
      get { if ((_hasBits0 & 32) != 0) { return yieldOfYesterdayClose_; } else { return YieldOfYesterdayCloseDefaultValue; } }
      set {
        _hasBits0 |= 32;
        yieldOfYesterdayClose_ = value;
      }
    }
    /// <summary>Gets whether the "yield_of_yesterday_close" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasYieldOfYesterdayClose {
      get { return (_hasBits0 & 32) != 0; }
    }
    /// <summary>Clears the value of the "yield_of_yesterday_close" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearYieldOfYesterdayClose() {
      _hasBits0 &= ~32;
    }

    /// <summary>Field number for the "yield_of_indicative_open" field.</summary>
    public const int YieldOfIndicativeOpenFieldNumber = 7;
    private readonly static double YieldOfIndicativeOpenDefaultValue = 0D;

    private double yieldOfIndicativeOpen_;
    /// <summary>
    /// Indicative open yield.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double YieldOfIndicativeOpen {
      get { if ((_hasBits0 & 64) != 0) { return yieldOfIndicativeOpen_; } else { return YieldOfIndicativeOpenDefaultValue; } }
      set {
        _hasBits0 |= 64;
        yieldOfIndicativeOpen_ = value;
      }
    }
    /// <summary>Gets whether the "yield_of_indicative_open" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasYieldOfIndicativeOpen {
      get { return (_hasBits0 & 64) != 0; }
    }
    /// <summary>Clears the value of the "yield_of_indicative_open" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearYieldOfIndicativeOpen() {
      _hasBits0 &= ~64;
    }

    /// <summary>Field number for the "yield_of_settlement" field.</summary>
    public const int YieldOfSettlementFieldNumber = 8;
    private readonly static double YieldOfSettlementDefaultValue = 0D;

    private double yieldOfSettlement_;
    /// <summary>
    /// Settlement yield.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double YieldOfSettlement {
      get { if ((_hasBits0 & 128) != 0) { return yieldOfSettlement_; } else { return YieldOfSettlementDefaultValue; } }
      set {
        _hasBits0 |= 128;
        yieldOfSettlement_ = value;
      }
    }
    /// <summary>Gets whether the "yield_of_settlement" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasYieldOfSettlement {
      get { return (_hasBits0 & 128) != 0; }
    }
    /// <summary>Clears the value of the "yield_of_settlement" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearYieldOfSettlement() {
      _hasBits0 &= ~128;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as MarketYields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(MarketYields other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(YieldOfOpenPrice, other.YieldOfOpenPrice)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(YieldOfHighPrice, other.YieldOfHighPrice)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(YieldOfLowPrice, other.YieldOfLowPrice)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(YieldOfClosePrice, other.YieldOfClosePrice)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(YieldOfYesterdaySettlement, other.YieldOfYesterdaySettlement)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(YieldOfYesterdayClose, other.YieldOfYesterdayClose)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(YieldOfIndicativeOpen, other.YieldOfIndicativeOpen)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(YieldOfSettlement, other.YieldOfSettlement)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasYieldOfOpenPrice) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(YieldOfOpenPrice);
      if (HasYieldOfHighPrice) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(YieldOfHighPrice);
      if (HasYieldOfLowPrice) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(YieldOfLowPrice);
      if (HasYieldOfClosePrice) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(YieldOfClosePrice);
      if (HasYieldOfYesterdaySettlement) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(YieldOfYesterdaySettlement);
      if (HasYieldOfYesterdayClose) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(YieldOfYesterdayClose);
      if (HasYieldOfIndicativeOpen) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(YieldOfIndicativeOpen);
      if (HasYieldOfSettlement) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(YieldOfSettlement);
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasYieldOfOpenPrice) {
        output.WriteRawTag(9);
        output.WriteDouble(YieldOfOpenPrice);
      }
      if (HasYieldOfHighPrice) {
        output.WriteRawTag(17);
        output.WriteDouble(YieldOfHighPrice);
      }
      if (HasYieldOfLowPrice) {
        output.WriteRawTag(25);
        output.WriteDouble(YieldOfLowPrice);
      }
      if (HasYieldOfClosePrice) {
        output.WriteRawTag(33);
        output.WriteDouble(YieldOfClosePrice);
      }
      if (HasYieldOfYesterdaySettlement) {
        output.WriteRawTag(41);
        output.WriteDouble(YieldOfYesterdaySettlement);
      }
      if (HasYieldOfYesterdayClose) {
        output.WriteRawTag(49);
        output.WriteDouble(YieldOfYesterdayClose);
      }
      if (HasYieldOfIndicativeOpen) {
        output.WriteRawTag(57);
        output.WriteDouble(YieldOfIndicativeOpen);
      }
      if (HasYieldOfSettlement) {
        output.WriteRawTag(65);
        output.WriteDouble(YieldOfSettlement);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasYieldOfOpenPrice) {
        output.WriteRawTag(9);
        output.WriteDouble(YieldOfOpenPrice);
      }
      if (HasYieldOfHighPrice) {
        output.WriteRawTag(17);
        output.WriteDouble(YieldOfHighPrice);
      }
      if (HasYieldOfLowPrice) {
        output.WriteRawTag(25);
        output.WriteDouble(YieldOfLowPrice);
      }
      if (HasYieldOfClosePrice) {
        output.WriteRawTag(33);
        output.WriteDouble(YieldOfClosePrice);
      }
      if (HasYieldOfYesterdaySettlement) {
        output.WriteRawTag(41);
        output.WriteDouble(YieldOfYesterdaySettlement);
      }
      if (HasYieldOfYesterdayClose) {
        output.WriteRawTag(49);
        output.WriteDouble(YieldOfYesterdayClose);
      }
      if (HasYieldOfIndicativeOpen) {
        output.WriteRawTag(57);
        output.WriteDouble(YieldOfIndicativeOpen);
      }
      if (HasYieldOfSettlement) {
        output.WriteRawTag(65);
        output.WriteDouble(YieldOfSettlement);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (HasYieldOfOpenPrice) {
        size += 1 + 8;
      }
      if (HasYieldOfHighPrice) {
        size += 1 + 8;
      }
      if (HasYieldOfLowPrice) {
        size += 1 + 8;
      }
      if (HasYieldOfClosePrice) {
        size += 1 + 8;
      }
      if (HasYieldOfYesterdaySettlement) {
        size += 1 + 8;
      }
      if (HasYieldOfYesterdayClose) {
        size += 1 + 8;
      }
      if (HasYieldOfIndicativeOpen) {
        size += 1 + 8;
      }
      if (HasYieldOfSettlement) {
        size += 1 + 8;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(MarketYields other) {
      if (other == null) {
        return;
      }
      if (other.HasYieldOfOpenPrice) {
        YieldOfOpenPrice = other.YieldOfOpenPrice;
      }
      if (other.HasYieldOfHighPrice) {
        YieldOfHighPrice = other.YieldOfHighPrice;
      }
      if (other.HasYieldOfLowPrice) {
        YieldOfLowPrice = other.YieldOfLowPrice;
      }
      if (other.HasYieldOfClosePrice) {
        YieldOfClosePrice = other.YieldOfClosePrice;
      }
      if (other.HasYieldOfYesterdaySettlement) {
        YieldOfYesterdaySettlement = other.YieldOfYesterdaySettlement;
      }
      if (other.HasYieldOfYesterdayClose) {
        YieldOfYesterdayClose = other.YieldOfYesterdayClose;
      }
      if (other.HasYieldOfIndicativeOpen) {
        YieldOfIndicativeOpen = other.YieldOfIndicativeOpen;
      }
      if (other.HasYieldOfSettlement) {
        YieldOfSettlement = other.YieldOfSettlement;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 9: {
            YieldOfOpenPrice = input.ReadDouble();
            break;
          }
          case 17: {
            YieldOfHighPrice = input.ReadDouble();
            break;
          }
          case 25: {
            YieldOfLowPrice = input.ReadDouble();
            break;
          }
          case 33: {
            YieldOfClosePrice = input.ReadDouble();
            break;
          }
          case 41: {
            YieldOfYesterdaySettlement = input.ReadDouble();
            break;
          }
          case 49: {
            YieldOfYesterdayClose = input.ReadDouble();
            break;
          }
          case 57: {
            YieldOfIndicativeOpen = input.ReadDouble();
            break;
          }
          case 65: {
            YieldOfSettlement = input.ReadDouble();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 9: {
            YieldOfOpenPrice = input.ReadDouble();
            break;
          }
          case 17: {
            YieldOfHighPrice = input.ReadDouble();
            break;
          }
          case 25: {
            YieldOfLowPrice = input.ReadDouble();
            break;
          }
          case 33: {
            YieldOfClosePrice = input.ReadDouble();
            break;
          }
          case 41: {
            YieldOfYesterdaySettlement = input.ReadDouble();
            break;
          }
          case 49: {
            YieldOfYesterdayClose = input.ReadDouble();
            break;
          }
          case 57: {
            YieldOfIndicativeOpen = input.ReadDouble();
            break;
          }
          case 65: {
            YieldOfSettlement = input.ReadDouble();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Request at-the-money strike for the option maturity.
  /// </summary>
  public sealed partial class AtTheMoneyStrikeRequest : pb::IMessage<AtTheMoneyStrikeRequest>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<AtTheMoneyStrikeRequest> _parser = new pb::MessageParser<AtTheMoneyStrikeRequest>(() => new AtTheMoneyStrikeRequest());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<AtTheMoneyStrikeRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::MarketData2.MarketData2Reflection.Descriptor.MessageTypes[6]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AtTheMoneyStrikeRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AtTheMoneyStrikeRequest(AtTheMoneyStrikeRequest other) : this() {
      optionMaturitySymbolId_ = other.optionMaturitySymbolId_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AtTheMoneyStrikeRequest Clone() {
      return new AtTheMoneyStrikeRequest(this);
    }

    /// <summary>Field number for the "option_maturity_symbol_id" field.</summary>
    public const int OptionMaturitySymbolIdFieldNumber = 1;
    private readonly static string OptionMaturitySymbolIdDefaultValue = "";

    private string optionMaturitySymbolId_;
    /// <summary>
    /// Option maturity symbol id representing the parent symbol for the option strike list of the same underlying and maturity period (see Symbol.id).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string OptionMaturitySymbolId {
      get { return optionMaturitySymbolId_ ?? OptionMaturitySymbolIdDefaultValue; }
      set {
        optionMaturitySymbolId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "option_maturity_symbol_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasOptionMaturitySymbolId {
      get { return optionMaturitySymbolId_ != null; }
    }
    /// <summary>Clears the value of the "option_maturity_symbol_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearOptionMaturitySymbolId() {
      optionMaturitySymbolId_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as AtTheMoneyStrikeRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(AtTheMoneyStrikeRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (OptionMaturitySymbolId != other.OptionMaturitySymbolId) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasOptionMaturitySymbolId) hash ^= OptionMaturitySymbolId.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasOptionMaturitySymbolId) {
        output.WriteRawTag(10);
        output.WriteString(OptionMaturitySymbolId);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasOptionMaturitySymbolId) {
        output.WriteRawTag(10);
        output.WriteString(OptionMaturitySymbolId);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (HasOptionMaturitySymbolId) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(OptionMaturitySymbolId);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(AtTheMoneyStrikeRequest other) {
      if (other == null) {
        return;
      }
      if (other.HasOptionMaturitySymbolId) {
        OptionMaturitySymbolId = other.OptionMaturitySymbolId;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            OptionMaturitySymbolId = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            OptionMaturitySymbolId = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Report with at-the-money strikes.
  /// </summary>
  public sealed partial class AtTheMoneyStrikeReport : pb::IMessage<AtTheMoneyStrikeReport>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<AtTheMoneyStrikeReport> _parser = new pb::MessageParser<AtTheMoneyStrikeReport>(() => new AtTheMoneyStrikeReport());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<AtTheMoneyStrikeReport> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::MarketData2.MarketData2Reflection.Descriptor.MessageTypes[7]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AtTheMoneyStrikeReport() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AtTheMoneyStrikeReport(AtTheMoneyStrikeReport other) : this() {
      _hasBits0 = other._hasBits0;
      strike_ = other.strike_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AtTheMoneyStrikeReport Clone() {
      return new AtTheMoneyStrikeReport(this);
    }

    /// <summary>Field number for the "strike" field.</summary>
    public const int StrikeFieldNumber = 1;
    private readonly static int StrikeDefaultValue = 0;

    private int strike_;
    /// <summary>
    /// Option at-the-money strike.
    /// It is omitted if at-the-money strike cannot be calculated at the moment (e.g. due to lack of real time data).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int Strike {
      get { if ((_hasBits0 & 1) != 0) { return strike_; } else { return StrikeDefaultValue; } }
      set {
        _hasBits0 |= 1;
        strike_ = value;
      }
    }
    /// <summary>Gets whether the "strike" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasStrike {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "strike" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearStrike() {
      _hasBits0 &= ~1;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as AtTheMoneyStrikeReport);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(AtTheMoneyStrikeReport other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Strike != other.Strike) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasStrike) hash ^= Strike.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasStrike) {
        output.WriteRawTag(8);
        output.WriteSInt32(Strike);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasStrike) {
        output.WriteRawTag(8);
        output.WriteSInt32(Strike);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (HasStrike) {
        size += 1 + pb::CodedOutputStream.ComputeSInt32Size(Strike);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(AtTheMoneyStrikeReport other) {
      if (other == null) {
        return;
      }
      if (other.HasStrike) {
        Strike = other.Strike;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Strike = input.ReadSInt32();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Strike = input.ReadSInt32();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Describes separate orders at price levels.
  /// Detailed DOM updates (snapshot or not) can come in several DetailedDOM messages. The first will have
  /// RealTimeMarketData.is_snapshot set, the rest will come as updates. The last will have
  /// DetailedDOM.is_detailed_dom_complete set.
  /// Update for a price level cannot be split into several messages.
  /// Updates must be applied in the order they listed in.
  /// </summary>
  public sealed partial class DetailedDOM : pb::IMessage<DetailedDOM>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<DetailedDOM> _parser = new pb::MessageParser<DetailedDOM>(() => new DetailedDOM());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<DetailedDOM> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::MarketData2.MarketData2Reflection.Descriptor.MessageTypes[8]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DetailedDOM() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DetailedDOM(DetailedDOM other) : this() {
      _hasBits0 = other._hasBits0;
      isDetailedDomComplete_ = other.isDetailedDomComplete_;
      isStale_ = other.isStale_;
      isSnapshot_ = other.isSnapshot_;
      priceLevels_ = other.priceLevels_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DetailedDOM Clone() {
      return new DetailedDOM(this);
    }

    /// <summary>Field number for the "is_detailed_dom_complete" field.</summary>
    public const int IsDetailedDomCompleteFieldNumber = 1;
    private readonly static bool IsDetailedDomCompleteDefaultValue = false;

    private bool isDetailedDomComplete_;
    /// <summary>
    /// True if this message is the last in the series of DetailedDOM updates (snapshot or not) for a contract.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsDetailedDomComplete {
      get { if ((_hasBits0 & 1) != 0) { return isDetailedDomComplete_; } else { return IsDetailedDomCompleteDefaultValue; } }
      set {
        _hasBits0 |= 1;
        isDetailedDomComplete_ = value;
      }
    }
    /// <summary>Gets whether the "is_detailed_dom_complete" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasIsDetailedDomComplete {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "is_detailed_dom_complete" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearIsDetailedDomComplete() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "is_stale" field.</summary>
    public const int IsStaleFieldNumber = 2;
    private readonly static bool IsStaleDefaultValue = false;

    private bool isStale_;
    /// <summary>
    /// True if the DOM is stale, i.e. has become obsolete and is not being updated at the moment.
    /// A new DetailedDOM message with is_stale = false will be sent when data is fixed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsStale {
      get { if ((_hasBits0 & 2) != 0) { return isStale_; } else { return IsStaleDefaultValue; } }
      set {
        _hasBits0 |= 2;
        isStale_ = value;
      }
    }
    /// <summary>Gets whether the "is_stale" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasIsStale {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "is_stale" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearIsStale() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "is_snapshot" field.</summary>
    public const int IsSnapshotFieldNumber = 3;
    private readonly static bool IsSnapshotDefaultValue = false;

    private bool isSnapshot_;
    /// <summary>
    /// If true, the data for this message should be entirely replaced with 'price_levels' contents.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsSnapshot {
      get { if ((_hasBits0 & 4) != 0) { return isSnapshot_; } else { return IsSnapshotDefaultValue; } }
      set {
        _hasBits0 |= 4;
        isSnapshot_ = value;
      }
    }
    /// <summary>Gets whether the "is_snapshot" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasIsSnapshot {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "is_snapshot" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearIsSnapshot() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "price_levels" field.</summary>
    public const int PriceLevelsFieldNumber = 4;
    private static readonly pb::FieldCodec<global::MarketData2.DetailedDOMAtPrice> _repeated_priceLevels_codec
        = pb::FieldCodec.ForMessage(34, global::MarketData2.DetailedDOMAtPrice.Parser);
    private readonly pbc::RepeatedField<global::MarketData2.DetailedDOMAtPrice> priceLevels_ = new pbc::RepeatedField<global::MarketData2.DetailedDOMAtPrice>();
    /// <summary>
    /// Price level updates.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::MarketData2.DetailedDOMAtPrice> PriceLevels {
      get { return priceLevels_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as DetailedDOM);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(DetailedDOM other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (IsDetailedDomComplete != other.IsDetailedDomComplete) return false;
      if (IsStale != other.IsStale) return false;
      if (IsSnapshot != other.IsSnapshot) return false;
      if(!priceLevels_.Equals(other.priceLevels_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasIsDetailedDomComplete) hash ^= IsDetailedDomComplete.GetHashCode();
      if (HasIsStale) hash ^= IsStale.GetHashCode();
      if (HasIsSnapshot) hash ^= IsSnapshot.GetHashCode();
      hash ^= priceLevels_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasIsDetailedDomComplete) {
        output.WriteRawTag(8);
        output.WriteBool(IsDetailedDomComplete);
      }
      if (HasIsStale) {
        output.WriteRawTag(16);
        output.WriteBool(IsStale);
      }
      if (HasIsSnapshot) {
        output.WriteRawTag(24);
        output.WriteBool(IsSnapshot);
      }
      priceLevels_.WriteTo(output, _repeated_priceLevels_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasIsDetailedDomComplete) {
        output.WriteRawTag(8);
        output.WriteBool(IsDetailedDomComplete);
      }
      if (HasIsStale) {
        output.WriteRawTag(16);
        output.WriteBool(IsStale);
      }
      if (HasIsSnapshot) {
        output.WriteRawTag(24);
        output.WriteBool(IsSnapshot);
      }
      priceLevels_.WriteTo(ref output, _repeated_priceLevels_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (HasIsDetailedDomComplete) {
        size += 1 + 1;
      }
      if (HasIsStale) {
        size += 1 + 1;
      }
      if (HasIsSnapshot) {
        size += 1 + 1;
      }
      size += priceLevels_.CalculateSize(_repeated_priceLevels_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(DetailedDOM other) {
      if (other == null) {
        return;
      }
      if (other.HasIsDetailedDomComplete) {
        IsDetailedDomComplete = other.IsDetailedDomComplete;
      }
      if (other.HasIsStale) {
        IsStale = other.IsStale;
      }
      if (other.HasIsSnapshot) {
        IsSnapshot = other.IsSnapshot;
      }
      priceLevels_.Add(other.priceLevels_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            IsDetailedDomComplete = input.ReadBool();
            break;
          }
          case 16: {
            IsStale = input.ReadBool();
            break;
          }
          case 24: {
            IsSnapshot = input.ReadBool();
            break;
          }
          case 34: {
            priceLevels_.AddEntriesFrom(input, _repeated_priceLevels_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            IsDetailedDomComplete = input.ReadBool();
            break;
          }
          case 16: {
            IsStale = input.ReadBool();
            break;
          }
          case 24: {
            IsSnapshot = input.ReadBool();
            break;
          }
          case 34: {
            priceLevels_.AddEntriesFrom(ref input, _repeated_priceLevels_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Either snapshot of orders at a price level or incremental update.
  /// </summary>
  public sealed partial class DetailedDOMAtPrice : pb::IMessage<DetailedDOMAtPrice>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<DetailedDOMAtPrice> _parser = new pb::MessageParser<DetailedDOMAtPrice>(() => new DetailedDOMAtPrice());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<DetailedDOMAtPrice> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::MarketData2.MarketData2Reflection.Descriptor.MessageTypes[9]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DetailedDOMAtPrice() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DetailedDOMAtPrice(DetailedDOMAtPrice other) : this() {
      _hasBits0 = other._hasBits0;
      scaledPrice_ = other.scaledPrice_;
      side_ = other.side_;
      isSnapshot_ = other.isSnapshot_;
      orders_ = other.orders_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DetailedDOMAtPrice Clone() {
      return new DetailedDOMAtPrice(this);
    }

    /// <summary>Field number for the "scaled_price" field.</summary>
    public const int ScaledPriceFieldNumber = 1;
    private readonly static int ScaledPriceDefaultValue = 0;

    private int scaledPrice_;
    /// <summary>
    /// Price level described by this message.
    /// Price is absent for No-price Orders.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int ScaledPrice {
      get { if ((_hasBits0 & 1) != 0) { return scaledPrice_; } else { return ScaledPriceDefaultValue; } }
      set {
        _hasBits0 |= 1;
        scaledPrice_ = value;
      }
    }
    /// <summary>Gets whether the "scaled_price" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasScaledPrice {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "scaled_price" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearScaledPrice() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "side" field.</summary>
    public const int SideFieldNumber = 2;
    private readonly static uint SideDefaultValue = 0;

    private uint side_;
    /// <summary>
    /// Side of this price level. SIDE_BUY or SIDE_SELL.
    /// This field is associated with Order.Side enum type.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint Side {
      get { if ((_hasBits0 & 2) != 0) { return side_; } else { return SideDefaultValue; } }
      set {
        _hasBits0 |= 2;
        side_ = value;
      }
    }
    /// <summary>Gets whether the "side" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasSide {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "side" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearSide() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "is_snapshot" field.</summary>
    public const int IsSnapshotFieldNumber = 3;
    private readonly static bool IsSnapshotDefaultValue = false;

    private bool isSnapshot_;
    /// <summary>
    /// If true, the data for this price level should be entirely replaced with 'orders' contents.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsSnapshot {
      get { if ((_hasBits0 & 4) != 0) { return isSnapshot_; } else { return IsSnapshotDefaultValue; } }
      set {
        _hasBits0 |= 4;
        isSnapshot_ = value;
      }
    }
    /// <summary>Gets whether the "is_snapshot" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasIsSnapshot {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "is_snapshot" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearIsSnapshot() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "orders" field.</summary>
    public const int OrdersFieldNumber = 4;
    private static readonly pb::FieldCodec<global::MarketData2.DetailedDOMOrder> _repeated_orders_codec
        = pb::FieldCodec.ForMessage(34, global::MarketData2.DetailedDOMOrder.Parser);
    private readonly pbc::RepeatedField<global::MarketData2.DetailedDOMOrder> orders_ = new pbc::RepeatedField<global::MarketData2.DetailedDOMOrder>();
    /// <summary>
    /// All orders at the price level, if is_snapshot is true, or changes to the price level, otherwise.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::MarketData2.DetailedDOMOrder> Orders {
      get { return orders_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as DetailedDOMAtPrice);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(DetailedDOMAtPrice other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (ScaledPrice != other.ScaledPrice) return false;
      if (Side != other.Side) return false;
      if (IsSnapshot != other.IsSnapshot) return false;
      if(!orders_.Equals(other.orders_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasScaledPrice) hash ^= ScaledPrice.GetHashCode();
      if (HasSide) hash ^= Side.GetHashCode();
      if (HasIsSnapshot) hash ^= IsSnapshot.GetHashCode();
      hash ^= orders_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasScaledPrice) {
        output.WriteRawTag(8);
        output.WriteSInt32(ScaledPrice);
      }
      if (HasSide) {
        output.WriteRawTag(16);
        output.WriteUInt32(Side);
      }
      if (HasIsSnapshot) {
        output.WriteRawTag(24);
        output.WriteBool(IsSnapshot);
      }
      orders_.WriteTo(output, _repeated_orders_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasScaledPrice) {
        output.WriteRawTag(8);
        output.WriteSInt32(ScaledPrice);
      }
      if (HasSide) {
        output.WriteRawTag(16);
        output.WriteUInt32(Side);
      }
      if (HasIsSnapshot) {
        output.WriteRawTag(24);
        output.WriteBool(IsSnapshot);
      }
      orders_.WriteTo(ref output, _repeated_orders_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (HasScaledPrice) {
        size += 1 + pb::CodedOutputStream.ComputeSInt32Size(ScaledPrice);
      }
      if (HasSide) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Side);
      }
      if (HasIsSnapshot) {
        size += 1 + 1;
      }
      size += orders_.CalculateSize(_repeated_orders_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(DetailedDOMAtPrice other) {
      if (other == null) {
        return;
      }
      if (other.HasScaledPrice) {
        ScaledPrice = other.ScaledPrice;
      }
      if (other.HasSide) {
        Side = other.Side;
      }
      if (other.HasIsSnapshot) {
        IsSnapshot = other.IsSnapshot;
      }
      orders_.Add(other.orders_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            ScaledPrice = input.ReadSInt32();
            break;
          }
          case 16: {
            Side = input.ReadUInt32();
            break;
          }
          case 24: {
            IsSnapshot = input.ReadBool();
            break;
          }
          case 34: {
            orders_.AddEntriesFrom(input, _repeated_orders_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            ScaledPrice = input.ReadSInt32();
            break;
          }
          case 16: {
            Side = input.ReadUInt32();
            break;
          }
          case 24: {
            IsSnapshot = input.ReadBool();
            break;
          }
          case 34: {
            orders_.AddEntriesFrom(ref input, _repeated_orders_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// A single order or change to an existing order (depending on DetailedDOMAtPrice.is_snapshot).
  /// </summary>
  public sealed partial class DetailedDOMOrder : pb::IMessage<DetailedDOMOrder>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<DetailedDOMOrder> _parser = new pb::MessageParser<DetailedDOMOrder>(() => new DetailedDOMOrder());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<DetailedDOMOrder> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::MarketData2.MarketData2Reflection.Descriptor.MessageTypes[10]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DetailedDOMOrder() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DetailedDOMOrder(DetailedDOMOrder other) : this() {
      _hasBits0 = other._hasBits0;
      detailedDomOrderId_ = other.detailedDomOrderId_;
      operation_ = other.operation_;
      orderIndex_ = other.orderIndex_;
      scaledVolume_ = other.scaledVolume_;
      discretionaryOffset_ = other.discretionaryOffset_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DetailedDOMOrder Clone() {
      return new DetailedDOMOrder(this);
    }

    /// <summary>Field number for the "detailed_dom_order_id" field.</summary>
    public const int DetailedDomOrderIdFieldNumber = 1;
    private readonly static string DetailedDomOrderIdDefaultValue = "";

    private string detailedDomOrderId_;
    /// <summary>
    /// Same as OrderStatus.detailed_dom_order_id.
    /// The field is also non-empty for other users' orders. So, to determine user's place in orders
    /// queue user must check if this is his order using the contract_id and detailed_dom_order_id pair.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string DetailedDomOrderId {
      get { return detailedDomOrderId_ ?? DetailedDomOrderIdDefaultValue; }
      set {
        detailedDomOrderId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "detailed_dom_order_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasDetailedDomOrderId {
      get { return detailedDomOrderId_ != null; }
    }
    /// <summary>Clears the value of the "detailed_dom_order_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearDetailedDomOrderId() {
      detailedDomOrderId_ = null;
    }

    /// <summary>Field number for the "operation" field.</summary>
    public const int OperationFieldNumber = 2;
    private readonly static uint OperationDefaultValue = 0;

    private uint operation_;
    /// <summary>
    /// Associated with Operation enum.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint Operation {
      get { if ((_hasBits0 & 1) != 0) { return operation_; } else { return OperationDefaultValue; } }
      set {
        _hasBits0 |= 1;
        operation_ = value;
      }
    }
    /// <summary>Gets whether the "operation" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasOperation {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "operation" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearOperation() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "order_index" field.</summary>
    public const int OrderIndexFieldNumber = 3;
    private readonly static uint OrderIndexDefaultValue = 0;

    private uint orderIndex_;
    /// <summary>
    /// Order Index at the price level.
    /// It is the index after all updates up to this one have been applied.
    /// The index is specified only if it cannot be deduced:
    ///  - for INSERT operation it is omitted if equals order_index in previous DetailedDOMOrder plus 1;
    ///  - for MODIFY operation it is specified if order place relative to other orders in a price level changed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint OrderIndex {
      get { if ((_hasBits0 & 2) != 0) { return orderIndex_; } else { return OrderIndexDefaultValue; } }
      set {
        _hasBits0 |= 2;
        orderIndex_ = value;
      }
    }
    /// <summary>Gets whether the "order_index" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasOrderIndex {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "order_index" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearOrderIndex() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "scaled_volume" field.</summary>
    public const int ScaledVolumeFieldNumber = 5;
    private readonly static ulong ScaledVolumeDefaultValue = 0UL;

    private ulong scaledVolume_;
    /// <summary>
    /// Order volume, if changed or new order.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ulong ScaledVolume {
      get { if ((_hasBits0 & 4) != 0) { return scaledVolume_; } else { return ScaledVolumeDefaultValue; } }
      set {
        _hasBits0 |= 4;
        scaledVolume_ = value;
      }
    }
    /// <summary>Gets whether the "scaled_volume" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasScaledVolume {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "scaled_volume" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearScaledVolume() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "discretionary_offset" field.</summary>
    public const int DiscretionaryOffsetFieldNumber = 6;
    private readonly static uint DiscretionaryOffsetDefaultValue = 0;

    private uint discretionaryOffset_;
    /// <summary>
    /// Discretionary offset in the number of discretionary ticks.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint DiscretionaryOffset {
      get { if ((_hasBits0 & 8) != 0) { return discretionaryOffset_; } else { return DiscretionaryOffsetDefaultValue; } }
      set {
        _hasBits0 |= 8;
        discretionaryOffset_ = value;
      }
    }
    /// <summary>Gets whether the "discretionary_offset" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasDiscretionaryOffset {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "discretionary_offset" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearDiscretionaryOffset() {
      _hasBits0 &= ~8;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as DetailedDOMOrder);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(DetailedDOMOrder other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (DetailedDomOrderId != other.DetailedDomOrderId) return false;
      if (Operation != other.Operation) return false;
      if (OrderIndex != other.OrderIndex) return false;
      if (ScaledVolume != other.ScaledVolume) return false;
      if (DiscretionaryOffset != other.DiscretionaryOffset) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasDetailedDomOrderId) hash ^= DetailedDomOrderId.GetHashCode();
      if (HasOperation) hash ^= Operation.GetHashCode();
      if (HasOrderIndex) hash ^= OrderIndex.GetHashCode();
      if (HasScaledVolume) hash ^= ScaledVolume.GetHashCode();
      if (HasDiscretionaryOffset) hash ^= DiscretionaryOffset.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasDetailedDomOrderId) {
        output.WriteRawTag(10);
        output.WriteString(DetailedDomOrderId);
      }
      if (HasOperation) {
        output.WriteRawTag(16);
        output.WriteUInt32(Operation);
      }
      if (HasOrderIndex) {
        output.WriteRawTag(24);
        output.WriteUInt32(OrderIndex);
      }
      if (HasScaledVolume) {
        output.WriteRawTag(40);
        output.WriteUInt64(ScaledVolume);
      }
      if (HasDiscretionaryOffset) {
        output.WriteRawTag(48);
        output.WriteUInt32(DiscretionaryOffset);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasDetailedDomOrderId) {
        output.WriteRawTag(10);
        output.WriteString(DetailedDomOrderId);
      }
      if (HasOperation) {
        output.WriteRawTag(16);
        output.WriteUInt32(Operation);
      }
      if (HasOrderIndex) {
        output.WriteRawTag(24);
        output.WriteUInt32(OrderIndex);
      }
      if (HasScaledVolume) {
        output.WriteRawTag(40);
        output.WriteUInt64(ScaledVolume);
      }
      if (HasDiscretionaryOffset) {
        output.WriteRawTag(48);
        output.WriteUInt32(DiscretionaryOffset);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (HasDetailedDomOrderId) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(DetailedDomOrderId);
      }
      if (HasOperation) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Operation);
      }
      if (HasOrderIndex) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(OrderIndex);
      }
      if (HasScaledVolume) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(ScaledVolume);
      }
      if (HasDiscretionaryOffset) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(DiscretionaryOffset);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(DetailedDOMOrder other) {
      if (other == null) {
        return;
      }
      if (other.HasDetailedDomOrderId) {
        DetailedDomOrderId = other.DetailedDomOrderId;
      }
      if (other.HasOperation) {
        Operation = other.Operation;
      }
      if (other.HasOrderIndex) {
        OrderIndex = other.OrderIndex;
      }
      if (other.HasScaledVolume) {
        ScaledVolume = other.ScaledVolume;
      }
      if (other.HasDiscretionaryOffset) {
        DiscretionaryOffset = other.DiscretionaryOffset;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            DetailedDomOrderId = input.ReadString();
            break;
          }
          case 16: {
            Operation = input.ReadUInt32();
            break;
          }
          case 24: {
            OrderIndex = input.ReadUInt32();
            break;
          }
          case 40: {
            ScaledVolume = input.ReadUInt64();
            break;
          }
          case 48: {
            DiscretionaryOffset = input.ReadUInt32();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            DetailedDomOrderId = input.ReadString();
            break;
          }
          case 16: {
            Operation = input.ReadUInt32();
            break;
          }
          case 24: {
            OrderIndex = input.ReadUInt32();
            break;
          }
          case 40: {
            ScaledVolume = input.ReadUInt64();
            break;
          }
          case 48: {
            DiscretionaryOffset = input.ReadUInt32();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the DetailedDOMOrder message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public enum Operation {
        /// <summary>
        /// A new order is added.
        /// </summary>
        [pbr::OriginalName("OPERATION_INSERT")] Insert = 0,
        /// <summary>
        /// An existing order is removed.
        /// </summary>
        [pbr::OriginalName("OPERATION_REMOVE")] Remove = 1,
        /// <summary>
        /// An existing order is modified but remains at the same price level.
        /// </summary>
        [pbr::OriginalName("OPERATION_MODIFY")] Modify = 2,
        /// <summary>
        /// An existing order is removed from its current price level to another one.
        /// </summary>
        [pbr::OriginalName("OPERATION_MOVE_FROM_PRICE")] MoveFromPrice = 3,
        /// <summary>
        /// An existing order is inserted into its new price level.
        /// Note, some fields can also change.
        /// Note, relative order of OPERATION_MOVE_FROM_PRICE and OPERATION_MOVE_TO_PRICE is not defined.
        /// </summary>
        [pbr::OriginalName("OPERATION_MOVE_TO_PRICE")] MoveToPrice = 4,
      }

    }
    #endregion

  }

  /// <summary>
  /// Request for quotation (RFQ).
  /// </summary>
  public sealed partial class RFQ : pb::IMessage<RFQ>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<RFQ> _parser = new pb::MessageParser<RFQ>(() => new RFQ());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<RFQ> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::MarketData2.MarketData2Reflection.Descriptor.MessageTypes[11]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RFQ() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RFQ(RFQ other) : this() {
      _hasBits0 = other._hasBits0;
      exchangeRequestId_ = other.exchangeRequestId_;
      timestamp_ = other.timestamp_ != null ? other.timestamp_.Clone() : null;
      side_ = other.side_;
      volume_ = other.volume_ != null ? other.volume_.Clone() : null;
      expirationUtcTimestamp_ = other.expirationUtcTimestamp_ != null ? other.expirationUtcTimestamp_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RFQ Clone() {
      return new RFQ(this);
    }

    /// <summary>Field number for the "exchange_request_id" field.</summary>
    public const int ExchangeRequestIdFieldNumber = 1;
    private readonly static string ExchangeRequestIdDefaultValue = "";

    private string exchangeRequestId_;
    /// <summary>
    /// Exchange ID of the request.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ExchangeRequestId {
      get { return exchangeRequestId_ ?? ExchangeRequestIdDefaultValue; }
      set {
        exchangeRequestId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "exchange_request_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasExchangeRequestId {
      get { return exchangeRequestId_ != null; }
    }
    /// <summary>Clears the value of the "exchange_request_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearExchangeRequestId() {
      exchangeRequestId_ = null;
    }

    /// <summary>Field number for the "timestamp" field.</summary>
    public const int TimestampFieldNumber = 2;
    private global::Google.Protobuf.Timestamp timestamp_;
    /// <summary>
    /// Timestamp provided by exchange (UTC).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.Timestamp Timestamp {
      get { return timestamp_; }
      set {
        timestamp_ = value;
      }
    }

    /// <summary>Field number for the "side" field.</summary>
    public const int SideFieldNumber = 3;
    private readonly static uint SideDefaultValue = 0;

    private uint side_;
    /// <summary>
    /// Specifies side of active RFQ.
    /// This field is associated with Side enum type.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint Side {
      get { if ((_hasBits0 & 1) != 0) { return side_; } else { return SideDefaultValue; } }
      set {
        _hasBits0 |= 1;
        side_ = value;
      }
    }
    /// <summary>Gets whether the "side" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasSide {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "side" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearSide() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "volume" field.</summary>
    public const int VolumeFieldNumber = 4;
    private global::Cqg.Decimal volume_;
    /// <summary>
    /// RFQ volume.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Cqg.Decimal Volume {
      get { return volume_; }
      set {
        volume_ = value;
      }
    }

    /// <summary>Field number for the "expiration_utc_timestamp" field.</summary>
    public const int ExpirationUtcTimestampFieldNumber = 5;
    private global::Google.Protobuf.Timestamp expirationUtcTimestamp_;
    /// <summary>
    /// Expiration time provided by exchange (UTC).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.Timestamp ExpirationUtcTimestamp {
      get { return expirationUtcTimestamp_; }
      set {
        expirationUtcTimestamp_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as RFQ);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(RFQ other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (ExchangeRequestId != other.ExchangeRequestId) return false;
      if (!object.Equals(Timestamp, other.Timestamp)) return false;
      if (Side != other.Side) return false;
      if (!object.Equals(Volume, other.Volume)) return false;
      if (!object.Equals(ExpirationUtcTimestamp, other.ExpirationUtcTimestamp)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasExchangeRequestId) hash ^= ExchangeRequestId.GetHashCode();
      if (timestamp_ != null) hash ^= Timestamp.GetHashCode();
      if (HasSide) hash ^= Side.GetHashCode();
      if (volume_ != null) hash ^= Volume.GetHashCode();
      if (expirationUtcTimestamp_ != null) hash ^= ExpirationUtcTimestamp.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasExchangeRequestId) {
        output.WriteRawTag(10);
        output.WriteString(ExchangeRequestId);
      }
      if (timestamp_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Timestamp);
      }
      if (HasSide) {
        output.WriteRawTag(24);
        output.WriteUInt32(Side);
      }
      if (volume_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Volume);
      }
      if (expirationUtcTimestamp_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(ExpirationUtcTimestamp);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasExchangeRequestId) {
        output.WriteRawTag(10);
        output.WriteString(ExchangeRequestId);
      }
      if (timestamp_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Timestamp);
      }
      if (HasSide) {
        output.WriteRawTag(24);
        output.WriteUInt32(Side);
      }
      if (volume_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Volume);
      }
      if (expirationUtcTimestamp_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(ExpirationUtcTimestamp);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (HasExchangeRequestId) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ExchangeRequestId);
      }
      if (timestamp_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Timestamp);
      }
      if (HasSide) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Side);
      }
      if (volume_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Volume);
      }
      if (expirationUtcTimestamp_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ExpirationUtcTimestamp);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(RFQ other) {
      if (other == null) {
        return;
      }
      if (other.HasExchangeRequestId) {
        ExchangeRequestId = other.ExchangeRequestId;
      }
      if (other.timestamp_ != null) {
        if (timestamp_ == null) {
          Timestamp = new global::Google.Protobuf.Timestamp();
        }
        Timestamp.MergeFrom(other.Timestamp);
      }
      if (other.HasSide) {
        Side = other.Side;
      }
      if (other.volume_ != null) {
        if (volume_ == null) {
          Volume = new global::Cqg.Decimal();
        }
        Volume.MergeFrom(other.Volume);
      }
      if (other.expirationUtcTimestamp_ != null) {
        if (expirationUtcTimestamp_ == null) {
          ExpirationUtcTimestamp = new global::Google.Protobuf.Timestamp();
        }
        ExpirationUtcTimestamp.MergeFrom(other.ExpirationUtcTimestamp);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            ExchangeRequestId = input.ReadString();
            break;
          }
          case 18: {
            if (timestamp_ == null) {
              Timestamp = new global::Google.Protobuf.Timestamp();
            }
            input.ReadMessage(Timestamp);
            break;
          }
          case 24: {
            Side = input.ReadUInt32();
            break;
          }
          case 34: {
            if (volume_ == null) {
              Volume = new global::Cqg.Decimal();
            }
            input.ReadMessage(Volume);
            break;
          }
          case 42: {
            if (expirationUtcTimestamp_ == null) {
              ExpirationUtcTimestamp = new global::Google.Protobuf.Timestamp();
            }
            input.ReadMessage(ExpirationUtcTimestamp);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            ExchangeRequestId = input.ReadString();
            break;
          }
          case 18: {
            if (timestamp_ == null) {
              Timestamp = new global::Google.Protobuf.Timestamp();
            }
            input.ReadMessage(Timestamp);
            break;
          }
          case 24: {
            Side = input.ReadUInt32();
            break;
          }
          case 34: {
            if (volume_ == null) {
              Volume = new global::Cqg.Decimal();
            }
            input.ReadMessage(Volume);
            break;
          }
          case 42: {
            if (expirationUtcTimestamp_ == null) {
              ExpirationUtcTimestamp = new global::Google.Protobuf.Timestamp();
            }
            input.ReadMessage(ExpirationUtcTimestamp);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the RFQ message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// Side of RFQ.
      /// </summary>
      public enum Side {
        /// <summary>
        /// Any.
        /// </summary>
        [pbr::OriginalName("SIDE_ANY")] Any = 0,
        /// <summary>
        /// Bid.
        /// </summary>
        [pbr::OriginalName("SIDE_BID")] Bid = 1,
        /// <summary>
        /// Ask.
        /// </summary>
        [pbr::OriginalName("SIDE_ASK")] Ask = 2,
      }

    }
    #endregion

  }

  /// <summary>
  /// RFQ request. Used to create RFQ on market.
  /// </summary>
  public sealed partial class RFQRequest : pb::IMessage<RFQRequest>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<RFQRequest> _parser = new pb::MessageParser<RFQRequest>(() => new RFQRequest());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<RFQRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::MarketData2.MarketData2Reflection.Descriptor.MessageTypes[12]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RFQRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RFQRequest(RFQRequest other) : this() {
      _hasBits0 = other._hasBits0;
      clientRequestId_ = other.clientRequestId_;
      accountId_ = other.accountId_;
      contractId_ = other.contractId_;
      isManual_ = other.isManual_;
      side_ = other.side_;
      size_ = other.size_ != null ? other.size_.Clone() : null;
      executionUtcTimestamp_ = other.executionUtcTimestamp_ != null ? other.executionUtcTimestamp_.Clone() : null;
      clientRegulatoryAlgorithmId_ = other.clientRegulatoryAlgorithmId_;
      expirationUtcTimestamp_ = other.expirationUtcTimestamp_ != null ? other.expirationUtcTimestamp_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RFQRequest Clone() {
      return new RFQRequest(this);
    }

    /// <summary>Field number for the "client_request_id" field.</summary>
    public const int ClientRequestIdFieldNumber = 1;
    private readonly static uint ClientRequestIdDefaultValue = 0;

    private uint clientRequestId_;
    /// <summary>
    /// Client ID of the request.
    /// It is required field.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint ClientRequestId {
      get { if ((_hasBits0 & 1) != 0) { return clientRequestId_; } else { return ClientRequestIdDefaultValue; } }
      set {
        _hasBits0 |= 1;
        clientRequestId_ = value;
      }
    }
    /// <summary>Gets whether the "client_request_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasClientRequestId {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "client_request_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearClientRequestId() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "account_id" field.</summary>
    public const int AccountIdFieldNumber = 2;
    private readonly static int AccountIdDefaultValue = 0;

    private int accountId_;
    /// <summary>
    /// Id of an account that is used to request quote.
    /// It is required field.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int AccountId {
      get { if ((_hasBits0 & 2) != 0) { return accountId_; } else { return AccountIdDefaultValue; } }
      set {
        _hasBits0 |= 2;
        accountId_ = value;
      }
    }
    /// <summary>Gets whether the "account_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasAccountId {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "account_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearAccountId() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "contract_id" field.</summary>
    public const int ContractIdFieldNumber = 3;
    private readonly static uint ContractIdDefaultValue = 0;

    private uint contractId_;
    /// <summary>
    /// Contract id.
    /// It is required field.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint ContractId {
      get { if ((_hasBits0 & 4) != 0) { return contractId_; } else { return ContractIdDefaultValue; } }
      set {
        _hasBits0 |= 4;
        contractId_ = value;
      }
    }
    /// <summary>Gets whether the "contract_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasContractId {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "contract_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearContractId() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "is_manual" field.</summary>
    public const int IsManualFieldNumber = 4;
    private readonly static bool IsManualDefaultValue = false;

    private bool isManual_;
    /// <summary>
    /// Is the request entered manually.
    /// False or omitted means that request is created by automated system.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsManual {
      get { if ((_hasBits0 & 8) != 0) { return isManual_; } else { return IsManualDefaultValue; } }
      set {
        _hasBits0 |= 8;
        isManual_ = value;
      }
    }
    /// <summary>Gets whether the "is_manual" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasIsManual {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "is_manual" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearIsManual() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "side" field.</summary>
    public const int SideFieldNumber = 5;
    private readonly static uint SideDefaultValue = 0;

    private uint side_;
    /// <summary>
    /// Specifies side of requested quote. Default value is RFQ.SIDE_ANY.
    /// This field is associated with RFQ.Side enum type.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint Side {
      get { if ((_hasBits0 & 16) != 0) { return side_; } else { return SideDefaultValue; } }
      set {
        _hasBits0 |= 16;
        side_ = value;
      }
    }
    /// <summary>Gets whether the "side" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasSide {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "side" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearSide() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "size" field.</summary>
    public const int SizeFieldNumber = 6;
    private global::Cqg.Decimal size_;
    /// <summary>
    /// Specifies size of requested quote. Unspecified value means "doesn't matter".
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Cqg.Decimal Size {
      get { return size_; }
      set {
        size_ = value;
      }
    }

    /// <summary>Field number for the "execution_utc_timestamp" field.</summary>
    public const int ExecutionUtcTimestampFieldNumber = 7;
    private global::Google.Protobuf.Timestamp executionUtcTimestamp_;
    /// <summary>
    /// Time when RFQ should be created (UTC).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.Timestamp ExecutionUtcTimestamp {
      get { return executionUtcTimestamp_; }
      set {
        executionUtcTimestamp_ = value;
      }
    }

    /// <summary>Field number for the "client_regulatory_algorithm_id" field.</summary>
    public const int ClientRegulatoryAlgorithmIdFieldNumber = 8;
    private readonly static uint ClientRegulatoryAlgorithmIdDefaultValue = 0;

    private uint clientRegulatoryAlgorithmId_;
    /// <summary>
    /// Regulatory Algorithm ID for client algorithm associated with this request, if any.
    /// This field is applicable only for exchanges that use it, e.g. Eurex.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint ClientRegulatoryAlgorithmId {
      get { if ((_hasBits0 & 32) != 0) { return clientRegulatoryAlgorithmId_; } else { return ClientRegulatoryAlgorithmIdDefaultValue; } }
      set {
        _hasBits0 |= 32;
        clientRegulatoryAlgorithmId_ = value;
      }
    }
    /// <summary>Gets whether the "client_regulatory_algorithm_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasClientRegulatoryAlgorithmId {
      get { return (_hasBits0 & 32) != 0; }
    }
    /// <summary>Clears the value of the "client_regulatory_algorithm_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearClientRegulatoryAlgorithmId() {
      _hasBits0 &= ~32;
    }

    /// <summary>Field number for the "expiration_utc_timestamp" field.</summary>
    public const int ExpirationUtcTimestampFieldNumber = 9;
    private global::Google.Protobuf.Timestamp expirationUtcTimestamp_;
    /// <summary>
    /// Quote request expiration date/time (UTC).
    /// Note: there is no way to cancel RFQ. The only way to manage its lifetime is to set expiration_utc_timestamp.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.Timestamp ExpirationUtcTimestamp {
      get { return expirationUtcTimestamp_; }
      set {
        expirationUtcTimestamp_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as RFQRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(RFQRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (ClientRequestId != other.ClientRequestId) return false;
      if (AccountId != other.AccountId) return false;
      if (ContractId != other.ContractId) return false;
      if (IsManual != other.IsManual) return false;
      if (Side != other.Side) return false;
      if (!object.Equals(Size, other.Size)) return false;
      if (!object.Equals(ExecutionUtcTimestamp, other.ExecutionUtcTimestamp)) return false;
      if (ClientRegulatoryAlgorithmId != other.ClientRegulatoryAlgorithmId) return false;
      if (!object.Equals(ExpirationUtcTimestamp, other.ExpirationUtcTimestamp)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasClientRequestId) hash ^= ClientRequestId.GetHashCode();
      if (HasAccountId) hash ^= AccountId.GetHashCode();
      if (HasContractId) hash ^= ContractId.GetHashCode();
      if (HasIsManual) hash ^= IsManual.GetHashCode();
      if (HasSide) hash ^= Side.GetHashCode();
      if (size_ != null) hash ^= Size.GetHashCode();
      if (executionUtcTimestamp_ != null) hash ^= ExecutionUtcTimestamp.GetHashCode();
      if (HasClientRegulatoryAlgorithmId) hash ^= ClientRegulatoryAlgorithmId.GetHashCode();
      if (expirationUtcTimestamp_ != null) hash ^= ExpirationUtcTimestamp.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasClientRequestId) {
        output.WriteRawTag(8);
        output.WriteUInt32(ClientRequestId);
      }
      if (HasAccountId) {
        output.WriteRawTag(16);
        output.WriteSInt32(AccountId);
      }
      if (HasContractId) {
        output.WriteRawTag(24);
        output.WriteUInt32(ContractId);
      }
      if (HasIsManual) {
        output.WriteRawTag(32);
        output.WriteBool(IsManual);
      }
      if (HasSide) {
        output.WriteRawTag(40);
        output.WriteUInt32(Side);
      }
      if (size_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(Size);
      }
      if (executionUtcTimestamp_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(ExecutionUtcTimestamp);
      }
      if (HasClientRegulatoryAlgorithmId) {
        output.WriteRawTag(64);
        output.WriteUInt32(ClientRegulatoryAlgorithmId);
      }
      if (expirationUtcTimestamp_ != null) {
        output.WriteRawTag(74);
        output.WriteMessage(ExpirationUtcTimestamp);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasClientRequestId) {
        output.WriteRawTag(8);
        output.WriteUInt32(ClientRequestId);
      }
      if (HasAccountId) {
        output.WriteRawTag(16);
        output.WriteSInt32(AccountId);
      }
      if (HasContractId) {
        output.WriteRawTag(24);
        output.WriteUInt32(ContractId);
      }
      if (HasIsManual) {
        output.WriteRawTag(32);
        output.WriteBool(IsManual);
      }
      if (HasSide) {
        output.WriteRawTag(40);
        output.WriteUInt32(Side);
      }
      if (size_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(Size);
      }
      if (executionUtcTimestamp_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(ExecutionUtcTimestamp);
      }
      if (HasClientRegulatoryAlgorithmId) {
        output.WriteRawTag(64);
        output.WriteUInt32(ClientRegulatoryAlgorithmId);
      }
      if (expirationUtcTimestamp_ != null) {
        output.WriteRawTag(74);
        output.WriteMessage(ExpirationUtcTimestamp);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (HasClientRequestId) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(ClientRequestId);
      }
      if (HasAccountId) {
        size += 1 + pb::CodedOutputStream.ComputeSInt32Size(AccountId);
      }
      if (HasContractId) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(ContractId);
      }
      if (HasIsManual) {
        size += 1 + 1;
      }
      if (HasSide) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Side);
      }
      if (size_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Size);
      }
      if (executionUtcTimestamp_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ExecutionUtcTimestamp);
      }
      if (HasClientRegulatoryAlgorithmId) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(ClientRegulatoryAlgorithmId);
      }
      if (expirationUtcTimestamp_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ExpirationUtcTimestamp);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(RFQRequest other) {
      if (other == null) {
        return;
      }
      if (other.HasClientRequestId) {
        ClientRequestId = other.ClientRequestId;
      }
      if (other.HasAccountId) {
        AccountId = other.AccountId;
      }
      if (other.HasContractId) {
        ContractId = other.ContractId;
      }
      if (other.HasIsManual) {
        IsManual = other.IsManual;
      }
      if (other.HasSide) {
        Side = other.Side;
      }
      if (other.size_ != null) {
        if (size_ == null) {
          Size = new global::Cqg.Decimal();
        }
        Size.MergeFrom(other.Size);
      }
      if (other.executionUtcTimestamp_ != null) {
        if (executionUtcTimestamp_ == null) {
          ExecutionUtcTimestamp = new global::Google.Protobuf.Timestamp();
        }
        ExecutionUtcTimestamp.MergeFrom(other.ExecutionUtcTimestamp);
      }
      if (other.HasClientRegulatoryAlgorithmId) {
        ClientRegulatoryAlgorithmId = other.ClientRegulatoryAlgorithmId;
      }
      if (other.expirationUtcTimestamp_ != null) {
        if (expirationUtcTimestamp_ == null) {
          ExpirationUtcTimestamp = new global::Google.Protobuf.Timestamp();
        }
        ExpirationUtcTimestamp.MergeFrom(other.ExpirationUtcTimestamp);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            ClientRequestId = input.ReadUInt32();
            break;
          }
          case 16: {
            AccountId = input.ReadSInt32();
            break;
          }
          case 24: {
            ContractId = input.ReadUInt32();
            break;
          }
          case 32: {
            IsManual = input.ReadBool();
            break;
          }
          case 40: {
            Side = input.ReadUInt32();
            break;
          }
          case 50: {
            if (size_ == null) {
              Size = new global::Cqg.Decimal();
            }
            input.ReadMessage(Size);
            break;
          }
          case 58: {
            if (executionUtcTimestamp_ == null) {
              ExecutionUtcTimestamp = new global::Google.Protobuf.Timestamp();
            }
            input.ReadMessage(ExecutionUtcTimestamp);
            break;
          }
          case 64: {
            ClientRegulatoryAlgorithmId = input.ReadUInt32();
            break;
          }
          case 74: {
            if (expirationUtcTimestamp_ == null) {
              ExpirationUtcTimestamp = new global::Google.Protobuf.Timestamp();
            }
            input.ReadMessage(ExpirationUtcTimestamp);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            ClientRequestId = input.ReadUInt32();
            break;
          }
          case 16: {
            AccountId = input.ReadSInt32();
            break;
          }
          case 24: {
            ContractId = input.ReadUInt32();
            break;
          }
          case 32: {
            IsManual = input.ReadBool();
            break;
          }
          case 40: {
            Side = input.ReadUInt32();
            break;
          }
          case 50: {
            if (size_ == null) {
              Size = new global::Cqg.Decimal();
            }
            input.ReadMessage(Size);
            break;
          }
          case 58: {
            if (executionUtcTimestamp_ == null) {
              ExecutionUtcTimestamp = new global::Google.Protobuf.Timestamp();
            }
            input.ReadMessage(ExecutionUtcTimestamp);
            break;
          }
          case 64: {
            ClientRegulatoryAlgorithmId = input.ReadUInt32();
            break;
          }
          case 74: {
            if (expirationUtcTimestamp_ == null) {
              ExpirationUtcTimestamp = new global::Google.Protobuf.Timestamp();
            }
            input.ReadMessage(ExpirationUtcTimestamp);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Result of RFQ request.
  /// </summary>
  public sealed partial class RFQReport : pb::IMessage<RFQReport>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<RFQReport> _parser = new pb::MessageParser<RFQReport>(() => new RFQReport());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<RFQReport> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::MarketData2.MarketData2Reflection.Descriptor.MessageTypes[13]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RFQReport() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RFQReport(RFQReport other) : this() {
      _hasBits0 = other._hasBits0;
      clientRequestId_ = other.clientRequestId_;
      exchangeRequestId_ = other.exchangeRequestId_;
      statusCode_ = other.statusCode_;
      details_ = other.details_ != null ? other.details_.Clone() : null;
      effectiveRegulatoryAlgorithmId_ = other.effectiveRegulatoryAlgorithmId_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RFQReport Clone() {
      return new RFQReport(this);
    }

    /// <summary>Field number for the "client_request_id" field.</summary>
    public const int ClientRequestIdFieldNumber = 1;
    private readonly static uint ClientRequestIdDefaultValue = 0;

    private uint clientRequestId_;
    /// <summary>
    /// Client ID of the request.
    /// It is required field.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint ClientRequestId {
      get { if ((_hasBits0 & 1) != 0) { return clientRequestId_; } else { return ClientRequestIdDefaultValue; } }
      set {
        _hasBits0 |= 1;
        clientRequestId_ = value;
      }
    }
    /// <summary>Gets whether the "client_request_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasClientRequestId {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "client_request_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearClientRequestId() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "exchange_request_id" field.</summary>
    public const int ExchangeRequestIdFieldNumber = 2;
    private readonly static string ExchangeRequestIdDefaultValue = "";

    private string exchangeRequestId_;
    /// <summary>
    /// Exchange ID of the request.
    /// It's set if status_code = STATUS_CODE_SUCCESS.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ExchangeRequestId {
      get { return exchangeRequestId_ ?? ExchangeRequestIdDefaultValue; }
      set {
        exchangeRequestId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "exchange_request_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasExchangeRequestId {
      get { return exchangeRequestId_ != null; }
    }
    /// <summary>Clears the value of the "exchange_request_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearExchangeRequestId() {
      exchangeRequestId_ = null;
    }

    /// <summary>Field number for the "status_code" field.</summary>
    public const int StatusCodeFieldNumber = 3;
    private readonly static uint StatusCodeDefaultValue = 0;

    private uint statusCode_;
    /// <summary>
    /// Status code.
    /// This field is associated with StatusCode enum type.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint StatusCode {
      get { if ((_hasBits0 & 2) != 0) { return statusCode_; } else { return StatusCodeDefaultValue; } }
      set {
        _hasBits0 |= 2;
        statusCode_ = value;
      }
    }
    /// <summary>Gets whether the "status_code" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasStatusCode {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "status_code" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearStatusCode() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "details" field.</summary>
    public const int DetailsFieldNumber = 4;
    private global::Shared1.Text details_;
    /// <summary>
    /// Optional failure details.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Shared1.Text Details {
      get { return details_; }
      set {
        details_ = value;
      }
    }

    /// <summary>Field number for the "effective_regulatory_algorithm_id" field.</summary>
    public const int EffectiveRegulatoryAlgorithmIdFieldNumber = 5;
    private readonly static uint EffectiveRegulatoryAlgorithmIdDefaultValue = 0;

    private uint effectiveRegulatoryAlgorithmId_;
    /// <summary>
    /// Regulatory Algorithm ID actually sent to the exchange for this request, if any.
    /// Will differ from client_regulatory_algorithm_id if any CQG algorithm was applied to the order.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint EffectiveRegulatoryAlgorithmId {
      get { if ((_hasBits0 & 4) != 0) { return effectiveRegulatoryAlgorithmId_; } else { return EffectiveRegulatoryAlgorithmIdDefaultValue; } }
      set {
        _hasBits0 |= 4;
        effectiveRegulatoryAlgorithmId_ = value;
      }
    }
    /// <summary>Gets whether the "effective_regulatory_algorithm_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasEffectiveRegulatoryAlgorithmId {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "effective_regulatory_algorithm_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearEffectiveRegulatoryAlgorithmId() {
      _hasBits0 &= ~4;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as RFQReport);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(RFQReport other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (ClientRequestId != other.ClientRequestId) return false;
      if (ExchangeRequestId != other.ExchangeRequestId) return false;
      if (StatusCode != other.StatusCode) return false;
      if (!object.Equals(Details, other.Details)) return false;
      if (EffectiveRegulatoryAlgorithmId != other.EffectiveRegulatoryAlgorithmId) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasClientRequestId) hash ^= ClientRequestId.GetHashCode();
      if (HasExchangeRequestId) hash ^= ExchangeRequestId.GetHashCode();
      if (HasStatusCode) hash ^= StatusCode.GetHashCode();
      if (details_ != null) hash ^= Details.GetHashCode();
      if (HasEffectiveRegulatoryAlgorithmId) hash ^= EffectiveRegulatoryAlgorithmId.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasClientRequestId) {
        output.WriteRawTag(8);
        output.WriteUInt32(ClientRequestId);
      }
      if (HasExchangeRequestId) {
        output.WriteRawTag(18);
        output.WriteString(ExchangeRequestId);
      }
      if (HasStatusCode) {
        output.WriteRawTag(24);
        output.WriteUInt32(StatusCode);
      }
      if (details_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Details);
      }
      if (HasEffectiveRegulatoryAlgorithmId) {
        output.WriteRawTag(40);
        output.WriteUInt32(EffectiveRegulatoryAlgorithmId);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasClientRequestId) {
        output.WriteRawTag(8);
        output.WriteUInt32(ClientRequestId);
      }
      if (HasExchangeRequestId) {
        output.WriteRawTag(18);
        output.WriteString(ExchangeRequestId);
      }
      if (HasStatusCode) {
        output.WriteRawTag(24);
        output.WriteUInt32(StatusCode);
      }
      if (details_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Details);
      }
      if (HasEffectiveRegulatoryAlgorithmId) {
        output.WriteRawTag(40);
        output.WriteUInt32(EffectiveRegulatoryAlgorithmId);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (HasClientRequestId) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(ClientRequestId);
      }
      if (HasExchangeRequestId) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ExchangeRequestId);
      }
      if (HasStatusCode) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(StatusCode);
      }
      if (details_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Details);
      }
      if (HasEffectiveRegulatoryAlgorithmId) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(EffectiveRegulatoryAlgorithmId);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(RFQReport other) {
      if (other == null) {
        return;
      }
      if (other.HasClientRequestId) {
        ClientRequestId = other.ClientRequestId;
      }
      if (other.HasExchangeRequestId) {
        ExchangeRequestId = other.ExchangeRequestId;
      }
      if (other.HasStatusCode) {
        StatusCode = other.StatusCode;
      }
      if (other.details_ != null) {
        if (details_ == null) {
          Details = new global::Shared1.Text();
        }
        Details.MergeFrom(other.Details);
      }
      if (other.HasEffectiveRegulatoryAlgorithmId) {
        EffectiveRegulatoryAlgorithmId = other.EffectiveRegulatoryAlgorithmId;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            ClientRequestId = input.ReadUInt32();
            break;
          }
          case 18: {
            ExchangeRequestId = input.ReadString();
            break;
          }
          case 24: {
            StatusCode = input.ReadUInt32();
            break;
          }
          case 34: {
            if (details_ == null) {
              Details = new global::Shared1.Text();
            }
            input.ReadMessage(Details);
            break;
          }
          case 40: {
            EffectiveRegulatoryAlgorithmId = input.ReadUInt32();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            ClientRequestId = input.ReadUInt32();
            break;
          }
          case 18: {
            ExchangeRequestId = input.ReadString();
            break;
          }
          case 24: {
            StatusCode = input.ReadUInt32();
            break;
          }
          case 34: {
            if (details_ == null) {
              Details = new global::Shared1.Text();
            }
            input.ReadMessage(Details);
            break;
          }
          case 40: {
            EffectiveRegulatoryAlgorithmId = input.ReadUInt32();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the RFQReport message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public enum StatusCode {
        /// <summary>
        //// Success codes (0 - 99)
        /// </summary>
        [pbr::OriginalName("STATUS_CODE_SUCCESS")] Success = 0,
        /// <summary>
        //// Failure codes (100+)
        /// General failure.
        /// </summary>
        [pbr::OriginalName("STATUS_CODE_FAILURE")] Failure = 101,
        /// <summary>
        /// Request parameters are invalid.
        /// </summary>
        [pbr::OriginalName("STATUS_CODE_INVALID_PARAMS")] InvalidParams = 102,
        /// <summary>
        /// RFQ is not supported for specified contract.
        /// </summary>
        [pbr::OriginalName("STATUS_CODE_NOT_SUPPORTED_FOR_CONTRACT")] NotSupportedForContract = 103,
      }

    }
    #endregion

  }

  /// <summary>
  /// Parameters of OptionCalculationRequest
  /// </summary>
  public sealed partial class OptionCalculationParameters : pb::IMessage<OptionCalculationParameters>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<OptionCalculationParameters> _parser = new pb::MessageParser<OptionCalculationParameters>(() => new OptionCalculationParameters());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<OptionCalculationParameters> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::MarketData2.MarketData2Reflection.Descriptor.MessageTypes[14]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public OptionCalculationParameters() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public OptionCalculationParameters(OptionCalculationParameters other) : this() {
      optionMaturitySymbolId_ = other.optionMaturitySymbolId_;
      strikeContractIds_ = other.strikeContractIds_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public OptionCalculationParameters Clone() {
      return new OptionCalculationParameters(this);
    }

    /// <summary>Field number for the "option_maturity_symbol_id" field.</summary>
    public const int OptionMaturitySymbolIdFieldNumber = 1;
    private readonly static string OptionMaturitySymbolIdDefaultValue = "";

    private string optionMaturitySymbolId_;
    /// <summary>
    /// Option maturity symbol id representing the parent symbol for the option strike list of the same underlying and maturity period (see Symbol.id).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string OptionMaturitySymbolId {
      get { return optionMaturitySymbolId_ ?? OptionMaturitySymbolIdDefaultValue; }
      set {
        optionMaturitySymbolId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "option_maturity_symbol_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasOptionMaturitySymbolId {
      get { return optionMaturitySymbolId_ != null; }
    }
    /// <summary>Clears the value of the "option_maturity_symbol_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearOptionMaturitySymbolId() {
      optionMaturitySymbolId_ = null;
    }

    /// <summary>Field number for the "strike_contract_ids" field.</summary>
    public const int StrikeContractIdsFieldNumber = 2;
    private static readonly pb::FieldCodec<uint> _repeated_strikeContractIds_codec
        = pb::FieldCodec.ForUInt32(16);
    private readonly pbc::RepeatedField<uint> strikeContractIds_ = new pbc::RepeatedField<uint>();
    /// <summary>
    /// Server side contract identifiers. Leave it empty to request all strikes for the given maturity.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<uint> StrikeContractIds {
      get { return strikeContractIds_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as OptionCalculationParameters);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(OptionCalculationParameters other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (OptionMaturitySymbolId != other.OptionMaturitySymbolId) return false;
      if(!strikeContractIds_.Equals(other.strikeContractIds_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasOptionMaturitySymbolId) hash ^= OptionMaturitySymbolId.GetHashCode();
      hash ^= strikeContractIds_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasOptionMaturitySymbolId) {
        output.WriteRawTag(10);
        output.WriteString(OptionMaturitySymbolId);
      }
      strikeContractIds_.WriteTo(output, _repeated_strikeContractIds_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasOptionMaturitySymbolId) {
        output.WriteRawTag(10);
        output.WriteString(OptionMaturitySymbolId);
      }
      strikeContractIds_.WriteTo(ref output, _repeated_strikeContractIds_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (HasOptionMaturitySymbolId) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(OptionMaturitySymbolId);
      }
      size += strikeContractIds_.CalculateSize(_repeated_strikeContractIds_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(OptionCalculationParameters other) {
      if (other == null) {
        return;
      }
      if (other.HasOptionMaturitySymbolId) {
        OptionMaturitySymbolId = other.OptionMaturitySymbolId;
      }
      strikeContractIds_.Add(other.strikeContractIds_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            OptionMaturitySymbolId = input.ReadString();
            break;
          }
          case 18:
          case 16: {
            strikeContractIds_.AddEntriesFrom(input, _repeated_strikeContractIds_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            OptionMaturitySymbolId = input.ReadString();
            break;
          }
          case 18:
          case 16: {
            strikeContractIds_.AddEntriesFrom(ref input, _repeated_strikeContractIds_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Request for Greeks and other option calculations
  /// </summary>
  public sealed partial class OptionCalculationRequest : pb::IMessage<OptionCalculationRequest>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<OptionCalculationRequest> _parser = new pb::MessageParser<OptionCalculationRequest>(() => new OptionCalculationRequest());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<OptionCalculationRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::MarketData2.MarketData2Reflection.Descriptor.MessageTypes[15]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public OptionCalculationRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public OptionCalculationRequest(OptionCalculationRequest other) : this() {
      _hasBits0 = other._hasBits0;
      requestId_ = other.requestId_;
      optionCalculationParameters_ = other.optionCalculationParameters_ != null ? other.optionCalculationParameters_.Clone() : null;
      requestType_ = other.requestType_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public OptionCalculationRequest Clone() {
      return new OptionCalculationRequest(this);
    }

    /// <summary>Field number for the "request_id" field.</summary>
    public const int RequestIdFieldNumber = 1;
    private readonly static uint RequestIdDefaultValue = 0;

    private uint requestId_;
    /// <summary>
    /// ID of the request. Cannot be empty.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint RequestId {
      get { if ((_hasBits0 & 1) != 0) { return requestId_; } else { return RequestIdDefaultValue; } }
      set {
        _hasBits0 |= 1;
        requestId_ = value;
      }
    }
    /// <summary>Gets whether the "request_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasRequestId {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "request_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearRequestId() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "option_calculation_parameters" field.</summary>
    public const int OptionCalculationParametersFieldNumber = 2;
    private global::MarketData2.OptionCalculationParameters optionCalculationParameters_;
    /// <summary>
    /// Request parameters.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::MarketData2.OptionCalculationParameters OptionCalculationParameters {
      get { return optionCalculationParameters_; }
      set {
        optionCalculationParameters_ = value;
      }
    }

    /// <summary>Field number for the "request_type" field.</summary>
    public const int RequestTypeFieldNumber = 3;
    private readonly static uint RequestTypeDefaultValue = 0;

    private uint requestType_;
    /// <summary>
    /// This field is associated with RequestType enum type.
    /// REQUEST_TYPE_SUBSCRIBE operation is processed by default.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint RequestType {
      get { if ((_hasBits0 & 2) != 0) { return requestType_; } else { return RequestTypeDefaultValue; } }
      set {
        _hasBits0 |= 2;
        requestType_ = value;
      }
    }
    /// <summary>Gets whether the "request_type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasRequestType {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "request_type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearRequestType() {
      _hasBits0 &= ~2;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as OptionCalculationRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(OptionCalculationRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (RequestId != other.RequestId) return false;
      if (!object.Equals(OptionCalculationParameters, other.OptionCalculationParameters)) return false;
      if (RequestType != other.RequestType) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasRequestId) hash ^= RequestId.GetHashCode();
      if (optionCalculationParameters_ != null) hash ^= OptionCalculationParameters.GetHashCode();
      if (HasRequestType) hash ^= RequestType.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasRequestId) {
        output.WriteRawTag(8);
        output.WriteUInt32(RequestId);
      }
      if (optionCalculationParameters_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(OptionCalculationParameters);
      }
      if (HasRequestType) {
        output.WriteRawTag(24);
        output.WriteUInt32(RequestType);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasRequestId) {
        output.WriteRawTag(8);
        output.WriteUInt32(RequestId);
      }
      if (optionCalculationParameters_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(OptionCalculationParameters);
      }
      if (HasRequestType) {
        output.WriteRawTag(24);
        output.WriteUInt32(RequestType);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (HasRequestId) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(RequestId);
      }
      if (optionCalculationParameters_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(OptionCalculationParameters);
      }
      if (HasRequestType) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(RequestType);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(OptionCalculationRequest other) {
      if (other == null) {
        return;
      }
      if (other.HasRequestId) {
        RequestId = other.RequestId;
      }
      if (other.optionCalculationParameters_ != null) {
        if (optionCalculationParameters_ == null) {
          OptionCalculationParameters = new global::MarketData2.OptionCalculationParameters();
        }
        OptionCalculationParameters.MergeFrom(other.OptionCalculationParameters);
      }
      if (other.HasRequestType) {
        RequestType = other.RequestType;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            RequestId = input.ReadUInt32();
            break;
          }
          case 18: {
            if (optionCalculationParameters_ == null) {
              OptionCalculationParameters = new global::MarketData2.OptionCalculationParameters();
            }
            input.ReadMessage(OptionCalculationParameters);
            break;
          }
          case 24: {
            RequestType = input.ReadUInt32();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            RequestId = input.ReadUInt32();
            break;
          }
          case 18: {
            if (optionCalculationParameters_ == null) {
              OptionCalculationParameters = new global::MarketData2.OptionCalculationParameters();
            }
            input.ReadMessage(OptionCalculationParameters);
            break;
          }
          case 24: {
            RequestType = input.ReadUInt32();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the OptionCalculationRequest message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// Type of request action.
      /// </summary>
      public enum RequestType {
        /// <summary>
        /// Calculation request with subscription for updates.
        /// </summary>
        [pbr::OriginalName("REQUEST_TYPE_SUBSCRIBE")] Subscribe = 2,
        /// <summary>
        /// Drop subscription request and unsubscribe.
        /// </summary>
        [pbr::OriginalName("REQUEST_TYPE_DROP")] Drop = 3,
      }

    }
    #endregion

  }

  /// <summary>
  /// Calculated values
  /// </summary>
  public sealed partial class OptionCalculationValues : pb::IMessage<OptionCalculationValues>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<OptionCalculationValues> _parser = new pb::MessageParser<OptionCalculationValues>(() => new OptionCalculationValues());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<OptionCalculationValues> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::MarketData2.MarketData2Reflection.Descriptor.MessageTypes[16]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public OptionCalculationValues() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public OptionCalculationValues(OptionCalculationValues other) : this() {
      _hasBits0 = other._hasBits0;
      strikeContractId_ = other.strikeContractId_;
      scaledCoherentUnderlyingPrice_ = other.scaledCoherentUnderlyingPrice_;
      impliedVolatility_ = other.impliedVolatility_;
      theov_ = other.theov_;
      delta_ = other.delta_;
      gamma_ = other.gamma_;
      vega_ = other.vega_;
      theta_ = other.theta_;
      rho_ = other.rho_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public OptionCalculationValues Clone() {
      return new OptionCalculationValues(this);
    }

    /// <summary>Field number for the "strike_contract_id" field.</summary>
    public const int StrikeContractIdFieldNumber = 1;
    private readonly static uint StrikeContractIdDefaultValue = 0;

    private uint strikeContractId_;
    /// <summary>
    /// Server side contract id.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint StrikeContractId {
      get { if ((_hasBits0 & 1) != 0) { return strikeContractId_; } else { return StrikeContractIdDefaultValue; } }
      set {
        _hasBits0 |= 1;
        strikeContractId_ = value;
      }
    }
    /// <summary>Gets whether the "strike_contract_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasStrikeContractId {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "strike_contract_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearStrikeContractId() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "scaled_coherent_underlying_price" field.</summary>
    public const int ScaledCoherentUnderlyingPriceFieldNumber = 2;
    private readonly static int ScaledCoherentUnderlyingPriceDefaultValue = 0;

    private int scaledCoherentUnderlyingPrice_;
    /// <summary>
    /// The most recent price of the underlying instrument at the time of the option contract price used in calculations.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int ScaledCoherentUnderlyingPrice {
      get { if ((_hasBits0 & 2) != 0) { return scaledCoherentUnderlyingPrice_; } else { return ScaledCoherentUnderlyingPriceDefaultValue; } }
      set {
        _hasBits0 |= 2;
        scaledCoherentUnderlyingPrice_ = value;
      }
    }
    /// <summary>Gets whether the "scaled_coherent_underlying_price" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasScaledCoherentUnderlyingPrice {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "scaled_coherent_underlying_price" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearScaledCoherentUnderlyingPrice() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "implied_volatility" field.</summary>
    public const int ImpliedVolatilityFieldNumber = 3;
    private readonly static double ImpliedVolatilityDefaultValue = 0D;

    private double impliedVolatility_;
    /// <summary>
    /// Calculated Implied Volatility in percents.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double ImpliedVolatility {
      get { if ((_hasBits0 & 4) != 0) { return impliedVolatility_; } else { return ImpliedVolatilityDefaultValue; } }
      set {
        _hasBits0 |= 4;
        impliedVolatility_ = value;
      }
    }
    /// <summary>Gets whether the "implied_volatility" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasImpliedVolatility {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "implied_volatility" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearImpliedVolatility() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "theov" field.</summary>
    public const int TheovFieldNumber = 4;
    private readonly static double TheovDefaultValue = 0D;

    private double theov_;
    /// <summary>
    /// Calculated Theoretical Price in correct price format.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double Theov {
      get { if ((_hasBits0 & 8) != 0) { return theov_; } else { return TheovDefaultValue; } }
      set {
        _hasBits0 |= 8;
        theov_ = value;
      }
    }
    /// <summary>Gets whether the "theov" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasTheov {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "theov" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearTheov() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "delta" field.</summary>
    public const int DeltaFieldNumber = 5;
    private readonly static double DeltaDefaultValue = 0D;

    private double delta_;
    /// <summary>
    /// Calculated Delta Greek value in percents.
    /// Represents the ratio of the change in the correct theoretical price over the change in the correct underlying price.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double Delta {
      get { if ((_hasBits0 & 16) != 0) { return delta_; } else { return DeltaDefaultValue; } }
      set {
        _hasBits0 |= 16;
        delta_ = value;
      }
    }
    /// <summary>Gets whether the "delta" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasDelta {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "delta" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearDelta() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "gamma" field.</summary>
    public const int GammaFieldNumber = 6;
    private readonly static double GammaDefaultValue = 0D;

    private double gamma_;
    /// <summary>
    /// Calculated Gamma Greek value in percents.
    /// Represents Delta Greek change which occurs if correct underlying price increases by 1.
    /// Correct underlying price can be calculated by multiplying OptionCalculationReport.scaled_underlying_price
    /// by correct_price_scale of the underlying contract.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double Gamma {
      get { if ((_hasBits0 & 32) != 0) { return gamma_; } else { return GammaDefaultValue; } }
      set {
        _hasBits0 |= 32;
        gamma_ = value;
      }
    }
    /// <summary>Gets whether the "gamma" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasGamma {
      get { return (_hasBits0 & 32) != 0; }
    }
    /// <summary>Clears the value of the "gamma" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearGamma() {
      _hasBits0 &= ~32;
    }

    /// <summary>Field number for the "vega" field.</summary>
    public const int VegaFieldNumber = 7;
    private readonly static double VegaDefaultValue = 0D;

    private double vega_;
    /// <summary>
    /// Calculated Vega Greek value.
    /// Represents correct theoretical price change which occurs if Implied Volatility increases by 1%.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double Vega {
      get { if ((_hasBits0 & 64) != 0) { return vega_; } else { return VegaDefaultValue; } }
      set {
        _hasBits0 |= 64;
        vega_ = value;
      }
    }
    /// <summary>Gets whether the "vega" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasVega {
      get { return (_hasBits0 & 64) != 0; }
    }
    /// <summary>Clears the value of the "vega" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearVega() {
      _hasBits0 &= ~64;
    }

    /// <summary>Field number for the "theta" field.</summary>
    public const int ThetaFieldNumber = 8;
    private readonly static double ThetaDefaultValue = 0D;

    private double theta_;
    /// <summary>
    /// Calculated Theta Greek value.
    /// Represents correct theoretical price change which occurs if number of days to expiration decreases by one day.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double Theta {
      get { if ((_hasBits0 & 128) != 0) { return theta_; } else { return ThetaDefaultValue; } }
      set {
        _hasBits0 |= 128;
        theta_ = value;
      }
    }
    /// <summary>Gets whether the "theta" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasTheta {
      get { return (_hasBits0 & 128) != 0; }
    }
    /// <summary>Clears the value of the "theta" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearTheta() {
      _hasBits0 &= ~128;
    }

    /// <summary>Field number for the "rho" field.</summary>
    public const int RhoFieldNumber = 9;
    private readonly static double RhoDefaultValue = 0D;

    private double rho_;
    /// <summary>
    /// Calculated Rho Greek value.
    /// Represents correct theoretical price change which occurs if Interest Rate increases by 1%.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double Rho {
      get { if ((_hasBits0 & 256) != 0) { return rho_; } else { return RhoDefaultValue; } }
      set {
        _hasBits0 |= 256;
        rho_ = value;
      }
    }
    /// <summary>Gets whether the "rho" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasRho {
      get { return (_hasBits0 & 256) != 0; }
    }
    /// <summary>Clears the value of the "rho" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearRho() {
      _hasBits0 &= ~256;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as OptionCalculationValues);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(OptionCalculationValues other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (StrikeContractId != other.StrikeContractId) return false;
      if (ScaledCoherentUnderlyingPrice != other.ScaledCoherentUnderlyingPrice) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(ImpliedVolatility, other.ImpliedVolatility)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(Theov, other.Theov)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(Delta, other.Delta)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(Gamma, other.Gamma)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(Vega, other.Vega)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(Theta, other.Theta)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(Rho, other.Rho)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasStrikeContractId) hash ^= StrikeContractId.GetHashCode();
      if (HasScaledCoherentUnderlyingPrice) hash ^= ScaledCoherentUnderlyingPrice.GetHashCode();
      if (HasImpliedVolatility) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(ImpliedVolatility);
      if (HasTheov) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(Theov);
      if (HasDelta) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(Delta);
      if (HasGamma) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(Gamma);
      if (HasVega) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(Vega);
      if (HasTheta) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(Theta);
      if (HasRho) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(Rho);
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasStrikeContractId) {
        output.WriteRawTag(8);
        output.WriteUInt32(StrikeContractId);
      }
      if (HasScaledCoherentUnderlyingPrice) {
        output.WriteRawTag(16);
        output.WriteSInt32(ScaledCoherentUnderlyingPrice);
      }
      if (HasImpliedVolatility) {
        output.WriteRawTag(25);
        output.WriteDouble(ImpliedVolatility);
      }
      if (HasTheov) {
        output.WriteRawTag(33);
        output.WriteDouble(Theov);
      }
      if (HasDelta) {
        output.WriteRawTag(41);
        output.WriteDouble(Delta);
      }
      if (HasGamma) {
        output.WriteRawTag(49);
        output.WriteDouble(Gamma);
      }
      if (HasVega) {
        output.WriteRawTag(57);
        output.WriteDouble(Vega);
      }
      if (HasTheta) {
        output.WriteRawTag(65);
        output.WriteDouble(Theta);
      }
      if (HasRho) {
        output.WriteRawTag(73);
        output.WriteDouble(Rho);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasStrikeContractId) {
        output.WriteRawTag(8);
        output.WriteUInt32(StrikeContractId);
      }
      if (HasScaledCoherentUnderlyingPrice) {
        output.WriteRawTag(16);
        output.WriteSInt32(ScaledCoherentUnderlyingPrice);
      }
      if (HasImpliedVolatility) {
        output.WriteRawTag(25);
        output.WriteDouble(ImpliedVolatility);
      }
      if (HasTheov) {
        output.WriteRawTag(33);
        output.WriteDouble(Theov);
      }
      if (HasDelta) {
        output.WriteRawTag(41);
        output.WriteDouble(Delta);
      }
      if (HasGamma) {
        output.WriteRawTag(49);
        output.WriteDouble(Gamma);
      }
      if (HasVega) {
        output.WriteRawTag(57);
        output.WriteDouble(Vega);
      }
      if (HasTheta) {
        output.WriteRawTag(65);
        output.WriteDouble(Theta);
      }
      if (HasRho) {
        output.WriteRawTag(73);
        output.WriteDouble(Rho);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (HasStrikeContractId) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(StrikeContractId);
      }
      if (HasScaledCoherentUnderlyingPrice) {
        size += 1 + pb::CodedOutputStream.ComputeSInt32Size(ScaledCoherentUnderlyingPrice);
      }
      if (HasImpliedVolatility) {
        size += 1 + 8;
      }
      if (HasTheov) {
        size += 1 + 8;
      }
      if (HasDelta) {
        size += 1 + 8;
      }
      if (HasGamma) {
        size += 1 + 8;
      }
      if (HasVega) {
        size += 1 + 8;
      }
      if (HasTheta) {
        size += 1 + 8;
      }
      if (HasRho) {
        size += 1 + 8;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(OptionCalculationValues other) {
      if (other == null) {
        return;
      }
      if (other.HasStrikeContractId) {
        StrikeContractId = other.StrikeContractId;
      }
      if (other.HasScaledCoherentUnderlyingPrice) {
        ScaledCoherentUnderlyingPrice = other.ScaledCoherentUnderlyingPrice;
      }
      if (other.HasImpliedVolatility) {
        ImpliedVolatility = other.ImpliedVolatility;
      }
      if (other.HasTheov) {
        Theov = other.Theov;
      }
      if (other.HasDelta) {
        Delta = other.Delta;
      }
      if (other.HasGamma) {
        Gamma = other.Gamma;
      }
      if (other.HasVega) {
        Vega = other.Vega;
      }
      if (other.HasTheta) {
        Theta = other.Theta;
      }
      if (other.HasRho) {
        Rho = other.Rho;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            StrikeContractId = input.ReadUInt32();
            break;
          }
          case 16: {
            ScaledCoherentUnderlyingPrice = input.ReadSInt32();
            break;
          }
          case 25: {
            ImpliedVolatility = input.ReadDouble();
            break;
          }
          case 33: {
            Theov = input.ReadDouble();
            break;
          }
          case 41: {
            Delta = input.ReadDouble();
            break;
          }
          case 49: {
            Gamma = input.ReadDouble();
            break;
          }
          case 57: {
            Vega = input.ReadDouble();
            break;
          }
          case 65: {
            Theta = input.ReadDouble();
            break;
          }
          case 73: {
            Rho = input.ReadDouble();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            StrikeContractId = input.ReadUInt32();
            break;
          }
          case 16: {
            ScaledCoherentUnderlyingPrice = input.ReadSInt32();
            break;
          }
          case 25: {
            ImpliedVolatility = input.ReadDouble();
            break;
          }
          case 33: {
            Theov = input.ReadDouble();
            break;
          }
          case 41: {
            Delta = input.ReadDouble();
            break;
          }
          case 49: {
            Gamma = input.ReadDouble();
            break;
          }
          case 57: {
            Vega = input.ReadDouble();
            break;
          }
          case 65: {
            Theta = input.ReadDouble();
            break;
          }
          case 73: {
            Rho = input.ReadDouble();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Option calculation response
  /// </summary>
  public sealed partial class OptionCalculationReport : pb::IMessage<OptionCalculationReport>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<OptionCalculationReport> _parser = new pb::MessageParser<OptionCalculationReport>(() => new OptionCalculationReport());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<OptionCalculationReport> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::MarketData2.MarketData2Reflection.Descriptor.MessageTypes[17]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public OptionCalculationReport() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public OptionCalculationReport(OptionCalculationReport other) : this() {
      _hasBits0 = other._hasBits0;
      requestId_ = other.requestId_;
      statusCode_ = other.statusCode_;
      upToUtcTime_ = other.upToUtcTime_;
      interestRate_ = other.interestRate_;
      scaledUnderlyingPrice_ = other.scaledUnderlyingPrice_;
      values_ = other.values_.Clone();
      details_ = other.details_ != null ? other.details_.Clone() : null;
      isReportComplete_ = other.isReportComplete_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public OptionCalculationReport Clone() {
      return new OptionCalculationReport(this);
    }

    /// <summary>Field number for the "request_id" field.</summary>
    public const int RequestIdFieldNumber = 1;
    private readonly static uint RequestIdDefaultValue = 0;

    private uint requestId_;
    /// <summary>
    /// Request ID.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint RequestId {
      get { if ((_hasBits0 & 1) != 0) { return requestId_; } else { return RequestIdDefaultValue; } }
      set {
        _hasBits0 |= 1;
        requestId_ = value;
      }
    }
    /// <summary>Gets whether the "request_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasRequestId {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "request_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearRequestId() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "status_code" field.</summary>
    public const int StatusCodeFieldNumber = 2;
    private readonly static uint StatusCodeDefaultValue = 0;

    private uint statusCode_;
    /// <summary>
    /// Subscription result.
    /// This field is associated with StatusCode enum type.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint StatusCode {
      get { if ((_hasBits0 & 2) != 0) { return statusCode_; } else { return StatusCodeDefaultValue; } }
      set {
        _hasBits0 |= 2;
        statusCode_ = value;
      }
    }
    /// <summary>Gets whether the "status_code" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasStatusCode {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "status_code" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearStatusCode() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "up_to_utc_time" field.</summary>
    public const int UpToUtcTimeFieldNumber = 3;
    private readonly static long UpToUtcTimeDefaultValue = 0L;

    private long upToUtcTime_;
    /// <summary>
    /// Timestamp of the latest event that caused calculations included in this report.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long UpToUtcTime {
      get { if ((_hasBits0 & 4) != 0) { return upToUtcTime_; } else { return UpToUtcTimeDefaultValue; } }
      set {
        _hasBits0 |= 4;
        upToUtcTime_ = value;
      }
    }
    /// <summary>Gets whether the "up_to_utc_time" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasUpToUtcTime {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "up_to_utc_time" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearUpToUtcTime() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "interest_rate" field.</summary>
    public const int InterestRateFieldNumber = 4;
    private readonly static double InterestRateDefaultValue = 0D;

    private double interestRate_;
    /// <summary>
    /// Interest Rate within a range (0;1], where 1 means 100%, 0.1 means 10%.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double InterestRate {
      get { if ((_hasBits0 & 8) != 0) { return interestRate_; } else { return InterestRateDefaultValue; } }
      set {
        _hasBits0 |= 8;
        interestRate_ = value;
      }
    }
    /// <summary>Gets whether the "interest_rate" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasInterestRate {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "interest_rate" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearInterestRate() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "scaled_underlying_price" field.</summary>
    public const int ScaledUnderlyingPriceFieldNumber = 5;
    private readonly static int ScaledUnderlyingPriceDefaultValue = 0;

    private int scaledUnderlyingPrice_;
    /// <summary>
    /// Latest quote price of the underlying instrument at the moment of calculations.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int ScaledUnderlyingPrice {
      get { if ((_hasBits0 & 16) != 0) { return scaledUnderlyingPrice_; } else { return ScaledUnderlyingPriceDefaultValue; } }
      set {
        _hasBits0 |= 16;
        scaledUnderlyingPrice_ = value;
      }
    }
    /// <summary>Gets whether the "scaled_underlying_price" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasScaledUnderlyingPrice {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "scaled_underlying_price" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearScaledUnderlyingPrice() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "values" field.</summary>
    public const int ValuesFieldNumber = 6;
    private static readonly pb::FieldCodec<global::MarketData2.OptionCalculationValues> _repeated_values_codec
        = pb::FieldCodec.ForMessage(50, global::MarketData2.OptionCalculationValues.Parser);
    private readonly pbc::RepeatedField<global::MarketData2.OptionCalculationValues> values_ = new pbc::RepeatedField<global::MarketData2.OptionCalculationValues>();
    /// <summary>
    /// Calculated values.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::MarketData2.OptionCalculationValues> Values {
      get { return values_; }
    }

    /// <summary>Field number for the "details" field.</summary>
    public const int DetailsFieldNumber = 7;
    private global::Shared1.Text details_;
    /// <summary>
    /// Optional failure details.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Shared1.Text Details {
      get { return details_; }
      set {
        details_ = value;
      }
    }

    /// <summary>Field number for the "is_report_complete" field.</summary>
    public const int IsReportCompleteFieldNumber = 8;
    private readonly static bool IsReportCompleteDefaultValue = true;

    private bool isReportComplete_;
    /// <summary>
    /// True means that requested data is complete at the moment, false means more report messages are expected for completeness.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsReportComplete {
      get { if ((_hasBits0 & 32) != 0) { return isReportComplete_; } else { return IsReportCompleteDefaultValue; } }
      set {
        _hasBits0 |= 32;
        isReportComplete_ = value;
      }
    }
    /// <summary>Gets whether the "is_report_complete" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasIsReportComplete {
      get { return (_hasBits0 & 32) != 0; }
    }
    /// <summary>Clears the value of the "is_report_complete" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearIsReportComplete() {
      _hasBits0 &= ~32;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as OptionCalculationReport);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(OptionCalculationReport other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (RequestId != other.RequestId) return false;
      if (StatusCode != other.StatusCode) return false;
      if (UpToUtcTime != other.UpToUtcTime) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(InterestRate, other.InterestRate)) return false;
      if (ScaledUnderlyingPrice != other.ScaledUnderlyingPrice) return false;
      if(!values_.Equals(other.values_)) return false;
      if (!object.Equals(Details, other.Details)) return false;
      if (IsReportComplete != other.IsReportComplete) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasRequestId) hash ^= RequestId.GetHashCode();
      if (HasStatusCode) hash ^= StatusCode.GetHashCode();
      if (HasUpToUtcTime) hash ^= UpToUtcTime.GetHashCode();
      if (HasInterestRate) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(InterestRate);
      if (HasScaledUnderlyingPrice) hash ^= ScaledUnderlyingPrice.GetHashCode();
      hash ^= values_.GetHashCode();
      if (details_ != null) hash ^= Details.GetHashCode();
      if (HasIsReportComplete) hash ^= IsReportComplete.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasRequestId) {
        output.WriteRawTag(8);
        output.WriteUInt32(RequestId);
      }
      if (HasStatusCode) {
        output.WriteRawTag(16);
        output.WriteUInt32(StatusCode);
      }
      if (HasUpToUtcTime) {
        output.WriteRawTag(24);
        output.WriteInt64(UpToUtcTime);
      }
      if (HasInterestRate) {
        output.WriteRawTag(33);
        output.WriteDouble(InterestRate);
      }
      if (HasScaledUnderlyingPrice) {
        output.WriteRawTag(40);
        output.WriteSInt32(ScaledUnderlyingPrice);
      }
      values_.WriteTo(output, _repeated_values_codec);
      if (details_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(Details);
      }
      if (HasIsReportComplete) {
        output.WriteRawTag(64);
        output.WriteBool(IsReportComplete);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasRequestId) {
        output.WriteRawTag(8);
        output.WriteUInt32(RequestId);
      }
      if (HasStatusCode) {
        output.WriteRawTag(16);
        output.WriteUInt32(StatusCode);
      }
      if (HasUpToUtcTime) {
        output.WriteRawTag(24);
        output.WriteInt64(UpToUtcTime);
      }
      if (HasInterestRate) {
        output.WriteRawTag(33);
        output.WriteDouble(InterestRate);
      }
      if (HasScaledUnderlyingPrice) {
        output.WriteRawTag(40);
        output.WriteSInt32(ScaledUnderlyingPrice);
      }
      values_.WriteTo(ref output, _repeated_values_codec);
      if (details_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(Details);
      }
      if (HasIsReportComplete) {
        output.WriteRawTag(64);
        output.WriteBool(IsReportComplete);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (HasRequestId) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(RequestId);
      }
      if (HasStatusCode) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(StatusCode);
      }
      if (HasUpToUtcTime) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(UpToUtcTime);
      }
      if (HasInterestRate) {
        size += 1 + 8;
      }
      if (HasScaledUnderlyingPrice) {
        size += 1 + pb::CodedOutputStream.ComputeSInt32Size(ScaledUnderlyingPrice);
      }
      size += values_.CalculateSize(_repeated_values_codec);
      if (details_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Details);
      }
      if (HasIsReportComplete) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(OptionCalculationReport other) {
      if (other == null) {
        return;
      }
      if (other.HasRequestId) {
        RequestId = other.RequestId;
      }
      if (other.HasStatusCode) {
        StatusCode = other.StatusCode;
      }
      if (other.HasUpToUtcTime) {
        UpToUtcTime = other.UpToUtcTime;
      }
      if (other.HasInterestRate) {
        InterestRate = other.InterestRate;
      }
      if (other.HasScaledUnderlyingPrice) {
        ScaledUnderlyingPrice = other.ScaledUnderlyingPrice;
      }
      values_.Add(other.values_);
      if (other.details_ != null) {
        if (details_ == null) {
          Details = new global::Shared1.Text();
        }
        Details.MergeFrom(other.Details);
      }
      if (other.HasIsReportComplete) {
        IsReportComplete = other.IsReportComplete;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            RequestId = input.ReadUInt32();
            break;
          }
          case 16: {
            StatusCode = input.ReadUInt32();
            break;
          }
          case 24: {
            UpToUtcTime = input.ReadInt64();
            break;
          }
          case 33: {
            InterestRate = input.ReadDouble();
            break;
          }
          case 40: {
            ScaledUnderlyingPrice = input.ReadSInt32();
            break;
          }
          case 50: {
            values_.AddEntriesFrom(input, _repeated_values_codec);
            break;
          }
          case 58: {
            if (details_ == null) {
              Details = new global::Shared1.Text();
            }
            input.ReadMessage(Details);
            break;
          }
          case 64: {
            IsReportComplete = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            RequestId = input.ReadUInt32();
            break;
          }
          case 16: {
            StatusCode = input.ReadUInt32();
            break;
          }
          case 24: {
            UpToUtcTime = input.ReadInt64();
            break;
          }
          case 33: {
            InterestRate = input.ReadDouble();
            break;
          }
          case 40: {
            ScaledUnderlyingPrice = input.ReadSInt32();
            break;
          }
          case 50: {
            values_.AddEntriesFrom(ref input, _repeated_values_codec);
            break;
          }
          case 58: {
            if (details_ == null) {
              Details = new global::Shared1.Text();
            }
            input.ReadMessage(Details);
            break;
          }
          case 64: {
            IsReportComplete = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the OptionCalculationReport message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public enum StatusCode {
        /// <summary>
        //// success codes (1 - 99)
        /// Request is processed and subscription is established.
        /// </summary>
        [pbr::OriginalName("STATUS_CODE_SUBSCRIBED")] Subscribed = 1,
        /// <summary>
        /// Subscription is dropped by a client request.
        /// </summary>
        [pbr::OriginalName("STATUS_CODE_DROPPED")] Dropped = 2,
        /// <summary>
        /// Unsolicited information update because of subscription.
        /// </summary>
        [pbr::OriginalName("STATUS_CODE_UPDATE")] Update = 3,
        /// <summary>
        /// Currently subscription is disconnected. Possible reasons: communication issues, metadata update.
        /// NOTE: Clients should not resubscribe in this case, the server will restore subscription with
        /// sending STATUS_CODE_SUBSCRIBED status.
        /// </summary>
        [pbr::OriginalName("STATUS_CODE_DISCONNECTED")] Disconnected = 4,
        /// <summary>
        //// failure codes (100+)
        /// general failure
        /// </summary>
        [pbr::OriginalName("STATUS_CODE_FAILURE")] Failure = 101,
        /// <summary>
        /// Subscription parameters are invalid.
        /// </summary>
        [pbr::OriginalName("STATUS_CODE_INVALID_PARAMS")] InvalidParams = 102,
        /// <summary>
        /// The user is not allowed to be subscribed to this Instrument.
        /// </summary>
        [pbr::OriginalName("STATUS_CODE_ACCESS_DENIED")] AccessDenied = 103,
        /// <summary>
        /// The subscription count limit has been violated.
        /// </summary>
        [pbr::OriginalName("STATUS_CODE_SUBSCRIPTION_LIMIT_VIOLATION")] SubscriptionLimitViolation = 104,
        /// <summary>
        /// The request rate limit has been violated.
        /// </summary>
        [pbr::OriginalName("STATUS_CODE_REQUEST_RATE_LIMIT_VIOLATION")] RequestRateLimitViolation = 105,
        /// <summary>
        /// Market data source was deleted because of expiration or for another reason.
        /// </summary>
        [pbr::OriginalName("STATUS_CODE_DELETED")] Deleted = 106,
      }

    }
    #endregion

  }

  #endregion

}

#endregion Designer generated code
